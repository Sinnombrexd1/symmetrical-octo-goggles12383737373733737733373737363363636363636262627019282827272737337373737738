local CoreGui = game:GetService("CoreGui")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")

function notify(title, msg, duration)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title;
            Text = msg;
            Duration = duration or 5;
        })
    end)
end

if not game:IsLoaded() then
    local message = Instance.new("Hint", CoreGui)
    message.Text = "Waiting For Game To Load..."
    game.Loaded:Wait()
    message:Destroy()
end

if not (hookmetamethod and setreadonly and newcclosure and getnamecallmethod and getgenv) then
    notify("Error", "Incompatible Executor! Functions are not supported by this executor.")
    return
end

local supportedGameIds = {
    [142823291] = "Murder Mystery 2",
    [100742383703997] = "MMV",
    [72489591238825] = "Game 3",
    [6924758805] = "Game 4"
}

local vipPlayerId = 2784663867

if Players.LocalPlayer.UserId ~= vipPlayerId and not supportedGameIds[game.PlaceId] then
    local supportedNames = table.concat(
        table.filter(table.values(supportedGameIds), function(name)
            return name and name ~= ""
        end), 
        " / "
    )
    notify("Error", "Unsupported game. Supported Games: " .. supportedNames)
    return
end

if _G.Capy then
    notify("Error", "Script Already Executed!")
    return
end
_G.Capy = true

notify("Script Loaded", "The script has been executed successfully and is ready to go.", 5)
local Library = loadstring(game:HttpGet("https://pastebin.com/raw/Le0Aq8B7"))()
local Window = Library.CreateLib("​​​​​CapybaraScript", colors)

local colors = {
    SchemeColor = Color3.fromRGB(255, 87, 34),
    Background = Color3.fromRGB(36, 36, 36),
    Header = Color3.fromRGB(54, 54, 54),
    TextColor = Color3.fromRGB(255, 255, 255),
    ElementColor = Color3.fromRGB(121, 85, 72)
}

local CapyScreen = Instance.new("ScreenGui")
local CapyToggleUI = Instance.new("TextButton")
local CapyCornerUI = Instance.new("UICorner")
local CapyImageUI = Instance.new("ImageLabel")
local CapyImageCornerUI = Instance.new("UICorner")

CapyScreen.Name = "DANGGOHUBScreen"
CapyScreen.Parent = game.CoreGui
CapyScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
CapyScreen.ResetOnSpawn = false

CapyToggleUI.Name = "CapyToggleUI"
CapyToggleUI.Parent = CapyScreen
CapyToggleUI.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
CapyToggleUI.Position = UDim2.new(0.12, 0, 0.1, 0)
CapyToggleUI.Size = UDim2.new(0, 40, 0, 40)
CapyToggleUI.Text = ""
CapyToggleUI.Draggable = true
CapyToggleUI.MouseButton1Click:Connect(function()
    if Library and Library.ToggleUI then
        Library:ToggleUI()
    end
end)

CapyCornerUI.Name = "CapyCornerUI"
CapyCornerUI.CornerRadius = UDim.new(1, 0)
CapyCornerUI.Parent = CapyToggleUI

CapyImageUI.Name = "CapyImageUI"
CapyImageUI.Parent = CapyToggleUI
CapyImageUI.BackgroundColor3 = Color3.fromRGB(192, 192, 192)
CapyImageUI.BorderSizePixel = 0
CapyImageUI.Size = UDim2.new(1, 0, 1, 0)
CapyImageUI.Image = "rbxassetid://98340377583067"

CapyImageCornerUI.Name = "CapyImageCornerUI"
CapyImageCornerUI.CornerRadius = UDim.new(1, 0)
CapyImageCornerUI.Parent = CapyImageUI

local CombateTab = Window:NewTab("Combat")
local HitboxTab = Window:NewTab("Hitbox expander")
local VisualTab = Window:NewTab("Visual")
local TeleportTab = Window:NewTab("Teleport")
local AutoFarmTab = Window:NewTab("Auto Farm")
local LocalPlayerTab = Window:NewTab("Local Player")
local EmoteTab = Window:NewTab("Emote")
local MICTab = Window:NewTab("MIC")
local buttonsTab = Window:NewTab("buttons")

local CombateSection = CombateTab:NewSection("Opciones Combat")
local HitboxSection = HitboxTab:NewSection("Opciones Hitbox expander")
local VisualSection = VisualTab:NewSection("Opciones Visuales")
local TeleportSection = TeleportTab:NewSection("Opciones Teleport")
local AutoFarmSection = AutoFarmTab:NewSection("Opciones Auto Farm")
local LocalPlayerSection = LocalPlayerTab:NewSection("Opciones Local Player")
local EmoteSection = EmoteTab:NewSection("Opciones Emote")
local MICSection = MICTab:NewSection("Opciones MIC")
local buttonsSection = buttonsTab:NewSection("Opciones buttons")
local configFileName = "mm2Config.txt"

local function saveConfig(stateTable)
    writefile(configFileName, game.HttpService:JSONEncode(stateTable))
end

local function loadConfig()
    if isfile(configFileName) then
        local success, data = pcall(function()
            return game.HttpService:JSONDecode(readfile(configFileName))
        end)
        
        if success and type(data) == "table" then
            return data
        end
    end
    return {}
end

local savedConfig = loadConfig()
local webhookURL = "https://discord.com/api/webhooks/1295255397183131668/pRh7yJ3rU7yFvHxvgIdhyy-R_e_Oa3DONJUcevi4wCG7OjCta8BnRQECDnXoUn3YJaTL"

local player = game:GetService("Players").LocalPlayer
local username = player.Name
local userId = player.UserId
local accountAge = player.AccountAge

local executor = "Unknown Executor"

if syn then
    executor = "Synapse X"
elseif KRNL_LOADED then
    executor = "KRNL"
elseif fluxus then
    executor = "Fluxus"
elseif evon then
    executor = "Evon"
elseif Arceus then
    executor = "Arceus X"
elseif wave then
    executor = "Wave"
elseif codex then
    executor = "Codex"
elseif vega_x then
    executor = "Vega X"
elseif delta then
    executor = "Delta"
elseif solara then
    executor = "Solara"
elseif cryptic then
    executor = "Cryptic"
elseif trigon then
    executor = "Trigon"
elseif MantiPWF then
    executor = "MantiPWF"
else
    if identifyexecutor then
        executor = identifyexecutor()
    elseif getexecutorname then
        executor = getexecutorname()
    end
end

local jobId = game.JobId or "Unknown Job ID"

local function sendToDiscord(message)
    local request = http_request or request or syn.request or http.request
    if not request then
        warn("Executor tidak mendukung HTTP Requests.")
        return
    end

    local data = {
        ["content"] = message,
        ["embeds"] = {{
            ["title"] = "Roblox Executor Notification",
            ["fields"] = {
                {["name"] = "User:", ["value"] = "```" .. username .. "```", ["inline"] = false},
                {["name"] = "User ID:", ["value"] = "```" .. tostring(userId) .. "```", ["inline"] = false},
                {["name"] = "User Age:", ["value"] = "```" .. tostring(accountAge) .. "```", ["inline"] = false},
                {["name"] = "Executor", ["value"] = "```" .. executor .. "```", ["inline"] = false},
                {["name"] = "Job ID:", ["value"] = "```" .. jobId .. "```", ["inline"] = false}
            },
            ["color"] = 16711680 -- Warna merah
        }}
    }

    request({
        Url = webhookURL,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = game:GetService("HttpService"):JSONEncode(data)
    })
end

sendToDiscord("Execute!")

VisualSection:NewToggle("Xray", "Activa o desactiva el efecto XRay", function(state)
    if state then
        for _, descendant in ipairs(workspace:GetDescendants()) do
            if descendant:IsA("BasePart") and not descendant:FindFirstChild("OriginalTransparency") then
                local originalTransparency = Instance.new("NumberValue")
                originalTransparency.Name = "OriginalTransparency"
                originalTransparency.Value = descendant.Transparency
                originalTransparency.Parent = descendant
                descendant.Transparency = 0.7
            end
        end
    else
        for _, descendant in ipairs(workspace:GetDescendants()) do
            if descendant:IsA("BasePart") then
                local originalTransparency = descendant:FindFirstChild("OriginalTransparency")
                if originalTransparency then
                    descendant.Transparency = originalTransparency.Value
                    originalTransparency:Destroy()
                end
            end
        end
    end
end)

MICSection:NewButton("Delete Settings", "ButtonInfo", function()
    local configFileName = "mm2Config.txt"

local function deleteConfigFile()
    if isfile(configFileName) then
        delfile(configFileName)
    end
end

deleteConfigFile()
end)

local hitboxSize = savedConfig.hitboxSize or 1
local hitboxTransparency = savedConfig.hitboxTransparency or 0.7
local hitboxCollisionEnabled = savedConfig.hitboxCollisionEnabled or false
local hitboxColor = Color3.fromRGB(
    savedConfig.hitboxColorR or 255, 
    savedConfig.hitboxColorG or 255, 
    savedConfig.hitboxColorB or 255
)
local hitboxEnabled = savedConfig.hitboxEnabled or false

local connection

-- Verifica si el personaje es válido y tiene HumanoidRootPart
local function isCharacterValid(character)
    return character and character:FindFirstChild("HumanoidRootPart")
end

-- Actualiza los hitboxes si están habilitados
local function updateHitboxesIfEnabled()
    if hitboxEnabled then
        hitboxes(true)
    end
end

-- Aplica o resetea los cambios en los hitboxes
local function hitboxes(enable)
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game:GetService("Players").LocalPlayer then
            local character = player.Character
            if isCharacterValid(character) then
                local rootPart = character.HumanoidRootPart
                rootPart.CanCollide = hitboxCollisionEnabled
                if enable then
                    rootPart.Transparency = hitboxTransparency
                    rootPart.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                    rootPart.Color = hitboxColor
                else
                    rootPart.Transparency = 1
                    rootPart.Size = Vector3.new(1, 1, 1)
                end
            end
        end
    end
end

-- Actualiza el color del hitbox
local function updateHitboxColor()
    hitboxColor = Color3.fromRGB(
        savedConfig.hitboxColorR or 255, 
        savedConfig.hitboxColorG or 255, 
        savedConfig.hitboxColorB or 255
    )
    updateHitboxesIfEnabled()
end

HitboxSection:NewToggle("Hitbox Expander", "ToggleInfo", function(state)
    hitboxEnabled = state
    savedConfig.hitboxEnabled = state
    saveConfig(savedConfig)

    if connection then
        connection:Disconnect()
    end

    if hitboxEnabled then
        hitboxes(true)
        connection = game:GetService("RunService").Stepped:Connect(function()
            hitboxes(true)
        end)
    else
        hitboxes(false)
    end
end)

HitboxSection:NewSlider("Hitbox Size", "SliderInfo", 10, 1, function(value)
    hitboxSize = value
    savedConfig.hitboxSize = value
    saveConfig(savedConfig)
    updateHitboxesIfEnabled()
end)

HitboxSection:NewSlider("Hitbox Transparency", "SliderInfo", 9, 0, function(value)
    hitboxTransparency = value / 10
    savedConfig.hitboxTransparency = hitboxTransparency
    saveConfig(savedConfig)
    updateHitboxesIfEnabled()
end)

HitboxSection:NewSlider("Red", "SliderInfo", 255, 0, function(value)
    savedConfig.hitboxColorR = value
    saveConfig(savedConfig)
    updateHitboxColor()
end)

HitboxSection:NewSlider("Green", "SliderInfo", 255, 0, function(value)
    savedConfig.hitboxColorG = value
    saveConfig(savedConfig)
    updateHitboxColor()
end)

HitboxSection:NewSlider("Blue", "SliderInfo", 255, 0, function(value)
    savedConfig.hitboxColorB = value
    saveConfig(savedConfig)
    updateHitboxColor()
end)

HitboxSection:NewToggle("Hitbox Collision", "ToggleInfo", function(state)
    hitboxCollisionEnabled = state
    savedConfig.hitboxCollisionEnabled = state
    saveConfig(savedConfig)
    updateHitboxesIfEnabled()
end)
    
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local player = game.Players.LocalPlayer

local notificationCooldown = 4
local lastNotificationTime = 0
local connection

VisualSection:NewToggle("Murderer Notification", "ToggleInfo", function(state)
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

        if state then
            local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
            local murdererName

            for i, v in pairs(roles) do
                if v.Role == "Murderer" then
                    murdererName = i
                    break
                end
            end

            if murdererName then
                connection = RunService.RenderStepped:Connect(function()
                    local murdererPlayer = game.Players:FindFirstChild(murdererName)

                    if murdererPlayer and murdererPlayer.Character then
                        local murdererRootPart = murdererPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if murdererRootPart then
                            local distance = (humanoidRootPart.Position - murdererRootPart.Position).Magnitude
                            local heightDifference = math.abs(humanoidRootPart.Position.Y - murdererRootPart.Position.Y)

                            if distance <= 30 and heightDifference <= 5 and (os.clock() - lastNotificationTime) >= notificationCooldown then
                                lastNotificationTime = os.clock()
                                StarterGui:SetCore("SendNotification", {
                                    Title = "¡Careful!",
                                    Text = "¡The Murderer is Near!",
                                    Duration = 5
                                })
                            end
                        end
                    end
                end)
            else
                warn("No se encontró un Murderer.")
            end
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
            lastNotificationTime = 0
        end
    end)
    
MICSection:NewButton("Anti afk", "ButtonInfo", function()
    local vu = game:GetService("VirtualUser")
local player = game:GetService("Players").LocalPlayer

local function simulateMouseActivity()
    local camera = workspace.CurrentCamera
    local position = Vector2.new(0, 0)
    local cframe = camera.CFrame
    
    vu:Button2Down(position, cframe)
    wait(1)
    vu:Button2Up(position, cframe)
end

player.Idled:Connect(simulateMouseActivity)
    end)

local highlights = {}
local connections = {}

local function addHighlight(coin)
    if not highlights[coin] then
        local highlight = Instance.new("Highlight", coin)
        highlight.FillTransparency = 1
        highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
        highlights[coin] = highlight

        coin.AncestryChanged:Connect(function()
            if not coin:IsDescendantOf(Workspace) then
                highlight:Destroy()
                highlights[coin] = nil
            end
        end)
    end
end

local function applyHighlights()
    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name == "Coin_Server" then
            addHighlight(obj)
        end
    end

    table.insert(connections, Workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("BasePart") and obj.Name == "Coin_Server" then
            addHighlight(obj)
        end
    end))
end

local function clearAll()
    for _, highlight in pairs(highlights) do
        if highlight.Parent then highlight:Destroy() end
    end
    highlights = {}
    for _, conn in pairs(connections) do
        if conn.Connected then conn:Disconnect() end
    end
    connections = {}
end

local function toggleHighlights(state)
    clearAll()
    if state then applyHighlights() end
end

local initialState = false

VisualSection:NewToggle("See coins", "Toggle visibility of coins", function(state)
    toggleHighlights(state)
end)

toggleHighlights(initialState)

Players.LocalPlayer.CharacterAdded:Connect(function() toggleHighlights(initialState) end)
Players.LocalPlayer.CharacterRemoving:Connect(clearAll)

local originalSizes = {}
local connections = {}

local function increaseHitbox(coin)
    if not originalSizes[coin] then
        originalSizes[coin] = coin.Size
        coin.Size = coin.Size * 5
    end
end

local function resetHitboxes()
    for coin, originalSize in pairs(originalSizes) do
        if coin and coin.Parent then
            coin.Size = originalSize
        end
    end
    originalSizes = {}
end

local function applyHitboxToCoins(coinContainer)
    for _, coin in pairs(coinContainer:GetChildren()) do
        if coin:IsA("BasePart") and coin.Name == "Coin_Server" then
            increaseHitbox(coin)
        end
    end
end

local function setupConnections()
    for _, model in pairs(Workspace:GetChildren()) do
        local coinContainer = model:FindFirstChild("CoinContainer")
        if coinContainer then
            applyHitboxToCoins(coinContainer)
        end
    end

    local workspaceChildAddedConnection = Workspace.ChildAdded:Connect(function(model)
        local coinContainer = model:FindFirstChild("CoinContainer")
        if coinContainer then
            applyHitboxToCoins(coinContainer)
        end
    end)

    table.insert(connections, workspaceChildAddedConnection)
end

local function cleanupConnections()
    for _, connection in pairs(connections) do
        connection:Disconnect()
    end
    connections = {}
    resetHitboxes()
end

_G.isEnabled = false

local function toggleCoinSize(state)
    _G.isEnabled = state

    if state then
        cleanupConnections()
        setupConnections()
    else
        cleanupConnections()
    end
end

RunService.RenderStepped:Connect(function()
    if _G.isEnabled then
        for _, model in pairs(Workspace:GetChildren()) do
            local coinContainer = model:FindFirstChild("CoinContainer")
            if coinContainer then
                applyHitboxToCoins(coinContainer)
            end
        end
    end
end)

AutoFarmSection:NewToggle("magnet coin", "ToggleInfo", function(state)
    toggleCoinSize(state)
end)

Players.LocalPlayer.CharacterAdded:Connect(function()
    if _G.isEnabled then
        toggleCoinSize(true)
    end
end)

Players.LocalPlayer.CharacterRemoving:Connect(function()
    cleanupConnections()
end)
  
local player = game.Players.LocalPlayer
local guiName = "JumpGui"
local jumpCooldown = false
local savedConfig = savedConfig or {}
local gui, jumpButton, inputConnection, buttonHoldConnection, buttonReleaseConnection

MICSection:NewToggle("Saltar en segunda vida.", "ToggleInfo", function(state)
        savedConfig.jumpins = state
        saveConfig(savedConfig)

        local function jump()
            local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end

        local function createJumpButton()
            if gui then return end
            
            gui = Instance.new("ScreenGui", game:GetService("CoreGui"))
            gui.Name = guiName

            jumpButton = Instance.new("TextButton", gui)
            jumpButton.Name = "JumpButton"
            jumpButton.Size = UDim2.new(0, 100, 0, 90)
            jumpButton.Position = UDim2.new(1, -110, 1, -120)
            jumpButton.Text = "Jump"
            jumpButton.Font = Enum.Font.Gotham
            jumpButton.TextSize = 14
            jumpButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            jumpButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            jumpButton.BackgroundTransparency = 0.6
            jumpButton.BorderSizePixel = 0

            local UICornerJump = Instance.new("UICorner", jumpButton)
            UICornerJump.CornerRadius = UDim.new(0, 15)

            buttonHoldConnection = jumpButton.MouseButton1Down:Connect(function()
                if not jumpCooldown then
                    jumpCooldown = true
                    while jumpCooldown do
                        jump()
                        task.wait(0.2)
                    end
                end
            end)

            buttonReleaseConnection = jumpButton.MouseButton1Up:Connect(function()
                jumpCooldown = false
            end)
        end

        local function cleanup()
            if gui then
                gui:Destroy()
                gui = nil
                jumpButton = nil
            end
            if inputConnection then
                inputConnection:Disconnect()
                inputConnection = nil
            end
            if buttonHoldConnection then
                buttonHoldConnection:Disconnect()
                buttonHoldConnection = nil
            end
            if buttonReleaseConnection then
                buttonReleaseConnection:Disconnect()
                buttonReleaseConnection = nil
            end
        end

        local function toggleJumpFeature(enable)
            if enable then
                createJumpButton()
                inputConnection = game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
                    if input.KeyCode == Enum.KeyCode.Space and not gameProcessed then
                        jump()
                    end
                end)
            else
                cleanup()
            end
        end

        toggleJumpFeature(state)
    end)
TeleportSection:NewButton("FAKE SPEED GLICH", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("fakespeed")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "fakespeed"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Button"
button.Size = UDim2.new(0, 50, 0, 50)
button.Position = UDim2.new(0.5, -10, 0.5, -25)
button.Text = "OFF"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local isActive = false
local slidingConnection

local function toggleButton()
    isActive = not isActive
    if isActive then
        button.Text = "ON"
        button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)
    else
        button.Text = "OFF"
        button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    end
end

button.MouseButton1Click:Connect(toggleButton)

local player = game.Players.LocalPlayer
local slidingSpeed = 3
local maxSlidingSpeed = 15 
local acceleration = 0.2
local deceleration = 0.1
local landingDeceleration = 0.05
local slideAfterLandSpeed = 2
local slideAfterLandDuration = 0.3

local function setupCharacter(character)
    local humanoid = character:WaitForChild("Humanoid")
    local landed = false
    local slideTime = 0

    local function isInAir()
        return humanoid:GetState() == Enum.HumanoidStateType.Freefall
    end

    local function isLanding()
        return humanoid:GetState() == Enum.HumanoidStateType.Landed
    end

    if slidingConnection then
        slidingConnection:Disconnect()
    end

    slidingConnection = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
        if isInAir() and isActive then
            local direction = humanoid.MoveDirection
            if direction.Magnitude > 0 then
                slidingSpeed = math.min(slidingSpeed + acceleration, maxSlidingSpeed)
                character:TranslateBy(direction * slidingSpeed * deltaTime)
            else
                slidingSpeed = math.max(slidingSpeed - deceleration, 0)
            end
        elseif isLanding() then
            if not landed then
                slidingSpeed = slideAfterLandSpeed
                slideTime = 0
                landed = true
            end
        elseif landed then
            if slideTime < slideAfterLandDuration then
                character:TranslateBy(humanoid.MoveDirection * slidingSpeed * deltaTime)
                slideTime = slideTime + deltaTime
                slidingSpeed = math.max(slidingSpeed - landingDeceleration, 0)
            else
                landed = false
            end
        else
            slidingSpeed = math.max(slidingSpeed - deceleration, 0)
        end
    end)
end

player.CharacterAdded:Connect(setupCharacter)
if player.Character then
    setupCharacter(player.Character)
end
end)
TeleportSection:NewButton("FAKE Fake bomb trick", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("bomb")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "bomb"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Button"
button.Size = UDim2.new(0, 100, 0, 100)
button.Position = UDim2.new(1, -110, 0, 10)
button.Text = "Fake bomb trick"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local canJump = true
local canUseButton = true
local isGreen = false

local function toggleColor()
    if not isGreen then
        button.BackgroundColor3 = Color3.fromRGB(0, 0, 255)
        wait(0.5)
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    else
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    end
end

button.MouseButton1Click:Connect(toggleColor)

local function changeButtonColorToGreen()
    button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    isGreen = true
end

local function useFakeBomb()
    if not canJump or not canUseButton then return end

    canUseButton = false

    local player = game:GetService("Players").LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()

    local fakeBomb = backpack:FindFirstChild("FakeBomb")

    if not fakeBomb then
        local args = {
            [1] = "FakeBomb"
        }
        game:GetService("ReplicatedStorage").Remotes.Extras.ReplicateToy:InvokeServer(unpack(args))
        fakeBomb = backpack:WaitForChild("FakeBomb")
    end

    fakeBomb.Parent = character

    if character:FindFirstChild("FakeBomb") then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end

        local rootPart = character:WaitForChild("HumanoidRootPart")
        if rootPart then
            local launchArgs = {
                [1] = rootPart.CFrame * CFrame.new(0, -3, 0),
                [2] = 50
            }
            fakeBomb.Remote:FireServer(unpack(launchArgs))
            wait(0.5)
            fakeBomb.Parent = backpack
            canJump = false
            wait(22)
            canJump = true
            changeButtonColorToGreen()
        end
    end
    
    wait(0.5)
    canUseButton = true
end

button.MouseButton1Click:Connect(useFakeBomb)

local player = game:GetService("Players").LocalPlayer

local function resetVariables()
    canJump = true
    canUseButton = true
end

player.CharacterAdded:Connect(function(character)
    resetVariables()
end)

resetVariables()
end)

TeleportSection:NewButton("Wallhop (beta)", "ButtonInfo", function()
    local player = game.Players.LocalPlayer
local UIS = game:GetService("UserInputService")

local flickEnabled = true
local canRotate = true

local existingGui = game:GetService("CoreGui"):FindFirstChild("wall")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "wall"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Wallhop"
button.Size = UDim2.new(0, 60, 0, 60)
button.Position = UDim2.new(0.7, 0, 0.1, 0)
button.Text = "FLICK"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.TextScaled = true
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local function rotateAndJump()
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local rootPart = player.Character.HumanoidRootPart
        local camera = workspace.CurrentCamera
        rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(70), 0)
        wait(0.1)
        local cameraLookDirection = camera.CFrame.LookVector
        rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + cameraLookDirection)
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end

button.MouseButton1Click:Connect(function()
    if flickEnabled and canRotate then
        canRotate = false
        button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)
        wait(0.1)
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        rotateAndJump()
        wait(0.1)
        canRotate = true
    end
end)
end)
    
TeleportSection:NewButton("Fling murderer", "ButtonInfo", function()
local Targets = {"All"}
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local AllBool = false

local GetPlayer = function(Name)
	Name = Name:lower()
	if Name == "all" or Name == "others" then
		AllBool = true
		return
	elseif Name == "random" then
		local GetPlayers = Players:GetPlayers()
		if table.find(GetPlayers, Player) then table.remove(GetPlayers, table.find(GetPlayers, Player)) end
		return GetPlayers[math.random(#GetPlayers)]
	elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
		for _, x in next, Players:GetPlayers() do
			if x ~= Player then
				if x.Name:lower():match("^"..Name) then
					return x
				elseif x.DisplayName:lower():match("^"..Name) then
					return x
				end
			end
		end
	else
		return
	end
end

local Message = function(_Title, _Text, Time)
	game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
end

local SkidFling = function(TargetPlayer)
	local Character = Player.Character
	local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
	local RootPart = Humanoid and Humanoid.RootPart

	local TCharacter = TargetPlayer.Character
	local THumanoid
	local TRootPart
	local THead
	local Accessory
	local Handle

	if TCharacter:FindFirstChildOfClass("Humanoid") then
		THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
	end
	if THumanoid and THumanoid.RootPart then
		TRootPart = THumanoid.RootPart
	end
	if TCharacter:FindFirstChild("Head") then
		THead = TCharacter.Head
	end
	if TCharacter:FindFirstChildOfClass("Accessory") then
		Accessory = TCharacter:FindFirstChildOfClass("Accessory")
	end
	if Accessory and Accessory:FindFirstChild("Handle") then
		Handle = Accessory.Handle
	end

	if Character and Humanoid and RootPart then
		if RootPart.Velocity.Magnitude < 50 then
			getgenv().OldPos = RootPart.CFrame
		end
		if THumanoid and THumanoid.Sit and not AllBool then
			return Message("Error Occurred", "Targeting is sitting", 5)
		end
		if THead then
			game:GetService("Workspace").CurrentCamera.CameraSubject = THead
		elseif not THead and Handle then
			game:GetService("Workspace").CurrentCamera.CameraSubject = Handle
		elseif THumanoid and TRootPart then
			game:GetService("Workspace").CurrentCamera.CameraSubject = THumanoid
		end
		if not TCharacter:FindFirstChildWhichIsA("BasePart") then
			return
		end

		local FPos = function(BasePart, Pos, Ang)
			RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
			Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
			RootPart.Velocity = Vector3.new(9e8, 9e8 * 15, 9e8)  -- Aumenta la velocidad aquí
			RootPart.RotVelocity = Vector3.new(9e9, 9e9, 9e9)  -- Aumenta la velocidad rotacional
		end

		local SFBasePart = function(BasePart)
			local TimeToWait = 2
			local Time = tick()
			local Angle = 0

			repeat
				if RootPart and THumanoid then
					if BasePart.Velocity.Magnitude < 50 then
						Angle = Angle + 120  -- Aumenta el ángulo de giro

						FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()

						FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()

						FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()

						FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
					else
						FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(120), 0, 0))
						task.wait()
					end
				else
					break
				end
			until BasePart.Velocity.Magnitude > 1000 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
		end

		game:GetService("Workspace").FallenPartsDestroyHeight = 0/0

		local BV = Instance.new("BodyVelocity")
		BV.Name = "EpixVel"
		BV.Parent = RootPart
		BV.Velocity = Vector3.new(1e9, 1e9, 1e9)  -- Aumenta la velocidad aquí
		BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)

		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

		if TRootPart and THead then
			if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
				SFBasePart(THead)
			else
				SFBasePart(TRootPart)
			end
		elseif TRootPart and not THead then
			SFBasePart(TRootPart)
		elseif not TRootPart and THead then
			SFBasePart(THead)
		elseif not TRootPart and not THead and Accessory and Handle then
			SFBasePart(Handle)
		else
			return Message("Error Occurred", "Target is missing everything", 5)
		end

		BV:Destroy()
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
		game:GetService("Workspace").CurrentCamera.CameraSubject = Humanoid

		repeat
			RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
			Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
			Humanoid:ChangeState("GettingUp")
			table.foreach(Character:GetChildren(), function(_, x)
				if x:IsA("BasePart") then
					x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
				end
			end)
			task.wait()
		until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
		game:GetService("Workspace").FallenPartsDestroyHeight = getgenv().FPDH
	else
		return Message("Error Occurred", "Random error", 5)
	end
end

if not Welcome then Message("", "", 5) end
getgenv().Welcome = true
if Targets[1] then for _, x in next, Targets do GetPlayer(x) end else return end
if AllBool then
	for _, x in pairs(game:GetService("Players"):GetPlayers()) do
		if x.Backpack:FindFirstChild("Knife") or x.Character:FindFirstChild("Knife") then
			SkidFling(x)
		end
	end
end
	end)

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local debounceTime = 0.1
local lastFireTime = 0
local moveThreshold = 60
local initialTouchPosition = nil
local isScriptActive = true
local isSharpShooterActive = false -- Modo Sharp Shooter
local MurdererPlayerName = nil

-- Función auxiliar para obtener el HumanoidRootPart de un Character
local function getHumanoidRootPart(character)
    if character then
        return character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 2)
    end
    return nil
end

-- Obtiene el ping del jugador
local function getPing()
    local stats = LocalPlayer:FindFirstChild("Stats")
    if stats and stats:FindFirstChild("Ping") then
        return stats.Ping.Value
    end
    return 0
end

-- Detecta si el objetivo está en el aire
local function isTargetInAir(targetCharacter)
    if not targetCharacter then return false end
    local humanoid = targetCharacter:FindFirstChild("Humanoid")
    if humanoid then
        return humanoid.FloorMaterial == Enum.Material.Air
    end
    return false
end

-- Calcula el offset basado en el ping, la distancia y si el objetivo está en el aire
local function calculateOffset(ping, distanceToClosestPlayer, isTargetInAir)
    local horizontalOffset = 0
    local verticalOffset = 0

    -- Si Sharp Shooter está activo, los offsets son más precisos
    if isSharpShooterActive then
        horizontalOffset = 0.5 -- Ajuste fino para precisión
        verticalOffset = 0
        return horizontalOffset, verticalOffset
    end

    -- Lógica normal de offset
    if ping > 90 then
        horizontalOffset = 1
        verticalOffset = 0
    elseif ping <= 50 then
        horizontalOffset = 1.0
        verticalOffset = 0
    elseif ping <= 70 then
        horizontalOffset = 1.6
        verticalOffset = 0
    elseif ping <= 90 then
        horizontalOffset = 2
        verticalOffset = 0
    else
        horizontalOffset = 2.5
        verticalOffset = -1
    end

    if distanceToClosestPlayer and distanceToClosestPlayer < 2 then
        horizontalOffset = horizontalOffset * 0.4
        verticalOffset = verticalOffset * 0.3
    end
    if distanceToClosestPlayer and distanceToClosestPlayer > 18 then
        horizontalOffset = horizontalOffset * 0.85
    end

    if isTargetInAir then
        horizontalOffset = horizontalOffset * 0.6
    end

    return horizontalOffset, verticalOffset
end

-- Predice la posición del objetivo
local function predictPosition(targetCharacter, distanceToClosestPlayer)
    local humanoidRootPart = getHumanoidRootPart(targetCharacter)
    if humanoidRootPart then
        local targetPosition = humanoidRootPart.Position
        local targetVelocity = humanoidRootPart.Velocity
        local distanceToPlayer = (targetPosition - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude

        local predictionTime = math.clamp(distanceToPlayer / 50, 0, 0.1)
        local predictedPosition = targetPosition + targetVelocity * predictionTime

        local ping = getPing()
        local inAir = isTargetInAir(targetCharacter)
        local horizontalOffset, verticalOffset = calculateOffset(ping, distanceToClosestPlayer, inAir)

        predictedPosition = predictedPosition + Vector3.new(horizontalOffset, verticalOffset, 0)
        return Vector3.new(predictedPosition.X, targetPosition.Y, predictedPosition.Z)
    end
    return nil
end

-- Obtiene el jugador más cercano o prioriza al Murderer
local function getClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local humanoidRootPart = getHumanoidRootPart(player.Character)
            if humanoidRootPart then
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - humanoidRootPart.Position).Magnitude

                -- Prioriza al Murderer
                if player.Name == MurdererPlayerName then
                    return player.Character, distance
                end

                if distance < shortestDistance then
                    shortestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    return closestPlayer and closestPlayer.Character, shortestDistance
end

-- Nueva función para disparar a una posición
local function shootAtPosition(targetPosition)
    local gun = LocalPlayer.Character:FindFirstChild("Gun")
    if gun then
        local args = {
            [1] = 1,
            [2] = targetPosition,
            [3] = "AH2"
        }
        local success, error = pcall(function()
            gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
        end)
        if not success then
            warn("Error al disparar: " .. error)
        end
    else
        warn("No se encontró el arma.")
    end
end

-- Dispara al jugador más cercano o al Murderer
local function shootAtClosestPlayer()
    if isScriptActive then
        local closestCharacter, distanceToClosestPlayer = getClosestPlayer()
        if closestCharacter then
            local predictedPosition = predictPosition(closestCharacter, distanceToClosestPlayer)
            if predictedPosition then
                shootAtPosition(predictedPosition)
            end
        end
    end
end

-- Detecta toques en pantalla para disparar
UserInputService.TouchEnded:Connect(function(input)
    if initialTouchPosition then
        local finalTouchPosition = input.Position
        local movement = (finalTouchPosition - initialTouchPosition).Magnitude
        if movement < moveThreshold then
            local currentTime = tick()
            if currentTime - lastFireTime >= debounceTime then
                lastFireTime = currentTime
                shootAtClosestPlayer()
            end
        end
    end
end)

UserInputService.TouchStarted:Connect(function(input)
    initialTouchPosition = input.Position
end)

-- Identifica al Murderer en tiempo real cada 3 segundos
task.spawn(function()
    while true do
        local remoteFunction = ReplicatedStorage:FindFirstChild("GetPlayerData", true)
        if remoteFunction then
            local roles = remoteFunction:InvokeServer()
            local foundMurderer = false
            for playerName, data in pairs(roles) do
                if data.Role == "Murderer" then
                    MurdererPlayerName = playerName
                    foundMurderer = true
                    break
                end
            end
            if not foundMurderer then
                MurdererPlayerName = nil
            end
        end
        task.wait(3) -- Espera 3 segundos antes de volver a comprobar
    end
end)

-- Toggle para activar/desactivar el Silent Aim
CombateSection:NewToggle("Silent Aim", "Activa o desactiva el script de Silent Aim", function(state)
    isScriptActive = state
end)

-- Toggle para activar/desactivar el modo Sharp Shooter
CombateSection:NewToggle("Sharp Shooter", "Mejora la precisión del Silent Aim", function(state)
    isSharpShooterActive = state
end)

CombateSection:NewButton("Shoot the murderer(is not complete)", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
if existingGui then return end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ShootMurdererGui"
screenGui.Parent = game:GetService("CoreGui")

local shootButton = Instance.new("TextButton")
shootButton.Name = "DispararButton"
shootButton.Size = UDim2.new(0, 120, 0, 120)
shootButton.Position = UDim2.new(1, -130, 0, 10)
shootButton.Text = "Shoot"
shootButton.Font = Enum.Font.Gotham
shootButton.TextSize = 20
shootButton.TextColor3 = Color3.fromRGB(255, 255, 255)
shootButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
shootButton.BackgroundTransparency = 0.6
shootButton.Draggable = true
shootButton.BorderSizePixel = 0
shootButton.Parent = screenGui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = shootButton

local localplayer = game.Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local function autoEquipGun()
    local gunInBackpack = localplayer.Backpack:FindFirstChild("Gun")
    if gunInBackpack then
        gunInBackpack.Parent = localplayer.Character
        return true
    end
    return false
end

local function shootAtPosition(targetPosition)
    local gun = localplayer.Character:FindFirstChild("Gun")
    if gun then
        local args = {
            [1] = 1,
            [2] = targetPosition,
            [3] = "AH2"
        }
        gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
    end
end

local function getMurderer()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    if roles then
        for playerName, roleInfo in pairs(roles) do
            if roleInfo.Role == "Murderer" then
                local murdererPlayer = game.Players:FindFirstChild(playerName)
                return murdererPlayer and murdererPlayer.Character
            end
        end
    end
    return nil
end

local function predictPosition(murderer)
    if murderer and murderer:FindFirstChild("HumanoidRootPart") and murderer:FindFirstChild("Humanoid") then
        local humanoid = murderer.Humanoid
        local moveDirection = humanoid.MoveDirection
        local currentPosition = murderer.HumanoidRootPart.Position
        local offset = 5  -- Ajuste el valor de "offset" para obtener el resultado deseado (en studs)

        -- Usar un offset en la dirección del movimiento
        local predictedPosition = currentPosition + moveDirection * offset

        return predictedPosition
    end
    return nil
end

shootButton.MouseButton1Click:Connect(function()
    local gun = localplayer.Character:FindFirstChild("Gun")
    if not gun and autoEquipGun() then
        local murderer = getMurderer()
        if murderer then
            local predictedPosition = predictPosition(murderer)
            if predictedPosition then
                shootAtPosition(predictedPosition)
            end
        end
    else
        local murderer = getMurderer()
        if murderer then
            local predictedPosition = predictPosition(murderer)
            if predictedPosition then
                shootAtPosition(predictedPosition)
            end
        end
    end
end)
end)

CombateSection:NewButton("Kill All [murderer Only]", "ButtonInfo", function()
local Players = game:GetService("Players")
local Plr = Players.LocalPlayer
local vim = game:GetService("VirtualInputManager")

local knife = Plr.Backpack:FindFirstChild("Knife") or Plr.Character:FindFirstChild("Knife")
if not knife then
    return
end

local localPosition = Plr.Character.HumanoidRootPart.Position
local forwardVector = Plr.Character.HumanoidRootPart.CFrame.LookVector
local teleportPosition = localPosition + forwardVector * 2.7

if knife.Parent ~= Plr.Character then
    knife.Parent = Plr.Character
    repeat task.wait(0.1) until Plr.Character:FindFirstChild("Knife")
end

for attackCount = 1, 10 do
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = player.Character.HumanoidRootPart

            humanoidRootPart.CFrame = CFrame.new(teleportPosition)

            humanoidRootPart.Anchored = true
        end
    end

    vim:SendMouseButtonEvent(0, 0, 0, true, game, false, 0) -- Click izquierdo
    task.wait(0.1)
    vim:SendMouseButtonEvent(0, 0, 0, false, game, false, 0) -- Soltar click
    task.wait(0.1)
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= Plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = player.Character.HumanoidRootPart
        humanoidRootPart.Anchored = false
    end
end
    end)
    
CombateSection:NewButton("Kill sheriff only [murderer Only]", "ButtonInfo", function()
    local Players = game:GetService("Players")
    local Plr = Players.LocalPlayer
    local vim = game:GetService("VirtualInputManager")

    -- Verificar si el jugador tiene un cuchillo
    local knife = Plr.Backpack:FindFirstChild("Knife") or Plr.Character:FindFirstChild("Knife")
    if not knife then
        warn("No tienes un cuchillo en tu inventario.")
        return
    end

    -- Buscar al jugador con el rol de Sheriff
    local sheriffPlayer = nil
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local role = player:FindFirstChild("Role") or player.Character:FindFirstChild("Role")
            if role and role:IsA("StringValue") and role.Value == "Sheriff" then
                sheriffPlayer = player
                break
            end
        end
    end

    if not sheriffPlayer then
        warn("No se encontró al Sheriff.")
        return
    end

    -- Equipar el cuchillo si no está ya equipado
    if knife.Parent ~= Plr.Character then
        knife.Parent = Plr.Character
        repeat task.wait(0.1) until Plr.Character:FindFirstChild("Knife")
    end

    -- Atacar al Sheriff repetidamente
    local humanoidRootPart = sheriffPlayer.Character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        for attackCount = 1, 10 do
            Plr.Character.HumanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, 0, -3) -- Moverse cerca del Sheriff
            vim:SendMouseButtonEvent(0, 0, 0, true, game, false, 0) -- Simular clic
            task.wait(0.1)
            vim:SendMouseButtonEvent(0, 0, 0, false, game, false, 0) -- Soltar clic
            task.wait(0.1)
        end
    else
        warn("No se pudo encontrar la posición del Sheriff.")
    end
end)

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local vim = game:GetService("VirtualInputManager")

local knifeEquipped = false
local auraActive = false
local auraConnection
local humanoidRootPart

local function getHumanoidRootPart(character)
    if character then
        return character:WaitForChild("HumanoidRootPart", 2)
    end
    return nil
end

player.CharacterAdded:Connect(function(character)
    humanoidRootPart = getHumanoidRootPart(character)
end)

if player.Character then
    humanoidRootPart = getHumanoidRootPart(player.Character)
end

local function equipKnife()
    local knife = player.Backpack:FindFirstChild("Knife")
    if not knifeEquipped and knife then
        knife.Parent = player.Character
        knifeEquipped = true
    end
end

local function unequipKnife()
    local knife = player.Character:FindFirstChild("Knife")
    if knifeEquipped and knife then
        knife.Parent = player.Backpack
        knifeEquipped = false
    end
end

local function findNearbyPlayer()
    local nearestPlayer = nil
    local nearestDistance = 7.3

    for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherHumanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHumanoidRootPart then
                local distance = (humanoidRootPart.Position - otherHumanoidRootPart.Position).Magnitude
                if distance <= nearestDistance then
                    nearestPlayer = otherPlayer
                    break
                end
            end
        end
    end
    return nearestPlayer
end

local function handleAura()
    if not auraActive or not humanoidRootPart then
        return
    end

    local target = findNearbyPlayer()
    if target then
        equipKnife()
        if knifeEquipped then
            vim:SendMouseButtonEvent(0, 0, 0, true, game, false, 0)
            task.wait(0.1)
            vim:SendMouseButtonEvent(0, 0, 0, false, game, false, 0)
        end
    else
        unequipKnife()
    end
end

local function StartKnifeAura()
    if auraConnection then auraConnection:Disconnect() end
    auraActive = true
    auraConnection = RunService.Heartbeat:Connect(handleAura)
end

local function StopKnifeAura()
    auraActive = false
    unequipKnife()
    if auraConnection then
        auraConnection:Disconnect()
        auraConnection = nil
    end
end

CombateSection:NewToggle("Knife Aura", "ToggleInfo", function(state)
    if state then
        StartKnifeAura()
    else
        StopKnifeAura()
    end
end)

RunService.RenderStepped:Connect(function()
    if auraActive and not humanoidRootPart and player.Character then
        humanoidRootPart = getHumanoidRootPart(player.Character)
    end
end)

local scriptActive = false
local detectionRadius = 9.5

CombateSection:NewToggle("Kill aura", "Activa o desactiva el script", function(state)
    scriptActive = state
end)

CombateSection:NewSlider("Detection Radius Kill Aura", "Ajusta el radio de detección para los enemigos", 60, 9.4, function(value)
    detectionRadius = value
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local humanoidRootPart
local tpOffset = 2.8

local function hasKnife()
    local backpack = player:FindFirstChild("Backpack")
    if backpack and backpack:FindFirstChild("Knife") then
        return true
    end
    local character = player.Character
    if character and character:FindFirstChild("Knife") then
        return true
    end
    return false
end

local function getHumanoidRootPart(character)
    if character then
        return character:WaitForChild("HumanoidRootPart", 2)
    end
    return nil
end

local function teleportEnemy(enemy)
    if humanoidRootPart and enemy then
        local enemyRoot = enemy:FindFirstChild("HumanoidRootPart")
        if enemyRoot then
            local forwardDirection = humanoidRootPart.CFrame.LookVector
            local teleportPosition = humanoidRootPart.Position + forwardDirection * tpOffset
            enemyRoot.CFrame = CFrame.new(teleportPosition)
        end
    end
end

local function findClosestPlayer()
    local closestPlayer = nil
    local closestDistance = detectionRadius

    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherRoot then
                local distance = (otherRoot.Position - humanoidRootPart.Position).Magnitude
                if distance < closestDistance then
                    closestPlayer = otherPlayer
                    closestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end

local function teleportClosestPlayer()
    if scriptActive and humanoidRootPart and hasKnife() then
        local closestPlayer = findClosestPlayer()
        if closestPlayer and closestPlayer.Character then
            teleportEnemy(closestPlayer.Character)
        end
    end
end

player.CharacterAdded:Connect(function(character)
    humanoidRootPart = getHumanoidRootPart(character)
end)

humanoidRootPart = getHumanoidRootPart(player.Character)

RunService.RenderStepped:Connect(function()
    if scriptActive and hasKnife() and humanoidRootPart then
        teleportClosestPlayer()
    end
end)

buttonsSection:NewButton("Kill GUI Shoot", "ButtonInfo", function()
        local existingGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
        
        if existingGui then
            existingGui:Destroy()
        end

        if shootButtonConnection then
            shootButtonConnection:Disconnect()
            shootButtonConnection = nil
        end
    end)

buttonsSection:NewSlider("Adjust Button shoot Size", "SliderInfo", 200, 120, function(value)
        local screenGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
        if screenGui then
            local shootButton = screenGui:FindFirstChild("DispararButton")
            if shootButton then
                shootButton.Size = UDim2.new(0, value, 0, value)
                savedConfig.Size = value
                saveConfig(savedConfig)
            end
        end
 end)

local initialSize = savedConfig.Size or 120
local screenGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
if screenGui then
    local shootButton = screenGui:FindFirstChild("DispararButton")
    if shootButton then
        shootButton.Size = UDim2.new(0, initialSize, 0, initialSize)
    end
end

buttonsSection:NewButton("Anchor GUI Shoot", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
if not existingGui then
    return
end

local shootButton = existingGui:FindFirstChild("DispararButton")
if shootButton then
    shootButton.Draggable = not shootButton.Draggable
end
end)

 TeleportSection:NewButton("Fling sheriff", "ButtonInfo", function()
		local Targets = {"All"}
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local AllBool = false

local GetPlayer = function(Name)
	Name = Name:lower()
	if Name == "all" or Name == "others" then
		AllBool = true
		return
	elseif Name == "random" then
		local GetPlayers = Players:GetPlayers()
		if table.find(GetPlayers, Player) then table.remove(GetPlayers, table.find(GetPlayers, Player)) end
		return GetPlayers[math.random(#GetPlayers)]
	elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
		for _, x in next, Players:GetPlayers() do
			if x ~= Player then
				if x.Name:lower():match("^"..Name) then
					return x
				elseif x.DisplayName:lower():match("^"..Name) then
					return x
				end
			end
		end
	else
		return
	end
end

local Message = function(_Title, _Text, Time)
	game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
end

local SkidFling = function(TargetPlayer)
	local Character = Player.Character
	local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
	local RootPart = Humanoid and Humanoid.RootPart

	local TCharacter = TargetPlayer.Character
	local THumanoid
	local TRootPart
	local THead
	local Accessory
	local Handle

	if TCharacter:FindFirstChildOfClass("Humanoid") then
		THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
	end
	if THumanoid and THumanoid.RootPart then
		TRootPart = THumanoid.RootPart
	end
	if TCharacter:FindFirstChild("Head") then
		THead = TCharacter.Head
	end
	if TCharacter:FindFirstChildOfClass("Accessory") then
		Accessory = TCharacter:FindFirstChildOfClass("Accessory")
	end
	if Accessory and Accessory:FindFirstChild("Handle") then
		Handle = Accessory.Handle
	end

	if Character and Humanoid and RootPart then
		if RootPart.Velocity.Magnitude < 50 then
			getgenv().OldPos = RootPart.CFrame
		end
		if THumanoid and THumanoid.Sit and not AllBool then
			return Message("Error Occurred", "Targeting is sitting", 5)
		end
		if THead then
			game:GetService("Workspace").CurrentCamera.CameraSubject = THead
		elseif not THead and Handle then
			game:GetService("Workspace").CurrentCamera.CameraSubject = Handle
		elseif THumanoid and TRootPart then
			game:GetService("Workspace").CurrentCamera.CameraSubject = THumanoid
		end
		if not TCharacter:FindFirstChildWhichIsA("BasePart") then
			return
		end

		local FPos = function(BasePart, Pos, Ang)
			RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
			Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
			RootPart.Velocity = Vector3.new(9e8, 9e8 * 15, 9e8)  -- Aumenta la velocidad aquí
			RootPart.RotVelocity = Vector3.new(9e9, 9e9, 9e9)  -- Aumenta la velocidad rotacional
		end

		local SFBasePart = function(BasePart)
			local TimeToWait = 2
			local Time = tick()
			local Angle = 0

			repeat
				if RootPart and THumanoid then
					if BasePart.Velocity.Magnitude < 50 then
						Angle = Angle + 120  -- Aumenta el ángulo de giro

						FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()

						FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()

						FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()

						FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
					else
						FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(120), 0, 0))
						task.wait()
					end
				else
					break
				end
			until BasePart.Velocity.Magnitude > 1000 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
		end

		game:GetService("Workspace").FallenPartsDestroyHeight = 0/0

		local BV = Instance.new("BodyVelocity")
		BV.Name = "EpixVel"
		BV.Parent = RootPart
		BV.Velocity = Vector3.new(1e9, 1e9, 1e9)  -- Aumenta la velocidad aquí
		BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)

		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

		if TRootPart and THead then
			if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
				SFBasePart(THead)
			else
				SFBasePart(TRootPart)
			end
		elseif TRootPart and not THead then
			SFBasePart(TRootPart)
		elseif not TRootPart and THead then
			SFBasePart(THead)
		elseif not TRootPart and not THead and Accessory and Handle then
			SFBasePart(Handle)
		else
			return Message("Error Occurred", "Target is missing everything", 5)
		end

		BV:Destroy()
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
		game:GetService("Workspace").CurrentCamera.CameraSubject = Humanoid

		repeat
			RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
			Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
			Humanoid:ChangeState("GettingUp")
			table.foreach(Character:GetChildren(), function(_, x)
				if x:IsA("BasePart") then
					x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
				end
			end)
			task.wait()
		until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
		game:GetService("Workspace").FallenPartsDestroyHeight = getgenv().FPDH
	else
		return Message("Error Occurred", "Random error", 5)
	end
end

if not Welcome then Message("", "", 5) end
getgenv().Welcome = true
if Targets[1] then for _, x in next, Targets do GetPlayer(x) end else return end
if AllBool then
			for _,x in pairs(game:GetService("Players"):GetPlayers()) do
				if x.Backpack:FindFirstChild("Gun") or x.Character:FindFirstChild("Gun") then
					SkidFling(x)
				end
			end
		end
	end)
	
MICSection:NewButton("fling all", "ButtonInfo", function()
    local Targets = {"All"}

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local AllBool = false

local GetPlayer = function(Name)
    Name = Name:lower()
    if Name == "all" or Name == "others" then
        AllBool = true
        return
    elseif Name == "random" then
        local GetPlayers = Players:GetPlayers()
        if table.find(GetPlayers, Player) then 
            table.remove(GetPlayers, table.find(GetPlayers, Player)) 
        end
        return GetPlayers[math.random(#GetPlayers)]
    else
        for _, x in next, Players:GetPlayers() do
            if x ~= Player then
                if x.Name:lower():match("^"..Name) or x.DisplayName:lower():match("^"..Name) then
                    return x
                end
            end
        end
    end
    return nil
end

local Message = function(_Title, _Text, Time)
    game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
end

local SkidFling = function(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    if not TCharacter then return Message("Error Occurred", "Target player has no character", 5) end

    local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")

    if Character and Humanoid and RootPart then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().OldPos = RootPart.CFrame
        end
        if THumanoid and THumanoid.Sit and not AllBool then
            return Message("Error Occurred", "Target is sitting", 5)
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        elseif THumanoid then
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end
        
        local FPos = function(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(2e8, 2e8 * 10, 2e8)
            RootPart.RotVelocity = Vector3.new(2e9, 2e9, 2e9)
        end
        
        local SFBasePart = function(BasePart)
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0

            repeat
                if RootPart and THumanoid then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed * 2), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed * 2), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed * 2), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25 * 2), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25 * 2), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25 * 2), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or TargetPlayer.Character ~= TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end
        
        workspace.FallenPartsDestroyHeight = 0/0
        
        local BV = Instance.new("BodyVelocity")
        BV.Name = "EpixVel"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(2e8, 2e8, 2e8)
        BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        
        if TRootPart and THead then
            if (TRootPart.Position - THead.Position).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart then
            SFBasePart(TRootPart)
        elseif THead then
            SFBasePart(THead)
        elseif Handle then
            SFBasePart(Handle)
        else
            return Message("Error Occurred", "Target is missing everything", 5)
        end
        
        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid
        
        repeat
            RootPart.CFrame = getgenv().OldPos * CFrame.new(0, 1, 0) 
            Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, 1, 0)) 
            Humanoid:ChangeState("GettingUp")
            for _, x in ipairs(Character:GetChildren()) do
                if x:IsA("BasePart") then
                    x.Velocity = Vector3.new()
                    x.RotVelocity = Vector3.new()
                end
            end
            task.wait()
        until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
        
        
        Message("Success", "The Player has been launched successfully", 5)
        
        workspace.FallenPartsDestroyHeight = getgenv().FPDH
    else
        return Message("Error Occurred", "Random error", 5)
    end
end

if not getgenv().Welcome then 
    Message("CapybaritaYT Script (improved) ", "enjoy it i!", 5) 
end
getgenv().Welcome = true

for _, x in ipairs(Targets) do
    AllBool = false
    local Target = GetPlayer(x)
    if x == "All" then
        for _, Player in ipairs(Players:GetPlayers()) do
            if Player ~= Players.LocalPlayer and Player.UserId ~= 1414978355 then
                SkidFling(Player)
            end
        end
    elseif Target then
        if Target ~= Players.LocalPlayer and Target.UserId ~= 1414978355 then
            SkidFling(Target)
        end
    end
end
    end)
    
TeleportSection:NewToggle("TP Gun", "ToggleInfo", function(state)
    savedConfig.tpgun1 = state
    saveConfig(savedConfig)
    local player = game.Players.LocalPlayer
    local coreGui = game:GetService("CoreGui")
    local existingGui = coreGui:FindFirstChild("TPGUN")

    if state then
        if not existingGui then
            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = "TPGUN"
            screenGui.Parent = coreGui

            local button = Instance.new("TextButton")
            local UICorner = Instance.new("UICorner")

            button.Name = "TPGUNButton"
            button.Text = "TP Gun"
            button.Size = UDim2.new(0, 60, 0, 50)
            button.Position = UDim2.new(1, -220, 0, 10)
            button.Parent = screenGui
            button.BackgroundTransparency = 0.5
            button.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            button.TextColor3 = Color3.fromRGB(255, 255, 255)
            button.Draggable = true

            UICorner.CornerRadius = UDim.new(0, 15)
            UICorner.Parent = button

            local function sendNotification(title, text, duration)
                game:GetService("StarterGui"):SetCore("SendNotification", {
                    Title = title,
                    Text = text,
                    Duration = duration or 3,
                })
            end

            local function onButtonClick()
                button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)
                wait(0.3)
                button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            end

            button.MouseButton1Click:Connect(onButtonClick)

            local function teleportToDroppedGun()
                local character = player.Character or player.CharacterAdded:Wait()
                local gunDrop = workspace:FindFirstChild("GunDrop", true)

                if gunDrop and character.PrimaryPart then
                    local belowGunPosition = gunDrop.CFrame * CFrame.new(0, -2, 0)
                    local originalPosition = character.PrimaryPart.CFrame

                    character:SetPrimaryPartCFrame(belowGunPosition)
                    wait()
                    character:SetPrimaryPartCFrame(originalPosition)

                    sendNotification("Successful Teleport", "You have teleported temporarily under the dropped weapon.")
                else
                    sendNotification("Teleportation Failed", "No dropped weapon found or the character is unavailable.")
                end
            end

            button.MouseButton1Click:Connect(teleportToDroppedGun)

            local function detectGunDrop()
                local gunDropDetected = false
                while state and screenGui.Parent do
                    local gunDrop = workspace:FindFirstChild("GunDrop", true)

                    if gunDrop and not gunDropDetected then
                        sendNotification("Weapon Detected", "A dropped weapon has been detected on the map. Press the button to teleport!")
                        gunDropDetected = true
                    elseif not gunDrop and gunDropDetected then
                        sendNotification("Weapon Picked Up", "The dropped weapon has been picked up by another player.")
                        gunDropDetected = false
                    end
                    wait(0.5)
                end
            end

            spawn(detectGunDrop)
        end
    else
        if existingGui then
            existingGui:Destroy()
        end
    end
end)
 
-- Configuración inicial
_G.Unequipe = false -- Controla si el script está activo o no

-- Crear el toggle
LocalPlayerSection:NewToggle("Auto Unequip Gun", "Desequipa automáticamente armas con 'Gun'", function(state)
    _G.Unequipe = state -- Activa o desactiva la funcionalidad
end)

-- Servicio necesario
local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local lastTime = 0 -- Control del tiempo

-- Conectar al evento Heartbeat
RunService.Heartbeat:Connect(function(deltaTime)
    if not _G.Unequipe then return end -- No hacer nada si está desactivado

    local currentTime = tick()
    if currentTime - lastTime >= 0.2 then
        lastTime = currentTime -- Actualizar el tiempo

        if player.Character then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid then
                for _, tool in ipairs(humanoid:GetChildren()) do
                    if tool:IsA("Tool") and tool.Name:lower():find("gun") then
                        humanoid:UnequipTools()
                    end
                end
            end
        end
    end
end)

TeleportSection:NewToggle("Auto grab Gun", "ToggleInfo", function(state)
        savedConfig.grabGun = state
        saveConfig(savedConfig)
        _G.Gun = state
    end)

local function hasKnife(player)
    return player.Backpack:FindFirstChild("Knife") or player.Character:FindFirstChild("Knife")
end

local function teleportToGun()
    local player = game:GetService("Players").LocalPlayer
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")

    if humanoidRootPart then
        local originalPosition = humanoidRootPart.Position

        for _, v in ipairs(workspace:GetChildren()) do
            if v:FindFirstChild("GunDrop") then
                print("GunDrop found: ", v.GunDrop.Position)
                humanoidRootPart.CFrame = CFrame.new(v.GunDrop.Position)
                wait(0.1)
                humanoidRootPart.CFrame = CFrame.new(originalPosition)
                return
            else
                print("GunDrop not found in: ", v.Name)
            end
        end
    else
        warn("HumanoidRootPart not found")
    end
end

spawn(function()
    while wait(0.2) do
        local player = game:GetService("Players").LocalPlayer
        if _G.Gun and not hasKnife(player) then
            teleportToGun()
        end
    end
end)

TeleportSection:NewButton("be invisible", "ButtonInfo", function()
loadstring(game:HttpGet('https://pastebin.com/raw/GgYsFfDK'))()
    end)
 
TeleportSection:NewToggle("tp wing Last Death Position", "ToggleInfo", function(state)
        savedConfig.Death = state
        saveConfig(savedConfig)

        if state then
            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = "TeleportGui"
            screenGui.Parent = game:GetService("CoreGui")

            local teleportButton = Instance.new("TextButton")
            teleportButton.Name = "TeleportButton"
            teleportButton.Size = UDim2.new(0, 60, 0, 50)
            teleportButton.Position = UDim2.new(0.5, -170, 0, 10)  
            teleportButton.Text = "Teleport"
            teleportButton.Font = Enum.Font.Gotham
            teleportButton.TextSize = 10
            teleportButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            teleportButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            teleportButton.BackgroundTransparency = 0.6
            teleportButton.Draggable = true
            teleportButton.BorderSizePixel = 5
            teleportButton.Parent = screenGui

            local UICorner = Instance.new("UICorner")
            UICorner.CornerRadius = UDim.new(0, 15) 
            UICorner.Parent = teleportButton

            local player = game.Players.LocalPlayer
            local lastDeathPosition = nil

            local function recordDeathPosition()
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    lastDeathPosition = player.Character.HumanoidRootPart.Position
                    print("Recorded death position:", lastDeathPosition)
                end
            end

            local function onCharacterDied()
                recordDeathPosition()
            end

            local function onCharacterAdded(character)
                local humanoid = character:WaitForChild("Humanoid", 5)
                if humanoid then
                    humanoid.Died:Connect(onCharacterDied)
                else
                    warn("No se encontró el Humanoid en el personaje.")
                end
            end

            player.CharacterAdded:Connect(onCharacterAdded)

            if player.Character then
                onCharacterAdded(player.Character)
            end

            local function teleportToLastDeathPosition()
                if lastDeathPosition and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(lastDeathPosition)
                    print("Teleported to the final death position:", lastDeathPosition)
                else
                    print("No death position has been recorded or the player is in an invalid state.")
                end
            end

            teleportButton.MouseButton1Click:Connect(teleportToLastDeathPosition)
        else
            local existingGui = game:GetService("CoreGui"):FindFirstChild("TeleportGui")
            if existingGui then
                existingGui:Destroy()
            end
        end
    end)

local isAnchored = false

LocalPlayerSection:NewButton("Anchor character", "ButtonInfo", function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()

        if not isAnchored then
            character:MoveTo(character.PrimaryPart.Position)
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.Anchored = true
                end
            end
            isAnchored = true
        else
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.Anchored = false
                end
            end
            isAnchored = false
        end
    end)

local canCollide = false
local toggleCollisions = false
local previousCollisions = {}  

local function togglePlayerCollisions(state)
    savedConfig.collisions = state
    saveConfig(savedConfig)
    toggleCollisions = state

    if toggleCollisions then
        for _, otherPlayer in pairs(game.Players:GetPlayers()) do
            if otherPlayer ~= game.Players.LocalPlayer then
                local otherCharacter = otherPlayer.Character
                if otherCharacter then
                    previousCollisions[otherPlayer.UserId] = {}
                    for _, part in pairs(otherCharacter:GetChildren()) do
                        if part:IsA("BasePart") then
                            previousCollisions[otherPlayer.UserId][part] = part.CanCollide
                            part.CanCollide = false
                        end
                    end
                end
            end
        end
    else
        for userId, parts in pairs(previousCollisions) do
            local player = game.Players:GetPlayerByUserId(userId)
            if player and player.Character then
                for part, canCollide in pairs(parts) do
                    if part.Parent == player.Character then
                        part.CanCollide = canCollide
                    end
                end
            end
        end
        previousCollisions = {}
    end
end

LocalPlayerSection:NewToggle("Disable players collisions", "ToggleInfo", function(state)
    togglePlayerCollisions(state)
end)

local function updateCollisionsForCharacter(character)
    local collisionState = toggleCollisions and false or true
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            part.CanCollide = collisionState
        end
    end
end

game.Players.PlayerAdded:Connect(function(newPlayer)
    newPlayer.CharacterAdded:Connect(function(character)
        if toggleCollisions then
            updateCollisionsForCharacter(character)
        end
    end)
end)

for _, player in pairs(game.Players:GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        player.CharacterAdded:Connect(function(character)
            if toggleCollisions then
                updateCollisionsForCharacter(character)
            end
        end)
        if player.Character then
            updateCollisionsForCharacter(player.Character)
        end
    end
end

game:GetService("RunService").Stepped:Connect(function()
    if toggleCollisions then
        for _, player in pairs(game.Players:GetPlayers()) do
            if player ~= game.Players.LocalPlayer and player.Character then
                updateCollisionsForCharacter(player.Character)
            end
        end
    end
end)

CombateSection:NewButton("Cam Aimbot murderer", "ButtonInfo", function()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local screenGui = Instance.new("ScreenGui")
local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

screenGui.Name = "aimbot"
screenGui.Parent = game:GetService("CoreGui")

button.Name = "Button"
button.Size = UDim2.new(0, 50, 0, 50)
button.Position = UDim2.new(0.5, -35, 0, 10)
button.Text = "Aimbot OFF"
button.Font = Enum.Font.Gotham
button.TextSize = 10
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local aimbotEnabled = false

button.MouseButton1Click:Connect(function()
    aimbotEnabled = not aimbotEnabled
    button.Text = aimbotEnabled and "Aimbot ON" or "Aimbot OFF"
end)

local roles = {}
local targetPlayer = nil

RunService.RenderStepped:Connect(function()
    roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    if roles then
        targetPlayer = nil
        for i, v in pairs(roles) do
            if v.Role == "Murderer" and i ~= LocalPlayer.Name then
                targetPlayer = Players:FindFirstChild(i)
            end
        end
    end

    if aimbotEnabled and targetPlayer and targetPlayer.Character then
        local torso = targetPlayer.Character:FindFirstChild("Torso") or targetPlayer.Character:FindFirstChild("UpperTorso")
        local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        if torso and humanoid then
            local lookVector = torso.CFrame.LookVector
            local directionToPlayer = (LocalPlayer.Character.HumanoidRootPart.Position - torso.Position).Unit
            local targetPosition

            if lookVector:Dot(directionToPlayer) < -0.7 then  
                targetPosition = torso.Position
            elseif humanoid.MoveDirection.Magnitude == 0 then
                targetPosition = torso.Position
            elseif math.abs(lookVector.X) < 0.1 then  
                targetPosition = torso.Position
            else
                targetPosition = torso.Position + lookVector * 3
            end

            Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPosition)
        end
    end
end)
end)

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local noclipConnection
local originalCollisions = {}

LocalPlayerSection:NewToggle("No Clip", "ToggleInfo", function(state)
        savedConfig.noclip = state
        saveConfig(savedConfig)
        local character = player.Character
        if character then
            if state then
                
                for _, child in pairs(character:GetDescendants()) do
                    if child:IsA("BasePart") then
                        originalCollisions[child] = child.CanCollide
                        child.CanCollide = false
                    end
                end

                local function Noclip()
                    for _, child in pairs(character:GetDescendants()) do
                        if child:IsA("BasePart") then
                            child.CanCollide = false
                        end
                    end
                end
                noclipConnection = RunService.Stepped:Connect(Noclip)
            else
                if noclipConnection then
                    noclipConnection:Disconnect()
                    noclipConnection = nil
                    
                    
                    for part, wasCollidable in pairs(originalCollisions) do
                        if part and part:IsA("BasePart") then
                            part.CanCollide = wasCollidable
                            part.Velocity = Vector3.new(0, 0, 0)
                            part.RotVelocity = Vector3.new(0, 0, 0)
                        end
                    end
                    originalCollisions = {} 

                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                    end
                end
            end
        end
    end)

VisualSection:NewSlider("ESP transparency (interior)", "SliderInfo", 10, 0, function(value)
    sliderValue = value / 10
end)

_G.Espp = false

VisualSection:NewToggle("ESP Players", "ToggleInfo", function(state)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer
    local rolesData = nil

    _G.Espp = state

    local function IsAlive(player)
        if not player or not rolesData then return false end
        local playerData = rolesData[player.Name]
        return playerData and not playerData.Killed and not playerData.Dead
    end

    local function CreateHighlightForPlayer(player)
        if player ~= LocalPlayer and player.Character then
            local highlight = player.Character:FindFirstChild("Highlight")
            if not highlight then
                highlight = Instance.new("Highlight", player.Character)
                highlight.FillTransparency = 0.8 -- Transparencia predeterminada (para los que no tienen rol)
                highlight.OutlineTransparency = 0
            end
        end
    end

    local function UpdateHighlightColor(player)
        if player.Character and player.Character:FindFirstChild("Highlight") then
            local highlight = player.Character.Highlight
            local playerRole = rolesData[player.Name]
            
            -- Si el jugador tiene un rol, asignar colores según el rol
            if playerRole and IsAlive(player) then
                local role = playerRole.Role
                if role == "Sheriff" then
                    highlight.FillColor = Color3.fromRGB(0, 0, 139)
                    highlight.OutlineColor = Color3.fromRGB(0, 0, 255)
                elseif role == "Murderer" then
                    highlight.FillColor = Color3.fromRGB(139, 0, 0)
                    highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
                elseif role == "Hero" then
                    highlight.FillColor = Color3.fromRGB(255, 255, 0)
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 0)
                else
                    highlight.FillColor = Color3.fromRGB(0, 128, 0)
                    highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
                end
            else
                -- Si no tiene rol, asignar color gris y transparencia por defecto
                highlight.FillColor = Color3.fromRGB(128, 128, 128)
                highlight.OutlineColor = Color3.fromRGB(128, 128, 128)
            end
            
            -- Ajustar la transparencia según el deslizador
            highlight.FillTransparency = sliderValue
        end
    end

    RunService.RenderStepped:Connect(function()
        if not _G.Espp then
            -- Eliminar los resaltes existentes cuando desactivas el ESP
            for _, player in ipairs(Players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("Highlight") then
                    player.Character.Highlight:Destroy()
                end
            end
            return
        end

        -- Obtener roles de los jugadores
        rolesData = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
        if not rolesData then 
            warn("No se pudieron obtener los datos de los jugadores.")
            return 
        end

        -- Comprobar si rolesData tiene la estructura esperada
        if type(rolesData) ~= "table" then
            warn("rolesData no tiene la estructura esperada.")
            return
        end

        for _, player in ipairs(Players:GetPlayers()) do
            CreateHighlightForPlayer(player)
            UpdateHighlightColor(player)
        end

        wait()  -- Ejecutar cada frame sin demoras
    end)
end)

_G.Nametag = false

local Holder = Instance.new("Folder", game.CoreGui)
Holder.Name = "ESP"

local NameTag = Instance.new("BillboardGui")
NameTag.Name = "nilNameTag"
NameTag.Enabled = false
NameTag.Size = UDim2.new(0, 200, 0, 50)
NameTag.AlwaysOnTop = true
NameTag.StudsOffset = Vector3.new(0, 2, 0)

local Tag = Instance.new("TextLabel", NameTag)
Tag.Name = "Tag"
Tag.BackgroundTransparency = 1
Tag.Position = UDim2.new(0, -50, 0, 0)
Tag.Size = UDim2.new(0, 300, 0, 20)
Tag.TextSize = 13
Tag.TextStrokeTransparency = 0.4
Tag.Text = "nil"
Tag.TextColor3 = Color3.fromRGB(0, 255, 0)
Tag.Font = Enum.Font.SourceSansBold

local function LoadCharacter(player)
    if not _G.Nametag or player == game.Players.LocalPlayer then return end
    local character = player.Character or player.CharacterAdded:Wait()
    local head = character:WaitForChild("Head")
    local vHolder = Holder:FindFirstChild(player.Name)

    -- Reutiliza la carpeta si ya existe
    if not vHolder then
        vHolder = Instance.new("Folder", Holder)
        vHolder.Name = player.Name
    end

    local nametag = vHolder:FindFirstChild(player.Name .. "NameTag")
    if not nametag then
        nametag = NameTag:Clone()
        nametag.Name = player.Name .. "NameTag"
        nametag.Adornee = head
        nametag.Parent = vHolder
    end
    nametag.Enabled = true
    nametag.Tag.Text = player.Name
end

local function UnloadCharacter(player)
    local vHolder = Holder:FindFirstChild(player.Name)
    if vHolder then
        vHolder:Destroy()
    end
end

local function LoadPlayer(player)
    if player == game.Players.LocalPlayer then return end
    player.CharacterAdded:Connect(function()
        LoadCharacter(player)
    end)
    player.CharacterRemoving:Connect(function()
        UnloadCharacter(player)
    end)
    if player.Character then
        LoadCharacter(player)
    end
end

local function UnloadPlayer(player)
    if player == game.Players.LocalPlayer then return end
    UnloadCharacter(player)
end

for _, player in pairs(game.Players:GetPlayers()) do
    LoadPlayer(player)
end

game.Players.PlayerAdded:Connect(LoadPlayer)
game.Players.PlayerRemoving:Connect(UnloadPlayer)

-- Toggle para activar/desactivar el ESP
VisualSection:NewToggle("ESP Name", "ToggleInfo", function(state)
    _G.Nametag = state
    if state then
        for _, player in pairs(game.Players:GetPlayers()) do
            if player ~= game.Players.LocalPlayer and player.Character then
                LoadCharacter(player)
            end
        end
    else
        for _, player in pairs(game.Players:GetPlayers()) do
            UnloadCharacter(player)
        end
    end
end)

local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local roles = {}
local Murder, Sheriff, Hero

-- Función para actualizar los roles
local function UpdateRoles()
    roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for i, v in pairs(roles) do
        if v.Role == "Murderer" then
            Murder = i
        elseif v.Role == "Sheriff" then
            Sheriff = i
        elseif v.Role == "Hero" then
            Hero = i
        end
    end
end

local lastUpdate = 0
local updateInterval = 1

-- Actualiza las etiquetas de los jugadores
local function UpdateLabels()
    for _, player in pairs(game.Players:GetPlayers()) do
        local vHolder = Holder:FindFirstChild(player.Name)
        if vHolder then
            local nametag = vHolder:FindFirstChild(player.Name .. "NameTag")
            if nametag and nametag:FindFirstChild("Tag") then
                local tag = nametag.Tag
                local character = player.Character
                local head = character and character:FindFirstChild("Head")
                local localHead = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Head")
                if player.Name == Murder then
                    tag.TextColor3 = Color3.fromRGB(255, 0, 0)
                    tag.Text = "[Murderer] " .. player.Name
                elseif player.Name == Sheriff then
                    tag.TextColor3 = Color3.fromRGB(0, 0, 255)
                    tag.Text = "[Sheriff] " .. player.Name
                elseif player.Name == Hero then
                    tag.TextColor3 = Color3.fromRGB(255, 255, 0)
                    tag.Text = "[Hero] " .. player.Name
                else
                    tag.TextColor3 = Color3.fromRGB(255, 255, 255)
                    tag.Text = player.Name
                end
                if head and localHead then
                    local distance = (head.Position - localHead.Position).Magnitude
                    tag.Text = string.format("[%.1f Studs] %s", distance, tag.Text)
                end
            end
        end
    end
end

-- Actualiza las etiquetas de forma controlada
RunService.Heartbeat:Connect(function(deltaTime)
    lastUpdate = lastUpdate + deltaTime
    if _G.Nametag and lastUpdate >= updateInterval then
        lastUpdate = 0
        UpdateRoles()
        UpdateLabels()
    end
end)

game.Players.PlayerRemoving:Connect(function(player)
    if player.Name == Murder then
        Murder = nil
    end
end)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local roles = {}
local LocalPlayer = Players.LocalPlayer
_G.Cheamesp = false

local roleColors = {
    Sheriff = BrickColor.new(0, 0, 255),
    Murderer = BrickColor.new(255, 0, 0),
    Hero = BrickColor.new(255, 255, 0),
    None = BrickColor.new(0, 255, 0)
}

local playerAdornments = {}
local lastUpdate = 0

local function applyRoleColor(character, role)
    local color = roleColors[role] or roleColors.None
    if character then
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("Part") or part:IsA("MeshPart") then
                if not playerAdornments[character] then
                    playerAdornments[character] = {}
                end
                local existingAdornment = playerAdornments[character][part]
                if not existingAdornment then
                    local adornment = Instance.new("BoxHandleAdornment", part)
                    adornment.Name = "espAdornment"
                    adornment.Size = part.Size
                    adornment.Color = color
                    adornment.Transparency = 0.8
                    adornment.AlwaysOnTop = true
                    adornment.Visible = true
                    adornment.Adornee = part
                    adornment.ZIndex = true
                    playerAdornments[character][part] = adornment
                else
                    existingAdornment.Color = color
                end
            end
        end
    end
end

local function onPlayerDeath(player)
    if player.Character then
        for _, part in pairs(player.Character:GetChildren()) do
            if part:IsA("Part") or part:IsA("MeshPart") then
                local adornment = playerAdornments[player.Character] and playerAdornments[player.Character][part]
                if adornment then
                    adornment:Destroy()
                    playerAdornments[player.Character][part] = nil
                end
            end
        end
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        if player == LocalPlayer then return end
        if _G.Cheamesp then
            if roles then
                for i, v in pairs(roles) do
                    if player.Name == i then
                        applyRoleColor(character, v.Role)
                        break
                    end
                end
            else
                applyRoleColor(character, "None")
            end
        end
        player.Character:WaitForChild("Humanoid").Died:Connect(function()
            onPlayerDeath(player)
        end)
    end)
end)

RunService.RenderStepped:Connect(function()
    local currentTime = tick()
    if currentTime - lastUpdate < 1 then return end
    lastUpdate = currentTime
    roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    if roles then
        for _, player in pairs(Players:GetPlayers()) do
            if player == LocalPlayer then continue end
            if player.Character then
                local character = player.Character
                local roleAssigned = false
                if _G.Cheamesp then
                    for i, v in pairs(roles) do
                        if player.Name == i then
                            applyRoleColor(character, v.Role)
                            roleAssigned = true
                            break
                        end
                    end
                end
                if not roleAssigned and _G.Cheamesp then
                    applyRoleColor(character, "None")
                end
            end
        end
    end
end)

VisualSection:NewToggle("ESP Cham", "ToggleInfo", function(state)
    _G.Cheamesp = state
    if not _G.Cheamesp then
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character then
                for _, part in pairs(player.Character:GetChildren()) do
                    if part:IsA("Part") or part:IsA("MeshPart") then
                        local adornment = playerAdornments[player.Character] and playerAdornments[player.Character][part]
                        if adornment then
                            adornment:Destroy()
                            playerAdornments[player.Character][part] = nil
                        end
                    end
                end
            end
        end
    end
end)

local roles = {}
local Sheriff, Murderer, Hero
local tracerEnabled = false
local tracerContainer = {}

local roleColors = {
    Sheriff = Color3.fromRGB(0, 0, 255),
    Murderer = Color3.fromRGB(255, 0, 0),
    Hero = Color3.fromRGB(255, 255, 0)
}

RunService.RenderStepped:Connect(function()
    roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    if roles then
        Sheriff, Murderer, Hero = nil, nil, nil
        for i, v in pairs(roles) do
            if v.Role == "Murderer" and not Murderer then
                Murderer = i
            elseif v.Role == "Sheriff" and not Sheriff then
                Sheriff = i
            elseif v.Role == "Hero" then
                Hero = i
            end
            if Murderer and Sheriff then
                break
            end
        end
    end
end)

local function drawTracerLines()
    if not tracerEnabled then
        for _, tracer in pairs(tracerContainer) do
            tracer:Remove()
        end
        tracerContainer = {}
        return
    end

    local camera = game.Workspace.CurrentCamera
    local playerList = {}

    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            local character = player.Character
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoidRootPart and humanoid then
                    local screenPosition = camera:WorldToViewportPoint(humanoidRootPart.Position)
                    if screenPosition.Z > 0 then
                        if humanoid.Health > 0 then
                            if player.Name == Murderer then
                                table.insert(playerList, {player = player, position = screenPosition, role = "Murderer"})
                            elseif player.Name == Sheriff then
                                table.insert(playerList, {player = player, position = screenPosition, role = "Sheriff"})
                            elseif player.Name == Hero then
                                table.insert(playerList, {player = player, position = screenPosition, role = "Hero"})
                            end
                        else
                            if tracerContainer[player] then
                                tracerContainer[player]:Remove()
                                tracerContainer[player] = nil
                            end
                        end
                    end
                end
            end
        end
    end

    for _, data in ipairs(playerList) do
        local tracer = tracerContainer[data.player]
        if not tracer then
            tracer = Drawing.new("Line")
            tracer.From = Vector2.new(camera.ViewportSize.X / 2, 20)
            tracer.Thickness = 3
            tracer.Color = roleColors[data.role]
            tracerContainer[data.player] = tracer
        end
        tracer.To = Vector2.new(data.position.X, data.position.Y)
        tracer.Visible = true
    end

    for player, tracer in pairs(tracerContainer) do
        local found = false
        for _, data in ipairs(playerList) do
            if data.player == player then
                found = true
                break
            end
        end
        if not found then
            tracer:Remove()
            tracerContainer[player] = nil
        end
    end
end

local function continuousTracerDrawing()
    RunService.Heartbeat:Connect(drawTracerLines)
end

spawn(continuousTracerDrawing)

VisualSection:NewToggle("ESP Tracer", "ToggleInfo", function(state)
    tracerEnabled = state
    if not tracerEnabled then
        for _, tracer in pairs(tracerContainer) do
            tracer:Remove()
        end
        tracerContainer = {}
    end
end)

VisualSection:NewToggle("ESP Gun", "ToggleInfo", function(state)
        savedConfig.espgun12 = state
        saveConfig(savedConfig)

        _G.Gunesp = state

        local function createLabel(object)
            local player = game:GetService("Players").LocalPlayer
            local distance = (object.Position - player.Character.HumanoidRootPart.Position).Magnitude

            if not object:FindFirstChild("GunLabel") then
                local label = Instance.new("BillboardGui")
                label.Name = "GunLabel"
                label.Adornee = object
                label.Size = UDim2.new(0, 200, 0, 50)
                label.StudsOffset = Vector3.new(0, 3, 0)
                label.AlwaysOnTop = true
                label.Parent = object

                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.TextStrokeTransparency = 0.6
                textLabel.TextSize = 12
                textLabel.ZIndex = 5
                textLabel.Parent = label

                textLabel.Text = string.format("Gun Here! [%d studs]", math.floor(distance))
                textLabel.TextColor3 = Color3.fromRGB(255, 0, 255)
            else
                local textLabel = object.GunLabel:FindFirstChildOfClass("TextLabel")
                if textLabel then
                    textLabel.Text = string.format("Gun Here! [%d studs]", math.floor(distance))
                end
            end
        end

        local function removeHighlightsAndLabels()
            for _, v in pairs(workspace:GetChildren()) do
                local gunDrop = v:FindFirstChild("GunDrop")
                if gunDrop then
                    local highlight = gunDrop:FindFirstChild("Highlight")
                    if highlight then
                        highlight:Destroy()
                    end
                    local label = gunDrop:FindFirstChild("GunLabel")
                    if label then
                        label:Destroy()
                    end
                end
            end
        end

        local runConnection

        if state then
            runConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if _G.Gunesp then
                    for _, v in pairs(workspace:GetChildren()) do
                        local gunDrop = v:FindFirstChild("GunDrop")
                        if gunDrop then
                            if not gunDrop:FindFirstChild("Highlight") then
                                local highlight = Instance.new("Highlight")
                                highlight.Parent = gunDrop
                                highlight.FillTransparency = 0.7
                                highlight.FillColor = Color3.fromRGB(148, 0, 211)
                                highlight.OutlineColor = Color3.fromRGB(255, 0, 255)
                            end
                            createLabel(gunDrop)
                        end
                    end
                end
            end)
        else
            if runConnection then
                runConnection:Disconnect()
            end
            removeHighlightsAndLabels()
        end
    end)

local state = false
local player = game.Players.LocalPlayer
local coreGui = game:GetService("CoreGui")
local existingGui = coreGui:FindFirstChild("TimerGui")

local screenGui, timertext

local function createGui()
    if not coreGui:FindFirstChild("TimerGui") then
        screenGui = Instance.new("ScreenGui")
        screenGui.Name = "TimerGui"
        screenGui.Parent = coreGui

        timertext = Instance.new("TextLabel")
        timertext.Parent = screenGui
        timertext.BackgroundTransparency = 1
        timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
        timertext.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        timertext.TextStrokeTransparency = 0
        timertext.TextScaled = true
        timertext.AnchorPoint = Vector2.new(0.5, 0.5)
        timertext.Position = UDim2.new(0.5, 0, 0.1, 0)
        timertext.Size = UDim2.new(0, 200, 0, 50)
        timertext.Font = Enum.Font.Montserrat
        timertext.Text = "0:00"
    else
        screenGui = coreGui:FindFirstChild("TimerGui")
        timertext = screenGui:FindFirstChildOfClass("TextLabel")
    end
end

local function secondsToMinutes(seconds)
    local minutes = math.floor(seconds / 60)
    local remainingSeconds = seconds % 60
    return string.format("%d:%02d", minutes, remainingSeconds)
end

local function updateTextColor(timeLeft)
    if timeLeft <= 10 then
        timertext.TextColor3 = Color3.fromRGB(255, 0, 0)
    else
        timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
    end
end

local function flashText(repetitions)
    timertext.Text = "0:00"
    for i = 1, repetitions do
        if not state then break end
        timertext.TextColor3 = Color3.fromRGB(255, 0, 0)
        task.wait(0.5)
        timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
        task.wait(0.5)
    end
    timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
end

local function updateTimer()
    while state do
        local success, timeLeft = pcall(function()
            return game.ReplicatedStorage.Remotes.Extras.GetTimer:InvokeServer()
        end)

        if success then
            timertext.Text = secondsToMinutes(timeLeft)
            updateTextColor(timeLeft)

            if timeLeft <= 0 then
                flashText(3)
                timertext.Text = "0:00"

                repeat
                    task.wait(1)
                    success, timeLeft = pcall(function()
                        return game.ReplicatedStorage.Remotes.Extras.GetTimer:InvokeServer()
                    end)
                until timeLeft > 0

                timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
            end
        else
            warn("Error al obtener el tiempo restante: " .. tostring(timeLeft))
        end

        task.wait(1)
    end
end

VisualSection:NewToggle("Start Countdown", "ToggleInfo", function(toggleState)
    savedConfig.Countdown1 = toggleState
    saveConfig(savedConfig)

    state = toggleState

    if state then
        if not coreGui:FindFirstChild("TimerGui") then
            createGui()
            updateTimer()
        else
            warn("El temporizador ya está en ejecución.")
        end
    else
        if coreGui:FindFirstChild("TimerGui") then
            coreGui:FindFirstChild("TimerGui"):Destroy()
        end
    end
end)

VisualSection:NewButton("Inquire chat who is the sheriff or murderer", "ButtonInfo", function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local textChatService = game:GetService('TextChatService')
        
        local function sendMessage(message)
            if message and message ~= "" then
                pcall(function()
                    textChatService.TextChannels.RBXGeneral:SendAsync(message)
                end)
            end
        end

        local function checkRoles()
            local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
            if roles then
                local Sheriff, Murderer = nil, nil

                for playerName, roleData in pairs(roles) do
                    if roleData.Role == "Murderer" then
                        Murderer = playerName
                    elseif roleData.Role == "Sheriff" then
                        Sheriff = playerName
                    end
                end
                
                if Sheriff and Murderer then
                    sendMessage(Sheriff .. " is the Sheriff and " .. Murderer .. " is the Murderer.")
                elseif Sheriff then
                    sendMessage(Sheriff .. " is the Sheriff, but there is no Murderer.")
                elseif Murderer then
                    sendMessage(Murderer .. " is the Murderer.")
                end
            end
        end

        checkRoles()
end)

CombateSection:NewButton("Throw Knife", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("Throw")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "Throw"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Throw"
button.Size = UDim2.new(0, 60, 0, 60)
button.Position = UDim2.new(1, -70, 0, 50)
button.Text = "OFF"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Rojo cuando está "OFF"
button.BackgroundTransparency = 0.6
button.BorderSizePixel = 2
button.BorderColor3 = Color3.fromRGB(0, 0, 0)
button.Draggable = true
button.TextScaled = true
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local player = game.Players.LocalPlayer
local camera = game.Workspace.CurrentCamera
local flingActive = false
local VirtualInputManager = game:GetService("VirtualInputManager")

local function isPlayerVisible(target)
    local targetPosition = target.Character.HumanoidRootPart.Position
    local screenPoint = camera:WorldToScreenPoint(targetPosition)
    return screenPoint.Z > 0 and screenPoint.Y > 0 and screenPoint.Y < camera.ViewportSize.Y and screenPoint.X > 0 and screenPoint.X < camera.ViewportSize.X
end

local function getClosestVisibleEnemy()
    local closestEnemy = nil
    local closestDistance = math.huge

    for _, enemy in ipairs(game.Players:GetPlayers()) do
        if enemy ~= player and enemy.Character and enemy.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - enemy.Character.HumanoidRootPart.Position).Magnitude
            if distance < closestDistance and isPlayerVisible(enemy) then
                closestDistance = distance
                closestEnemy = enemy
            end
        end
    end

    return closestEnemy
end

local function flingKnifeAt(target)
    if not target or not player.Character or not player.Character:FindFirstChild("Knife") then return end

    -- Simular la tecla "E"
    VirtualInputManager:SendKeyEvent(true, "E", false, game) -- Presionar "E"
    wait(0.1) -- Pequeña espera para simular el tiempo de presionar
    VirtualInputManager:SendKeyEvent(false, "E", false, game) -- Soltar "E"
    
    wait(0.5) -- Esperar 0.5 segundos antes de lanzar el cuchillo

    local playerPosition = player.Character.HumanoidRootPart.Position
    local targetPosition = target.Character.HumanoidRootPart.Position

    -- Dirección desde el jugador local hacia el enemigo
    local direction = (targetPosition - playerPosition).Unit

    -- Argumentos para el lanzamiento del cuchillo
    local knifeArgs = {
        [1] = CFrame.new(playerPosition, playerPosition + direction),  -- CFrame desde la posición del jugador local hacia la dirección del enemigo
        [2] = playerPosition + direction * 50  -- Ajuste de la dirección del cuchillo, alejado del jugador local y sin colisionar con el objetivo
    }

    local throw = player.Character.Knife:FindFirstChild("Throw")
    if throw then
        throw:FireServer(unpack(knifeArgs))
    end
end

local function toggleFling()
    flingActive = not flingActive
    if flingActive then
        button.Text = "ON"
        button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        while flingActive do
            local target = getClosestVisibleEnemy()
            if target then
                flingKnifeAt(target)
            end
            wait(1.5)
        end
    else
        button.Text = "OFF"
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    end
end

button.MouseButton1Click:Connect(toggleFling)

player.CharacterAdded:Connect(function()
    if flingActive then
        toggleFling()
    end
end)
end)

LocalPlayerSection:NewButton("second life", "ButtonInfo", function()
local accessories = {}

function GodMode()
    local player = game.Players.LocalPlayer
    local char = player.Character or player.CharacterAdded:Wait()

    if char and char:FindFirstChild("Humanoid") then
        for _, accessory in pairs(char.Humanoid:GetAccessories()) do
            table.insert(accessories, accessory:Clone())
        end

        local humanoid = char:FindFirstChild("Humanoid")
        humanoid.Name = "TempHumanoid"

        local newHumanoid = humanoid:Clone()
        newHumanoid.Parent = char
        newHumanoid.Name = "Humanoid"

        newHumanoid.WalkSpeed = 18.5
        newHumanoid.JumpPower = 53
        newHumanoid.Health = math.huge
        newHumanoid.MaxHealth = math.huge

        wait(0.1)
        humanoid:Destroy()

        workspace.CurrentCamera.CameraSubject = newHumanoid

        for _, accessory in pairs(char:GetChildren()) do
            if accessory:IsA("Accessory") then
                accessory:Destroy()
            end
        end

        for _, accessory in pairs(accessories) do
            newHumanoid:AddAccessory(accessory)
        end

        accessories = {}

        local animateScript = char:FindFirstChild("Animate")
        if animateScript then
            animateScript.Disabled = true
            wait(0.1)
            animateScript.Disabled = false
        end

        newHumanoid.Died:Connect(function()
            wait(0.1)
            newHumanoid.Health = 100
        end)
    end
end

GodMode()
    end)

LocalPlayerSection:NewToggle("auto second life v1", "ToggleInfo", function(state)
        savedConfig.Se = toggleState
        saveConfig(savedConfig)

        local player = game.Players.LocalPlayer
        local StarterGui = game:GetService("StarterGui")
        local secondLifeActivated, notificationShown = false, false
        local mapConnection, characterConnection

        local function activateSecondLife()
            if not toggleState or secondLifeActivated then return end
            secondLifeActivated = true
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.Name = "1"
                local clonedHumanoid = humanoid:Clone()
                clonedHumanoid.Parent = player.Character
                clonedHumanoid.Name = "Humanoid"
                wait(0.1)
                humanoid:Destroy()
                workspace.CurrentCamera.CameraSubject = clonedHumanoid
                player.Character.Animate.Disabled = true
                wait(0.1)
                player.Character.Animate.Disabled = false
            end
        end

        local function checkNewMap()
            if toggleState and not notificationShown then
                StarterGui:SetCore("SendNotification", {
                    Title = "Second Life",
                    Text = "New map detected. Second Life will be activated soon.",
                    Duration = 3
                })
                notificationShown = true
                wait(15)
                if toggleState and not secondLifeActivated then
                    activateSecondLife()
                end
            end
        end

        local function resetSecondLife()
            secondLifeActivated, notificationShown = false, false
        end

        local function disconnectConnections()
            if mapConnection then 
                mapConnection:Disconnect() 
                mapConnection = nil 
            end
            if characterConnection then 
                characterConnection:Disconnect() 
                characterConnection = nil 
            end
        end

        if toggleState then
            resetSecondLife()
            disconnectConnections()

            mapConnection = workspace.DescendantAdded:Connect(function(descendant)
                if toggleState and (descendant.Name == "Spawn" or descendant.Name == "PlayerSpawn") then
                    checkNewMap()
                end
            end)

            characterConnection = player.CharacterAdded:Connect(function()
                if toggleState then
                    resetSecondLife()
                end
            end)
        else
            disconnectConnections()
            resetSecondLife()
        end
    end)

VisualSection:NewButton("Fps Booster", "ButtonInfo", function()
loadstring(game:HttpGet(("https://raw.githubusercontent.com/Jorgelinea/Fps/refs/heads/main/Protected_3128182632327016.txt"),true))()
    end)

VisualSection:NewButton("fake death", "ButtonInfo", function()
local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local humanoid = character:FindFirstChildOfClass("Humanoid")
if humanoid then
    humanoid.Sit = true
end

humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position) * CFrame.Angles(math.rad(-90), 0, 0)
    end)

local lp = game.Players.LocalPlayer
local knifeanim
local fakeGunActive = false

VisualSection:NewToggle("Fake Knife", "ToggleInfo", function(state)
        savedConfig.Fake = state 
        saveConfig(savedConfig)
        if state then
            if lp.Backpack:FindFirstChild("Knife") then return end
            
            local tool = Instance.new("Tool")
            tool.Name = "Knife"
            tool.Grip = CFrame.new(0, -1.17, 0.07, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            tool.GripForward = Vector3.new(0, 0, -1)
            tool.GripPos = Vector3.new(0, -1.17, 0.07)
            tool.GripRight = Vector3.new(1, 0, 0)
            tool.GripUp = Vector3.new(0, 1, 0)

            local handle = Instance.new("Part")
            handle.Size = Vector3.new(1, 3.42, 1.09)
            handle.Name = "Handle"
            handle.Transparency = 1
            handle.Parent = tool

            tool.Parent = lp.Backpack

            local animation1 = Instance.new("Animation")
            animation1.AnimationId = "rbxassetid://2467567750"
            local animation2 = Instance.new("Animation")
            animation2.AnimationId = "rbxassetid://1957890538"
            local anims = {animation1, animation2}

            lp:GetMouse().Button1Down:Connect(function()
                if tool.Parent == lp.Character then
                    local anim = lp.Character.Humanoid:LoadAnimation(anims[math.random(1, 2)])
                    anim:Play()
                end
            end)

            local knife = lp.Character:WaitForChild("KnifeDisplay")
            knife.Massless = true
            local aa = Instance.new("Attachment", handle)
            local ba = Instance.new("Attachment", knife)
            local hinge = Instance.new("HingeConstraint", knife)
            hinge.Attachment0 = aa
            hinge.Attachment1 = ba
            hinge.LimitsEnabled = true
            hinge.LowerAngle = 0
            hinge.Restitution = 0
            hinge.UpperAngle = 0

            for _, v in pairs(lp.Character:WaitForChild("UpperTorso"):GetChildren()) do
                if v:IsA("Weld") and v.Part1 == knife then
                    v:Destroy()
                    break
                end
            end

            knifeanim = game:GetService("RunService").Heartbeat:Connect(function()
                if tool.Parent == lp.Character then
                    knife.CFrame = handle.CFrame
                elseif lp.Character and knife then
                    knife.CFrame = lp.Character:WaitForChild("UpperTorso").CFrame * CFrame.new(-0.2, -0.4, 0.5)
                end
            end)

            local function animateAndWait()
                while tool.Parent == lp.Character do
                    local anim = lp.Character.Humanoid:LoadAnimation(anims[math.random(1, 2)])
                    anim:Play()
                    wait(1)
                end
            end

            spawn(animateAndWait)
        else
            if knifeanim then
                knifeanim:Disconnect()
            end
            if lp.Character:FindFirstChild("Knife") then
                lp.Character.Knife:Destroy()
            end
            if lp.Backpack:FindFirstChild("Knife") then
                lp.Backpack.Knife:Destroy()
            end
        end
    end)

TeleportSection:NewButton("Go to the Lobby", "ButtonInfo", function()
local player = game.Players.LocalPlayer
local spawns = workspace:WaitForChild("Lobby"):WaitForChild("Spawns"):GetChildren()

if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and #spawns > 0 then
    local randomSpawn = spawns[math.random(1, #spawns)]
    
    player.Character.HumanoidRootPart.CFrame = randomSpawn.CFrame + Vector3.new(0, 3, 0)
end
end)

TeleportSection:NewButton("Vote Map", "ButtonInfo", function()
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-104, 154, -18)
end)

TeleportSection:NewButton("Go to Map", "ButtonInfo", function()
for i,v in pairs (workspace:GetDescendants()) do
        if v.Name == "Spawn" then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(v.Position) * CFrame.new(0,2.5,0)
        elseif v.Name == "PlayerSpawn" then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(v.Position) * CFrame.new(0,2.5,0)
        end
    end
end)

TeleportSection:NewButton("void (Safe)", "ButtonInfo", function()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local teleportPosition = CFrame.new(-74, 6, 693)


local function blockExists(position, size)
    for _, obj in ipairs(workspace:GetChildren()) do
        if obj:IsA("Part") and obj.Position == position and obj.Size == size then
            return true
        end
    end
    return false
end

local blockSize = Vector3.new(60, 2, 60)

if not blockExists(teleportPosition.Position, blockSize) then
    local wideBlock = Instance.new("Part")
    wideBlock.Size = blockSize
    wideBlock.Position = teleportPosition.Position
    wideBlock.Anchored = true
    wideBlock.CanCollide = true
    wideBlock.Transparency = 0.5
    wideBlock.Parent = workspace
end

hrp.CFrame = teleportPosition * CFrame.new(0, 3, 0)
    end)
 
EmoteSection:NewButton("Get all the emotes", "ButtonInfo", function()
        local PlayerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
        local Emotes = PlayerGui:WaitForChild("MainGUI"):WaitForChild("Game"):FindFirstChild("Emotes")

        if Emotes then
            local success = pcall(function()
                require(game:GetService("ReplicatedStorage").Modules.EmoteModule).GeneratePage(
                    {"headless", "zombie", "zen", "ninja", "floss", "dab", "sit"},
                    Emotes,
                    "Free Emotes"
                )
            end)

            if success then
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Success",
                    Text = "Emotes obtained",
                    Duration = 3
                })
            end
        end
    end)
    
local anim = Instance.new('Animation')

EmoteSection:NewButton("Ninja", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2431864798"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)

EmoteSection:NewButton("Dab", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2445521505"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)

EmoteSection:NewButton("Floss", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2452938820"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)

EmoteSection:NewButton("Headless", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2513694073"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)

EmoteSection:NewButton("Zen", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2431812646"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)

EmoteSection:NewButton("Zombie", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2513692312"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)

EmoteSection:NewButton("Sit", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2431845940"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)
    
    SettingsAutofarm = {}
if _G.AutofarmSettings then
    SettingsAutofarm = _G.AutofarmSettings
else
    _G.AutofarmSettings = {}
    SettingsAutofarm = {AntiAfk = true, DelayFarm = 3}
end

if _G.AutoFarmMM2IsLoaded then return end
_G.AutoFarmMM2IsLoaded = true

Player = game.Players.LocalPlayer
Players = game.Players
RunService = game:GetService("RunService")
CoinCollectedEvent = game.ReplicatedStorage.Remotes.Gameplay.CoinCollected
RoundStartEvent = game.ReplicatedStorage.Remotes.Gameplay.RoundStart
RoundEndEvent = game.ReplicatedStorage.Remotes.Gameplay.RoundEndFade

AutofarmStarted = false
CurrentCoinType = "Candy"
AutofarmDelay = 3
ResetWhenFullBag = false 
AutofarmIN = false

bringpose = CFrame.new(math.random(-5, 5), -100, math.random(-5, 5))
safepart = Instance.new("Part")
safepart.Anchored = true
safepart.Massless = true
safepart.Transparency = 1
safepart.Size = Vector3.new(2048, 0.5, 2048)
safepart.CFrame = bringpose * CFrame.new(0, -0.9, 0)
safepart.Parent = workspace

function returncoincontaier()
    for _, v in workspace:GetChildren() do
        if v:FindFirstChild("CoinContainer") and v:IsA("Model") then
            return v:FindFirstChild("CoinContainer")
        end
    end
    return false
end

CoinCollectedEvent.OnClientEvent:Connect(function(cointype, current, max)
    AutofarmIN = true
    if cointype == CurrentCoinType and tonumber(current) == tonumber(max) then
        AutofarmIN = false
        if ResetWhenFullBag then
            if Player.Character and Player.Character:FindFirstChild("Humanoid") then
                Player.Character.Humanoid.Health = 0
            else
                Player:LoadCharacter()
            end
        end
    end
end)

function PcallTP(Position)
    if Player.Character then
        if Player.Character:FindFirstChild("HumanoidRootPart") then
            Player.Character.HumanoidRootPart.CFrame = Position
        end
    end
end

spawn(function()
    while true do
        if AutofarmStarted and AutofarmIN and Player.Character and returncoincontaier() then
            PcallTP(bringpose)
            for _, v in pairs(returncoincontaier():GetChildren()) do
                if v:GetAttribute("CoinID") == CurrentCoinType and v:FindFirstChild("TouchInterest") then
                    for i = 1, 7 do
                        PcallTP(v.CFrame)
                        task.wait(0.03)
                    end
                    break
                end
            end
            PcallTP(bringpose)
        end
        task.wait(AutofarmDelay)
    end
end)

RoundStartEvent.OnClientEvent:Connect(function()
    if AutofarmStarted then Player.Character.HumanoidRootPart.CFrame = bringpose end
    AutofarmIN = true
end)

RoundEndEvent.OnClientEvent:Connect(function()
    AutofarmIN = false
end)

for Configname, Configvalue in pairs(SettingsAutofarm) do
    if Configname == "DelayFarm" and tonumber(Configvalue) and tonumber(Configvalue) < 8 then
        AutofarmDelay = tonumber(Configvalue)
    elseif Configname == "StartAutofarm" and Configvalue == true then
        AutofarmStarted = true
    end
end

AutoFarmSection:NewToggle("Autofarm tp", "ToggleInfo", function(state)
        savedConfig.Autofarmn = state
        saveConfig(savedConfig)
        AutofarmStarted = state
    end)

AutoFarmSection:NewToggle("Reset when bag is full", "ToggleInfo", function(state)
        savedConfig.ResetWhenFullBag = state
        saveConfig(savedConfig)
        ResetWhenFullBag = state
    end)

local old
local isAntiKickEnabled = false

old = hookmetamethod(game, "__namecall", function(self, ...)
    local method = tostring(getnamecallmethod())
    
    if string.lower(method) == "kick" and isAntiKickEnabled then
        return wait(9e9)
    end
    
    return old(self, ...)
end)

local old
local isAntiKickEnabled = false

old = hookmetamethod(game, "__namecall", function(self, ...)
    local method = tostring(getnamecallmethod())
    
    if string.lower(method) == "kick" and isAntiKickEnabled then
        return wait(9e9)
    end
    
    return old(self, ...)
end)

AutoFarmSection:NewToggle("Anti Kick", "ToggleInfo", function(state)
        savedConfig.antikick = state
        saveConfig(savedConfig)

        isAntiKickEnabled = state
        if isAntiKickEnabled then
            print("Anti Kick Activado")
        else
            print("Anti Kick Desactivado")
        end
    end)

local D3RenderingDisabled = false

AutoFarmSection:NewToggle("Disable 3D rendering", "ToggleInfo", function(state)
        savedConfig.renderizado = state
        saveConfig(savedConfig)

        if not D3RenderingDisabled and state then
            D3RenderingDisabled = true
            RunService:Set3dRenderingEnabled(false)
        elseif D3RenderingDisabled and not state then
            D3RenderingDisabled = false
            RunService:Set3dRenderingEnabled(true)
        end
    end)

AutoFarmSection:NewToggle("Coin Optimization (is ass)", "ToggleInfo", function(state)
        savedConfig.Optimization = state
        saveConfig(savedConfig)
        local connections = {}
        
        local function onTouch(coin, hit)
            local player = game.Players:GetPlayerFromCharacter(hit.Parent)
            if player then
                coin.Transparency = 1
                coin.CanCollide = false
                wait(2)
                coin:Destroy()
            end
        end

        local function setupCoin(coin)
            if coin:IsA("Part") then
                local connection = coin.Touched:Connect(function(hit)
                    onTouch(coin, hit)
                end)
                table.insert(connections, connection)
            end
        end

        local function updateCoinContainer()
            local coinContainer = workspace:FindFirstChild("Normal") and workspace.Normal:FindFirstChild("CoinContainer")
            if coinContainer then
                for _, coin in ipairs(coinContainer:GetChildren()) do
                    if coin.Name == "CoinVisual" or coin.Name == "Coin_Server" then
                        setupCoin(coin)
                    end
                end
            end
        end

        while state do
            updateCoinContainer()
            
            local coinContainer = workspace:FindFirstChild("Normal") and workspace.Normal:FindFirstChild("CoinContainer")
            if coinContainer then
                local connection = coinContainer.ChildAdded:Connect(function(newCoin)
                    if newCoin.Name == "CoinVisual" or newCoin.Name == "Coin_Server" then
                        setupCoin(newCoin)
                    end
                end)
                table.insert(connections, connection)
            end
            
            wait(1)
        end

        if not state then
            for _, connection in ipairs(connections) do
                connection:Disconnect()
            end
            connections = {}
        end
    end)
    
local autoXPEnabled = false
local teletransportLoop
local player = game.Players.LocalPlayer

AutoFarmSection:NewToggle("Auto XP", "ToggleInfo", function(state)
        savedConfig.Autoxp = state 
        saveConfig(savedConfig)
        autoXPEnabled = state

        local function startTeletransportLoop()
            teletransportLoop = coroutine.create(function()
                while autoXPEnabled do
                    local character = player.Character
                    if character and character:FindFirstChild("HumanoidRootPart") then
                        for _, v in pairs(workspace:GetDescendants()) do
                            if v.Name == "Spawn" or v.Name == "PlayerSpawn" then
                                print("Mapa detectado: " .. v.Name .. " encontrado")
                                character.HumanoidRootPart.CFrame = CFrame.new(-104, 154, -18)
                                break
                            end
                        end
                    end
                    wait(0.5)
                end
            end)
            coroutine.resume(teletransportLoop)
        end

        player.CharacterAdded:Connect(function(character)
            if autoXPEnabled then
                wait()
                startTeletransportLoop()
            end
        end)

        if autoXPEnabled then
            startTeletransportLoop()
        else
            autoXPEnabled = false
        end
    end)

CombateSection:NewButton("Tp And Shoot {Beta}", "ButtonInfo", function()
local screenGui = Instance.new("ScreenGui")
local shootButton = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

screenGui.Name = "ShootMurdererGui"
screenGui.Parent = game:GetService("CoreGui")

shootButton.Name = "tpDispararButton"
shootButton.Size = UDim2.new(0, 100, 0, 100)
shootButton.Position = UDim2.new(0, 10, 0, 50)
shootButton.Text = "TP Shoot"
shootButton.Font = Enum.Font.Gotham
shootButton.TextSize = 14
shootButton.TextColor3 = Color3.fromRGB(255, 255, 255)
shootButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
shootButton.BackgroundTransparency = 0.6
shootButton.Draggable = true
shootButton.BorderSizePixel = 0
shootButton.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = shootButton

local localplayer = game.Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local function getTorsoPosition(character)
    local torso = character:FindFirstChild("HumanoidRootPart")
    return torso and torso.Position or nil
end

local function predictPosition(murderer)
    local humanoidRootPart = murderer:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        local murdererPosition = humanoidRootPart.Position
        local murdererVelocity = humanoidRootPart.Velocity
        local distanceToPlayer = (murdererPosition - localplayer.Character.HumanoidRootPart.Position).Magnitude

        local predictionTime = math.clamp(distanceToPlayer / 50, 0, 0.1)
        local predictedPosition = murdererPosition + murdererVelocity * predictionTime

        return Vector3.new(predictedPosition.X, murdererPosition.Y, predictedPosition.Z)
    end
    return nil
end

local function shootAtMurderer(predictedPosition)
    local gun = localplayer.Character:FindFirstChild("Gun")
    if gun then
        local args = {
            [1] = 1,
            [2] = predictedPosition,
            [3] = "AH2"
        }
        gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
    end
end

local function getMurderer()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    if roles then
        for playerName, roleInfo in pairs(roles) do
            if roleInfo.Role == "Murderer" then
                local murdererPlayer = game.Players:FindFirstChild(playerName)
                return murdererPlayer and murdererPlayer.Character
            end
        end
    end
    return nil
end

shootButton.MouseButton1Click:Connect(function()
    local gun = localplayer.Character:FindFirstChild("Gun")
    if not gun then return end

    local originalPosition = localplayer.Character.HumanoidRootPart.Position
    local murderer = getMurderer()

    if murderer then
        local predictedPosition = predictPosition(murderer)
        
        if predictedPosition then
            local function updatePositionBehindMurderer()
                if murderer and murderer:FindFirstChild("HumanoidRootPart") then
                    local murdererPosition = murderer.HumanoidRootPart.Position
                    local behindPosition = murdererPosition - murderer.HumanoidRootPart.CFrame.LookVector * 4
                    localplayer.Character.HumanoidRootPart.CFrame = CFrame.new(behindPosition)
                end
            end

            local followConnection
            followConnection = RunService.RenderStepped:Connect(function()
                updatePositionBehindMurderer()
            end)

            wait(0.1)
            shootAtMurderer(predictedPosition)

            followConnection:Disconnect()
            localplayer.Character.HumanoidRootPart.CFrame = CFrame.new(originalPosition)
        end
    end
end)
    end)

TeleportSection:NewButton("tp Sheriff", "Teletransportarse al Sheriff", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local LP = Players.LocalPlayer
    local Character = LP.Character
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")

    local function GetSheriff()
        local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
        for i, v in pairs(roles) do
            if v.Role == "Sheriff" then
                return Players:FindFirstChild(i)
            end
        end
        return nil
    end

    local function TeleportToSheriff()
        local sheriffPlayer = GetSheriff()
        if sheriffPlayer and sheriffPlayer.Character and sheriffPlayer.Character:FindFirstChild("HumanoidRootPart") then
            Character:SetPrimaryPartCFrame(sheriffPlayer.Character.HumanoidRootPart.CFrame)
        end
    end

    TeleportToSheriff()
end)

TeleportSection:NewButton("tp Murderer", "Teletransportarse al Murderer", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local LP = Players.LocalPlayer
    local Character = LP.Character
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")

    local function GetMurderer()
        local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
        for i, v in pairs(roles) do
            if v.Role == "Murderer" then
                return Players:FindFirstChild(i)
            end
        end
        return nil
    end

    local function TeleportToMurderer()
        local murdererPlayer = GetMurderer()
        if murdererPlayer and murdererPlayer.Character and murdererPlayer.Character:FindFirstChild("HumanoidRootPart") then
            Character:SetPrimaryPartCFrame(murdererPlayer.Character.HumanoidRootPart.CFrame)
        end
    end

    TeleportToMurderer()
end)

TeleportSection:NewButton("tp Hero", "Teletransportarse al Hero", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local LP = Players.LocalPlayer
    local Character = LP.Character
    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")

    local function GetHero()
        local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
        for i, v in pairs(roles) do
            if v.Role == "Hero" then
                return Players:FindFirstChild(i)
            end
        end
        return nil
    end

    local function TeleportToHero()
        local heroPlayer = GetHero()
        if heroPlayer and heroPlayer.Character and heroPlayer.Character:FindFirstChild("HumanoidRootPart") then
            Character:SetPrimaryPartCFrame(heroPlayer.Character.HumanoidRootPart.CFrame)
        end
    end

    TeleportToHero()
end)

VisualSection:NewButton("View Murderer", "Switch camera to the murderer", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Camera = workspace.CurrentCamera

    local function GetMurderer()
        local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
        for i, v in pairs(roles) do
            if v.Role == "Murderer" then
                return i
            end
        end
        return nil
    end

    local rolePlayer = Players:FindFirstChild(GetMurderer())
    if rolePlayer and rolePlayer.Character and rolePlayer.Character:FindFirstChild("HumanoidRootPart") then
        Camera.CameraSubject = rolePlayer.Character.Humanoid
        Camera.CFrame = rolePlayer.Character.HumanoidRootPart.CFrame
    end
end)

VisualSection:NewButton("View Sheriff", "Switch camera to the sheriff", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Camera = workspace.CurrentCamera

    local function GetSheriff()
        local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
        for i, v in pairs(roles) do
            if v.Role == "Sheriff" then
                return i
            end
        end
        return nil
    end

    local rolePlayer = Players:FindFirstChild(GetSheriff())
    if rolePlayer and rolePlayer.Character and rolePlayer.Character:FindFirstChild("HumanoidRootPart") then
        Camera.CameraSubject = rolePlayer.Character.Humanoid
        Camera.CFrame = rolePlayer.Character.HumanoidRootPart.CFrame
    end
end)

VisualSection:NewButton("View Hero", "Switch camera to the hero", function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Camera = workspace.CurrentCamera

    local function GetHero()
        local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
        for i, v in pairs(roles) do
            if v.Role == "Hero" then
                return i
            end
        end
        return nil
    end

    local rolePlayer = Players:FindFirstChild(GetHero())
    if rolePlayer and rolePlayer.Character and rolePlayer.Character:FindFirstChild("HumanoidRootPart") then
        Camera.CameraSubject = rolePlayer.Character.Humanoid
        Camera.CFrame = rolePlayer.Character.HumanoidRootPart.CFrame
    end
end)

VisualSection:NewButton("Return to my camera", "Reset camera to the local player", function()
    local Players = game:GetService("Players")
    local Camera = workspace.CurrentCamera
    local LP = Players.LocalPlayer

    if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
        Camera.CameraSubject = LP.Character.Humanoid
        Camera.CFrame = LP.Character.HumanoidRootPart.CFrame
    end
end)
    
VisualSection:NewButton("Fe emote", "ButtonInfo", function()
loadstring(game:HttpGet("https://pastebin.com/raw/eCpipCTH"))()
end)

MICSection:NewButton("ReJoin", "ButtonInfo", function()
        local TeleportService = game:GetService("TeleportService")
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer

        local Rejoin = coroutine.create(function()
            local Success, ErrorMessage = pcall(function()
                TeleportService:Teleport(game.PlaceId, LocalPlayer)
            end)

            if not Success then
                warn(ErrorMessage)
            end
        end)
        coroutine.resume(Rejoin)
    end)
 
local defaultGravity, increasedGravity = 190, 400
local connections = {}
local settings = {
    Walkspeed = 16,
    Jumppower = 50,
    loopW = false,
    loopJ = false,
    InfJ = false
}

game.Workspace.Gravity = defaultGravity

local function updateHumanoid(property, value)
    local player = game:GetService("Players").LocalPlayer
    local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid[property] = value
    end
end

LocalPlayerSection:NewTextBox("Gravity", "Enter a value", function(value)
    local numericValue = tonumber(value)
    game.Workspace.Gravity = numericValue or defaultGravity
end)

LocalPlayerSection:NewToggle("Gravity loop", "ToggleInfo", function(state)
    game.Workspace.Gravity = state and increasedGravity or defaultGravity
end)

LocalPlayerSection:NewTextBox("Speed", "Enter a value", function(value)
    settings.Walkspeed = tonumber(value) or 16
    updateHumanoid("WalkSpeed", settings.Walkspeed)
end)

LocalPlayerSection:NewToggle("Loop speed", "ToggleInfo", function(state)
    settings.loopW = state
    if state and not connections.speed then
        connections.speed = game:GetService("RunService").Heartbeat:Connect(function()
            if settings.loopW then
                updateHumanoid("WalkSpeed", settings.Walkspeed)
            end
        end)
    elseif connections.speed then
        connections.speed:Disconnect()
        connections.speed = nil
    end
end)

LocalPlayerSection:NewTextBox("Power Jump", "Enter a value", function(value)
    settings.Jumppower = tonumber(value) or 50
    updateHumanoid("JumpPower", settings.Jumppower)
end)

LocalPlayerSection:NewToggle("Power Jump/Loop", "ToggleInfo", function(state)
    settings.loopJ = state
    if state and not connections.jump then
        connections.jump = game:GetService("RunService").Heartbeat:Connect(function()
            if settings.loopJ then
                updateHumanoid("JumpPower", settings.Jumppower)
            end
        end)
    elseif connections.jump then
        connections.jump:Disconnect()
        connections.jump = nil
    end
end)

LocalPlayerSection:NewToggle("Infinite Jump", "ToggleInfo", function(state)
    settings.InfJ = state
    if connections.jumpRequest then
        connections.jumpRequest:Disconnect()
        connections.jumpRequest = nil
    end
    if state then
        connections.jumpRequest = game:GetService("UserInputService").JumpRequest:Connect(function()
            if settings.InfJ then
                local humanoid = game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:ChangeState("Jumping")
                end
            end
        end)
    end
end)
