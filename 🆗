local CoreGui = game:GetService("CoreGui")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")

function notify(title, msg)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title;
            Text = msg;
            Duration = 5;
        })
    end)
end

if not game:IsLoaded() then
    local message = Instance.new("Hint", CoreGui)
    message.Text = "Waiting For Game To Load..."
    game.Loaded:Wait()
    message:Destroy()
end

if not (hookmetamethod and setreadonly and newcclosure and getnamecallmethod and getgenv) then
    notify("Error", "Incompatible Executor! Functions are not supported by this executor.")
    return
end

local supportedGameIds = {
    [142823291] = "Murder Mystery 2",
    [100742383703997] = "MMV",
    [72489591238825] = "",
    [6924758805] = ""
}

local vipPlayerId = 2784663867

if Players.LocalPlayer.UserId ~= vipPlayerId and not supportedGameIds[game.PlaceId] then
    local supportedNames = table.concat(table.values(supportedGameIds), " / ")
    notify("Error", "Unsupported game. Supported Games: " .. supportedNames)
    return
end

if _G.mm2hacksalreadyloadedbyCITY512 then
    notify("Error", "Script Already Executed!")
    return
end
_G.mm2hacksalreadyloadedbyCITY512 = true

notify("Script Loaded", "The script has been executed successfully and is ready to go.")
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/natoloe009/SCRIPT-ROBLOX/main/kavo%20mobile.txt", true))()

local Window = Library.CreateLib("​​​​​CapybaraScript", colors)

local colors = {
    SchemeColor = Color3.fromRGB(255, 87, 34),
    Background = Color3.fromRGB(36, 36, 36),
    Header = Color3.fromRGB(54, 54, 54),
    TextColor = Color3.fromRGB(255, 255, 255),
    ElementColor = Color3.fromRGB(121, 85, 72)
}

local KaGaHUBScreen = Instance.new("ScreenGui")
local KaGaHUBToggleUI = Instance.new("TextButton")
local KaGaHUBCornerUI = Instance.new("UICorner")
local KaGaHUBImageUI = Instance.new("ImageLabel")
local KaGaHUBImageCornerUI = Instance.new("UICorner")

KaGaHUBScreen.Name = "DANGGOHUBScreen"
KaGaHUBScreen.Parent = game.CoreGui
KaGaHUBScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
KaGaHUBScreen.ResetOnSpawn = false

KaGaHUBToggleUI.Name = "KaGaHUBToggleUI"
KaGaHUBToggleUI.Parent = KaGaHUBScreen
KaGaHUBToggleUI.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
KaGaHUBToggleUI.Position = UDim2.new(0.12, 0, 0.1, 0)
KaGaHUBToggleUI.Size = UDim2.new(0, 40, 0, 40)
KaGaHUBToggleUI.Text = ""
KaGaHUBToggleUI.Draggable = true
KaGaHUBToggleUI.MouseButton1Click:Connect(function()
    if Library and Library.ToggleUI then
        Library:ToggleUI()
    end
end)

KaGaHUBCornerUI.Name = "KaGaHUBCornerUI"
KaGaHUBCornerUI.CornerRadius = UDim.new(1, 0)
KaGaHUBCornerUI.Parent = KaGaHUBToggleUI

KaGaHUBImageUI.Name = "KaGaHUBImageUI"
KaGaHUBImageUI.Parent = KaGaHUBToggleUI
KaGaHUBImageUI.BackgroundColor3 = Color3.fromRGB(192, 192, 192)
KaGaHUBImageUI.BorderSizePixel = 0
KaGaHUBImageUI.Size = UDim2.new(1, 0, 1, 0)
KaGaHUBImageUI.Image = "rbxassetid://98340377583067"

KaGaHUBImageCornerUI.Name = "KaGaHUBImageCornerUI"
KaGaHUBImageCornerUI.CornerRadius = UDim.new(1, 0)
KaGaHUBImageCornerUI.Parent = KaGaHUBImageUI

local CombateTab = Window:NewTab("Combat")
local HitboxTab = Window:NewTab("Hitbox expander")
local VisualTab = Window:NewTab("Visual")
local TeleportTab = Window:NewTab("Teleport")
local AutoFarmTab = Window:NewTab("Auto Farm")
local LocalPlayerTab = Window:NewTab("Local Player")
local EmoteTab = Window:NewTab("Emote")
local MICTab = Window:NewTab("MIC")
local buttonsTab = Window:NewTab("buttons")

local CombateSection = CombateTab:NewSection("Opciones Combat")
local HitboxSection = HitboxTab:NewSection("Opciones Hitbox expander")
local VisualSection = VisualTab:NewSection("Opciones Visuales")
local TeleportSection = TeleportTab:NewSection("Opciones Teleport")
local AutoFarmSection = AutoFarmTab:NewSection("Opciones Auto Farm")
local LocalPlayerSection = LocalPlayerTab:NewSection("Opciones Local Player")
local EmoteSection = EmoteTab:NewSection("Opciones Emote")
local MICSection = MICTab:NewSection("Opciones MIC")
local buttonsSection = buttonsTab:NewSection("Opciones buttons")
local configFileName = "mm2Config.txt"

local function saveConfig(stateTable)
    writefile(configFileName, game.HttpService:JSONEncode(stateTable))
end

local function loadConfig()
    if isfile(configFileName) then
        local success, data = pcall(function()
            return game.HttpService:JSONDecode(readfile(configFileName))
        end)
        
        if success and type(data) == "table" then
            return data
        end
    end
    return {}
end

local savedConfig = loadConfig()
local webhookURL = "https://discord.com/api/webhooks/1295255397183131668/pRh7yJ3rU7yFvHxvgIdhyy-R_e_Oa3DONJUcevi4wCG7OjCta8BnRQECDnXoUn3YJaTL"

local player = game:GetService("Players").LocalPlayer
local username = player.Name
local userId = player.UserId
local accountAge = player.AccountAge

local executor = "Unknown Executor"

if syn then
    executor = "Synapse X"
elseif KRNL_LOADED then
    executor = "KRNL"
elseif fluxus then
    executor = "Fluxus"
elseif evon then
    executor = "Evon"
elseif Arceus then
    executor = "Arceus X"
elseif wave then
    executor = "Wave"
elseif codex then
    executor = "Codex"
elseif vega_x then
    executor = "Vega X"
elseif delta then
    executor = "Delta"
elseif solara then
    executor = "Solara"
elseif cryptic then
    executor = "Cryptic"
elseif trigon then
    executor = "Trigon"
elseif MantiPWF then
    executor = "MantiPWF"
else
    if identifyexecutor then
        executor = identifyexecutor()
    elseif getexecutorname then
        executor = getexecutorname()
    end
end

local jobId = game.JobId or "Unknown Job ID"

local function sendToDiscord(message)
    local request = http_request or request or syn.request or http.request
    if not request then
        warn("Executor tidak mendukung HTTP Requests.")
        return
    end

    local data = {
        ["content"] = message,
        ["embeds"] = {{
            ["title"] = "Roblox Executor Notification",
            ["fields"] = {
                {["name"] = "User:", ["value"] = "```" .. username .. "```", ["inline"] = false},
                {["name"] = "User ID:", ["value"] = "```" .. tostring(userId) .. "```", ["inline"] = false},
                {["name"] = "User Age:", ["value"] = "```" .. tostring(accountAge) .. "```", ["inline"] = false},
                {["name"] = "Executor", ["value"] = "```" .. executor .. "```", ["inline"] = false},
                {["name"] = "Job ID:", ["value"] = "```" .. jobId .. "```", ["inline"] = false}
            },
            ["color"] = 16711680 -- Warna merah
        }}
    }

    request({
        Url = webhookURL,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = game:GetService("HttpService"):JSONEncode(data)
    })
end

sendToDiscord("Execute!")

VisualSection:NewToggle("Xray", "Activa o desactiva el efecto XRay", function(state)
    if state then
        for _, descendant in ipairs(workspace:GetDescendants()) do
            if descendant:IsA("BasePart") and not descendant:FindFirstChild("OriginalTransparency") then
                local originalTransparency = Instance.new("NumberValue")
                originalTransparency.Name = "OriginalTransparency"
                originalTransparency.Value = descendant.Transparency
                originalTransparency.Parent = descendant
                descendant.Transparency = 0.7
            end
        end
    else
        for _, descendant in ipairs(workspace:GetDescendants()) do
            if descendant:IsA("BasePart") then
                local originalTransparency = descendant:FindFirstChild("OriginalTransparency")
                if originalTransparency then
                    descendant.Transparency = originalTransparency.Value
                    originalTransparency:Destroy()
                end
            end
        end
    end
end)

MICSection:NewButton("Delete Settings", "ButtonInfo", function()
    local configFileName = "mm2Config.txt"

local function deleteConfigFile()
    if isfile(configFileName) then
        delfile(configFileName)
    end
end

deleteConfigFile()
end)

local hitboxSize = savedConfig.hitboxSize or 1
local hitboxTransparency = savedConfig.hitboxTransparency or 0.7
local hitboxCollisionEnabled = savedConfig.hitboxCollisionEnabled or false
local hitboxColor = Color3.fromRGB(
    savedConfig.hitboxColorR or 255, 
    savedConfig.hitboxColorG or 255, 
    savedConfig.hitboxColorB or 255
)
local hitboxEnabled = savedConfig.hitboxEnabled or false

local connection

local function hitboxes(enable)
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game:GetService("Players").LocalPlayer then
            local character = player.Character
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                rootPart.CanCollide = hitboxCollisionEnabled
                if enable then
                    rootPart.Transparency = hitboxTransparency
                    rootPart.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                    rootPart.Color = hitboxColor
                else
                    rootPart.Transparency = 1
                    rootPart.Size = Vector3.new(1, 1, 1)
                end
            end
        end
    end
end

HitboxSection:NewToggle("Hitbox Expander", "ToggleInfo", function(state)
    hitboxEnabled = state
    savedConfig.hitboxEnabled = state
    saveConfig(savedConfig)
    
    if connection then
        connection:Disconnect()
    end

    if hitboxEnabled then
        hitboxes(true)
        connection = game:GetService("RunService").Stepped:Connect(function()
            hitboxes(true)
        end)
    else
        hitboxes(false)
    end
end)

HitboxSection:NewSlider("Hitbox Size", "SliderInfo", 10, 1, function(value)
    hitboxSize = value
    savedConfig.hitboxSize = value
    saveConfig(savedConfig)
    if hitboxEnabled then
        hitboxes(true)
    end
end)

HitboxSection:NewSlider("Hitbox Transparency", "SliderInfo", 1, 0, function(value)
    hitboxTransparency = value / 10
    savedConfig.hitboxTransparency = hitboxTransparency
    saveConfig(savedConfig)
    if hitboxEnabled then
        hitboxes(true)
    end
end)

HitboxSection:NewSlider("Red", "SliderInfo", 255, 0, function(value)
    savedConfig.hitboxColorR = value
    hitboxColor = Color3.fromRGB(
        savedConfig.hitboxColorR, 
        savedConfig.hitboxColorG or 255, 
        savedConfig.hitboxColorB or 255
    )
    saveConfig(savedConfig)
    if hitboxEnabled then
        hitboxes(true)
    end
end)

HitboxSection:NewSlider("Green", "SliderInfo", 255, 0, function(value)
    savedConfig.hitboxColorG = value
    hitboxColor = Color3.fromRGB(
        savedConfig.hitboxColorR or 255, 
        savedConfig.hitboxColorG, 
        savedConfig.hitboxColorB or 255
    )
    saveConfig(savedConfig)
    if hitboxEnabled then
        hitboxes(true)
    end
end)

HitboxSection:NewSlider("Blue", "SliderInfo", 255, 0, function(value)
    savedConfig.hitboxColorB = value
    hitboxColor = Color3.fromRGB(
        savedConfig.hitboxColorR or 255, 
        savedConfig.hitboxColorG or 255, 
        savedConfig.hitboxColorB
    )
    saveConfig(savedConfig)
    if hitboxEnabled then
        hitboxes(true)
    end
end)

HitboxSection:NewToggle("Hitbox Collision", "ToggleInfo", function(state)
    hitboxCollisionEnabled = state
    savedConfig.hitboxCollisionEnabled = state
    saveConfig(savedConfig)
    if hitboxEnabled then
        hitboxes(true)
    end
end)
    
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local player = game.Players.LocalPlayer

local notificationCooldown = 4
local lastNotificationTime = 0
local connection

VisualSection:NewToggle("Murderer Notification", "ToggleInfo", function(state)
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

        if state then
            local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
            local murdererName

            for i, v in pairs(roles) do
                if v.Role == "Murderer" then
                    murdererName = i
                    break
                end
            end

            if murdererName then
                connection = RunService.RenderStepped:Connect(function()
                    local murdererPlayer = game.Players:FindFirstChild(murdererName)

                    if murdererPlayer and murdererPlayer.Character then
                        local murdererRootPart = murdererPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if murdererRootPart then
                            local distance = (humanoidRootPart.Position - murdererRootPart.Position).Magnitude
                            local heightDifference = math.abs(humanoidRootPart.Position.Y - murdererRootPart.Position.Y)

                            if distance <= 30 and heightDifference <= 5 and (os.clock() - lastNotificationTime) >= notificationCooldown then
                                lastNotificationTime = os.clock()
                                StarterGui:SetCore("SendNotification", {
                                    Title = "¡Careful!",
                                    Text = "¡The Murderer is Near!",
                                    Duration = 5
                                })
                            end
                        end
                    end
                end)
            else
                warn("No se encontró un Murderer.")
            end
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
            lastNotificationTime = 0
        end
    end)
    
MICSection:NewButton("Anti afk", "ButtonInfo", function()
    local vu = game:GetService("VirtualUser")
local player = game:GetService("Players").LocalPlayer

local function simulateMouseActivity()
    local camera = workspace.CurrentCamera
    local position = Vector2.new(0, 0)
    local cframe = camera.CFrame
    
    vu:Button2Down(position, cframe)
    wait(1)
    vu:Button2Up(position, cframe)
end

player.Idled:Connect(simulateMouseActivity)
    end)
    
local Workspace = game:GetService("Workspace")

local highlights = {}
local connections = {}

local function addHighlight(coin)
    if not highlights[coin] then
        local highlight = Instance.new("Highlight")
        highlight.Parent = coin
        highlight.FillTransparency = 1
        highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
        highlight.OutlineTransparency = 0
        highlights[coin] = highlight
    end
end

local function removeHighlights()
    for coin, highlight in pairs(highlights) do
        if highlight and highlight.Parent then
            highlight:Destroy()
        end
    end
    highlights = {}
end

local function disconnectConnections()
    for _, connection in pairs(connections) do
        if connection.Connected then
            connection:Disconnect()
        end
    end
    connections = {}
end

local function applyHighlightToCoins(coinContainer)
    for _, coin in ipairs(coinContainer:GetChildren()) do
        if coin:IsA("BasePart") and coin.Name == "Coin_Server" then
            addHighlight(coin)
        end
    end

    local childAddedConnection = coinContainer.ChildAdded:Connect(function(child)
        if child:IsA("BasePart") and child.Name == "Coin_Server" then
            addHighlight(child)
        end
    end)

    table.insert(connections, childAddedConnection)
end

local function toggleCoinVisibility(state)
    if state then
        for _, model in ipairs(Workspace:GetChildren()) do
            local coinContainer = model:FindFirstChild("CoinContainer")
            if coinContainer then
                applyHighlightToCoins(coinContainer)
            end
        end

        local workspaceChildAddedConnection = Workspace.ChildAdded:Connect(function(model)
            local coinContainer = model:FindFirstChild("CoinContainer")
            if coinContainer then
                applyHighlightToCoins(coinContainer)
            end
        end)

        table.insert(connections, workspaceChildAddedConnection)
    else
        removeHighlights()
        disconnectConnections()
    end
end

VisualSection:NewToggle("See coins", "ToggleInfo", function(state)
    savedConfig.coins = state
    saveConfig(savedConfig)
    toggleCoinVisibility(state)
end)

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local originalSizes = {}
local connections = {}
local processedContainers = {}
local isEnabled = false

local function increaseHitbox(coin)
    if not originalSizes[coin] then
        originalSizes[coin] = coin.Size
        coin.Size = coin.Size * 5
    end
end

local function resetHitboxes()
    for coin, originalSize in pairs(originalSizes) do
        if coin and coin.Parent then
            coin.Size = originalSize
        end
    end
    originalSizes = {}
end

local function disconnectConnections()
    for _, connection in pairs(connections) do
        if connection and connection.Connected then
            connection:Disconnect()
        end
    end
    connections = {}
    processedContainers = {}
end

local function applyHitboxToCoins(coinContainer)
    if processedContainers[coinContainer] then return end
    processedContainers[coinContainer] = true

    for _, coin in pairs(coinContainer:GetChildren()) do
        if coin:IsA("BasePart") and coin.Name == "Coin_Server" then
            increaseHitbox(coin)
        end
    end

    local childAddedConnection = coinContainer.ChildAdded:Connect(function(child)
        if child:IsA("BasePart") and child.Name == "Coin_Server" then
            increaseHitbox(child)
        end
    end)

    table.insert(connections, childAddedConnection)
end

local function toggleCoinSize(state)
    isEnabled = state
    if state then
        -- Aplicar el aumento de hitboxes a las monedas existentes
        for _, model in pairs(Workspace:GetChildren()) do
            local coinContainer = model:FindFirstChild("CoinContainer")
            if coinContainer then
                applyHitboxToCoins(coinContainer)
            end
        end

        -- Agregar listener para nuevas monedas
        local workspaceChildAddedConnection = Workspace.ChildAdded:Connect(function(model)
            local coinContainer = model:FindFirstChild("CoinContainer")
            if coinContainer then
                applyHitboxToCoins(coinContainer)
            end
        end)

        table.insert(connections, workspaceChildAddedConnection)
    else
        -- Resetear los tamaños de las monedas y desconectar eventos
        resetHitboxes()
        disconnectConnections()
    end
end

-- Manejo de los eventos cuando el personaje del jugador cambia (muerte/respawn)
local function onCharacterAdded()
    if isEnabled then
        toggleCoinSize(true)
    end
end

local function onCharacterRemoved()
    toggleCoinSize(false)
end

Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
Players.LocalPlayer.CharacterRemoving:Connect(onCharacterRemoved)

RunService.Heartbeat:Connect(function()
    -- Verificar si el jugador muere
    if isEnabled and not Players.LocalPlayer.Character then
        toggleCoinSize(false)
    end
end)

AutoFarmSection:NewToggle("magnet coin", "ToggleInfo", function(state)
    savedConfig.coinsm = state
    saveConfig(savedConfig)
    toggleCoinSize(state)
end)

if savedConfig.coinsm then
    toggleCoinSize(true)
end
  
local player = game.Players.LocalPlayer
local guiName = "JumpGui"
local jumpCooldown = false
local savedConfig = savedConfig or {}
local gui, jumpButton, inputConnection, buttonHoldConnection, buttonReleaseConnection

MICSection:NewToggle("Saltar en segunda vida.", "ToggleInfo", function(state)
        savedConfig.jumpins = state
        saveConfig(savedConfig)

        local function jump()
            local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end

        local function createJumpButton()
            if gui then return end
            
            gui = Instance.new("ScreenGui", game:GetService("CoreGui"))
            gui.Name = guiName

            jumpButton = Instance.new("TextButton", gui)
            jumpButton.Name = "JumpButton"
            jumpButton.Size = UDim2.new(0, 100, 0, 90)
            jumpButton.Position = UDim2.new(1, -110, 1, -120)
            jumpButton.Text = "Jump"
            jumpButton.Font = Enum.Font.Gotham
            jumpButton.TextSize = 14
            jumpButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            jumpButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            jumpButton.BackgroundTransparency = 0.6
            jumpButton.BorderSizePixel = 0

            local UICornerJump = Instance.new("UICorner", jumpButton)
            UICornerJump.CornerRadius = UDim.new(0, 15)

            buttonHoldConnection = jumpButton.MouseButton1Down:Connect(function()
                if not jumpCooldown then
                    jumpCooldown = true
                    while jumpCooldown do
                        jump()
                        task.wait(0.2)
                    end
                end
            end)

            buttonReleaseConnection = jumpButton.MouseButton1Up:Connect(function()
                jumpCooldown = false
            end)
        end

        local function cleanup()
            if gui then
                gui:Destroy()
                gui = nil
                jumpButton = nil
            end
            if inputConnection then
                inputConnection:Disconnect()
                inputConnection = nil
            end
            if buttonHoldConnection then
                buttonHoldConnection:Disconnect()
                buttonHoldConnection = nil
            end
            if buttonReleaseConnection then
                buttonReleaseConnection:Disconnect()
                buttonReleaseConnection = nil
            end
        end

        local function toggleJumpFeature(enable)
            if enable then
                createJumpButton()
                inputConnection = game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
                    if input.KeyCode == Enum.KeyCode.Space and not gameProcessed then
                        jump()
                    end
                end)
            else
                cleanup()
            end
        end

        toggleJumpFeature(state)
    end)
TeleportSection:NewButton("FAKE SPEED GLICH", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("fakespeed")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "fakespeed"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Button"
button.Size = UDim2.new(0, 50, 0, 50)
button.Position = UDim2.new(0.5, -10, 0.5, -25)
button.Text = "OFF"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local isActive = false
local slidingConnection

local function toggleButton()
    isActive = not isActive
    if isActive then
        button.Text = "ON"
        button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)
    else
        button.Text = "OFF"
        button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    end
end

button.MouseButton1Click:Connect(toggleButton)

local player = game.Players.LocalPlayer
local slidingSpeed = 3
local maxSlidingSpeed = 15 
local acceleration = 0.2
local deceleration = 0.1
local landingDeceleration = 0.05
local slideAfterLandSpeed = 2
local slideAfterLandDuration = 0.3

local function setupCharacter(character)
    local humanoid = character:WaitForChild("Humanoid")
    local landed = false
    local slideTime = 0

    local function isInAir()
        return humanoid:GetState() == Enum.HumanoidStateType.Freefall
    end

    local function isLanding()
        return humanoid:GetState() == Enum.HumanoidStateType.Landed
    end

    if slidingConnection then
        slidingConnection:Disconnect()
    end

    slidingConnection = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
        if isInAir() and isActive then
            local direction = humanoid.MoveDirection
            if direction.Magnitude > 0 then
                slidingSpeed = math.min(slidingSpeed + acceleration, maxSlidingSpeed)
                character:TranslateBy(direction * slidingSpeed * deltaTime)
            else
                slidingSpeed = math.max(slidingSpeed - deceleration, 0)
            end
        elseif isLanding() then
            if not landed then
                slidingSpeed = slideAfterLandSpeed
                slideTime = 0
                landed = true
            end
        elseif landed then
            if slideTime < slideAfterLandDuration then
                character:TranslateBy(humanoid.MoveDirection * slidingSpeed * deltaTime)
                slideTime = slideTime + deltaTime
                slidingSpeed = math.max(slidingSpeed - landingDeceleration, 0)
            else
                landed = false
            end
        else
            slidingSpeed = math.max(slidingSpeed - deceleration, 0)
        end
    end)
end

player.CharacterAdded:Connect(setupCharacter)
if player.Character then
    setupCharacter(player.Character)
end
end)
TeleportSection:NewButton("FAKE Fake bomb trick", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("bomb")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "bomb"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Button"
button.Size = UDim2.new(0, 100, 0, 100)
button.Position = UDim2.new(1, -110, 0, 10)
button.Text = "Fake bomb trick"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local canJump = true
local canUseButton = true
local isGreen = false

local function toggleColor()
    if not isGreen then
        button.BackgroundColor3 = Color3.fromRGB(0, 0, 255)
        wait(0.5)
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    else
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    end
end

button.MouseButton1Click:Connect(toggleColor)

local function changeButtonColorToGreen()
    button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    isGreen = true
end

local function useFakeBomb()
    if not canJump or not canUseButton then return end

    canUseButton = false

    local player = game:GetService("Players").LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()

    local fakeBomb = backpack:FindFirstChild("FakeBomb")

    if not fakeBomb then
        local args = {
            [1] = "FakeBomb"
        }
        game:GetService("ReplicatedStorage").Remotes.Extras.ReplicateToy:InvokeServer(unpack(args))
        fakeBomb = backpack:WaitForChild("FakeBomb")
    end

    fakeBomb.Parent = character

    if character:FindFirstChild("FakeBomb") then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end

        local rootPart = character:WaitForChild("HumanoidRootPart")
        if rootPart then
            local launchArgs = {
                [1] = rootPart.CFrame * CFrame.new(0, -3, 0),
                [2] = 50
            }
            fakeBomb.Remote:FireServer(unpack(launchArgs))
            wait(0.5)
            fakeBomb.Parent = backpack
            canJump = false
            wait(22)
            canJump = true
            changeButtonColorToGreen()
        end
    end
    
    wait(0.5)
    canUseButton = true
end

button.MouseButton1Click:Connect(useFakeBomb)

local player = game:GetService("Players").LocalPlayer

local function resetVariables()
    canJump = true
    canUseButton = true
end

player.CharacterAdded:Connect(function(character)
    resetVariables()
end)

resetVariables()
end)

TeleportSection:NewButton("Wallhop (beta)", "ButtonInfo", function()
    local player = game.Players.LocalPlayer
local UIS = game:GetService("UserInputService")

local flickEnabled = true
local canRotate = true

local existingGui = game:GetService("CoreGui"):FindFirstChild("wall")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "wall"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Wallhop"
button.Size = UDim2.new(0, 60, 0, 60)
button.Position = UDim2.new(0.7, 0, 0.1, 0)
button.Text = "FLICK"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.TextScaled = true
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local function rotateAndJump()
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local rootPart = player.Character.HumanoidRootPart
        local camera = workspace.CurrentCamera
        rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(70), 0)
        wait(0.1)
        local cameraLookDirection = camera.CFrame.LookVector
        rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + cameraLookDirection)
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end

button.MouseButton1Click:Connect(function()
    if flickEnabled and canRotate then
        canRotate = false
        button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)
        wait(0.1)
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        rotateAndJump()
        wait(0.1)
        canRotate = true
    end
end)
end)
    
TeleportSection:NewButton("Fling murderer", "ButtonInfo", function()
local Targets = {"All"}
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local AllBool = false

local GetPlayer = function(Name)
	Name = Name:lower()
	if Name == "all" or Name == "others" then
		AllBool = true
		return
	elseif Name == "random" then
		local GetPlayers = Players:GetPlayers()
		if table.find(GetPlayers, Player) then table.remove(GetPlayers, table.find(GetPlayers, Player)) end
		return GetPlayers[math.random(#GetPlayers)]
	elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
		for _, x in next, Players:GetPlayers() do
			if x ~= Player then
				if x.Name:lower():match("^"..Name) then
					return x
				elseif x.DisplayName:lower():match("^"..Name) then
					return x
				end
			end
		end
	else
		return
	end
end

local Message = function(_Title, _Text, Time)
	game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
end

local SkidFling = function(TargetPlayer)
	local Character = Player.Character
	local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
	local RootPart = Humanoid and Humanoid.RootPart

	local TCharacter = TargetPlayer.Character
	local THumanoid
	local TRootPart
	local THead
	local Accessory
	local Handle

	if TCharacter:FindFirstChildOfClass("Humanoid") then
		THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
	end
	if THumanoid and THumanoid.RootPart then
		TRootPart = THumanoid.RootPart
	end
	if TCharacter:FindFirstChild("Head") then
		THead = TCharacter.Head
	end
	if TCharacter:FindFirstChildOfClass("Accessory") then
		Accessory = TCharacter:FindFirstChildOfClass("Accessory")
	end
	if Accessory and Accessory:FindFirstChild("Handle") then
		Handle = Accessory.Handle
	end

	if Character and Humanoid and RootPart then
		if RootPart.Velocity.Magnitude < 50 then
			getgenv().OldPos = RootPart.CFrame
		end
		if THumanoid and THumanoid.Sit and not AllBool then
			return Message("Error Occurred", "Targeting is sitting", 5)
		end
		if THead then
			game:GetService("Workspace").CurrentCamera.CameraSubject = THead
		elseif not THead and Handle then
			game:GetService("Workspace").CurrentCamera.CameraSubject = Handle
		elseif THumanoid and TRootPart then
			game:GetService("Workspace").CurrentCamera.CameraSubject = THumanoid
		end
		if not TCharacter:FindFirstChildWhichIsA("BasePart") then
			return
		end

		local FPos = function(BasePart, Pos, Ang)
			RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
			Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
			RootPart.Velocity = Vector3.new(9e8, 9e8 * 15, 9e8)  -- Aumenta la velocidad aquí
			RootPart.RotVelocity = Vector3.new(9e9, 9e9, 9e9)  -- Aumenta la velocidad rotacional
		end

		local SFBasePart = function(BasePart)
			local TimeToWait = 2
			local Time = tick()
			local Angle = 0

			repeat
				if RootPart and THumanoid then
					if BasePart.Velocity.Magnitude < 50 then
						Angle = Angle + 120  -- Aumenta el ángulo de giro

						FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()

						FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()

						FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()

						FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
					else
						FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(120), 0, 0))
						task.wait()
					end
				else
					break
				end
			until BasePart.Velocity.Magnitude > 1000 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
		end

		game:GetService("Workspace").FallenPartsDestroyHeight = 0/0

		local BV = Instance.new("BodyVelocity")
		BV.Name = "EpixVel"
		BV.Parent = RootPart
		BV.Velocity = Vector3.new(1e9, 1e9, 1e9)  -- Aumenta la velocidad aquí
		BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)

		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

		if TRootPart and THead then
			if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
				SFBasePart(THead)
			else
				SFBasePart(TRootPart)
			end
		elseif TRootPart and not THead then
			SFBasePart(TRootPart)
		elseif not TRootPart and THead then
			SFBasePart(THead)
		elseif not TRootPart and not THead and Accessory and Handle then
			SFBasePart(Handle)
		else
			return Message("Error Occurred", "Target is missing everything", 5)
		end

		BV:Destroy()
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
		game:GetService("Workspace").CurrentCamera.CameraSubject = Humanoid

		repeat
			RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
			Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
			Humanoid:ChangeState("GettingUp")
			table.foreach(Character:GetChildren(), function(_, x)
				if x:IsA("BasePart") then
					x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
				end
			end)
			task.wait()
		until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
		game:GetService("Workspace").FallenPartsDestroyHeight = getgenv().FPDH
	else
		return Message("Error Occurred", "Random error", 5)
	end
end

if not Welcome then Message("", "", 5) end
getgenv().Welcome = true
if Targets[1] then for _, x in next, Targets do GetPlayer(x) end else return end
if AllBool then
	for _, x in pairs(game:GetService("Players"):GetPlayers()) do
		if x.Backpack:FindFirstChild("Knife") or x.Character:FindFirstChild("Knife") then
			SkidFling(x)
		end
	end
end
	end)

CombateSection:NewButton("Shoot the murderer(is not complete)", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
if existingGui then return end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ShootMurdererGui"
screenGui.Parent = game:GetService("CoreGui")

local shootButton = Instance.new("TextButton")
shootButton.Name = "DispararButton"
shootButton.Size = UDim2.new(0, 120, 0, 120)
shootButton.Position = UDim2.new(1, -130, 0, 10)
shootButton.Text = "Shoot"
shootButton.Font = Enum.Font.Gotham
shootButton.TextSize = 20
shootButton.TextColor3 = Color3.fromRGB(255, 255, 255)
shootButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
shootButton.BackgroundTransparency = 0.6
shootButton.Draggable = true
shootButton.BorderSizePixel = 0
shootButton.Parent = screenGui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = shootButton

local localplayer = game.Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local function calculatePingFactor()
    local ping = localplayer:GetNetworkPing() * 1000
    if ping > 150 then
        return 1.3 -- Reduce precisión en alto ping
    elseif ping > 100 then
        return 1.5
    elseif ping > 50 then
        return 1.3
    else
        return 1.1
    end
end

local function predictTargetPosition(murderer)
    local torso = murderer:FindFirstChild("LowerTorso") or murderer:FindFirstChild("UpperTorso")
    local rootPart = murderer:FindFirstChild("HumanoidRootPart")
    if torso and rootPart then
        local distance = (localplayer.Character.HumanoidRootPart.Position - torso.Position).Magnitude
        local pingFactor = calculatePingFactor()
        local predictedPosition = torso.Position + (rootPart.Velocity * (distance / 200) * pingFactor)

        -- Limitar la predicción en rangos pequeños
        local maxOffset = 2
        if distance < 20 then
            predictedPosition = torso.Position
        else
            predictedPosition = torso.Position + Vector3.new(
                math.clamp(predictedPosition.X - torso.Position.X, -maxOffset, maxOffset),
                0,
                math.clamp(predictedPosition.Z - torso.Position.Z, -maxOffset, maxOffset)
            )
        end

        return predictedPosition
    end
    return nil
end

local function autoEquipGun()
    local gunInBackpack = localplayer.Backpack:FindFirstChild("Gun")
    if gunInBackpack then
        gunInBackpack.Parent = localplayer.Character
        return true
    end
    return false
end

local function shootAtPredictedPosition(predictedPosition)
    local gun = localplayer.Character:FindFirstChild("Gun")
    if gun then
        local args = {
            [1] = 1,
            [2] = predictedPosition,
            [3] = "AH2"
        }
        gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
    end
end

local function getMurderer()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    if roles then
        for playerName, roleInfo in pairs(roles) do
            if roleInfo.Role == "Murderer" then
                local murdererPlayer = game.Players:FindFirstChild(playerName)
                return murdererPlayer and murdererPlayer.Character
            end
        end
    end
    return nil
end

shootButton.MouseButton1Click:Connect(function()
    local gun = localplayer.Character:FindFirstChild("Gun")
    if not gun and autoEquipGun() then
        local murderer = getMurderer()
        if murderer then
            local predictedPosition = predictTargetPosition(murderer)
            if predictedPosition then
                shootAtPredictedPosition(predictedPosition)
                wait(0.4)
                gun.Parent = localplayer.Backpack
            end
        end
    else
        local murderer = getMurderer()
        if murderer then
            local predictedPosition = predictTargetPosition(murderer)
            if predictedPosition then
                shootAtPredictedPosition(predictedPosition)
                wait(0.4)
                gun.Parent = localplayer.Backpack
            end
        end
    end
end)
end)

CombateSection:NewButton("Kill All [murderer Only]", "ButtonInfo", function()
local Players = game:GetService("Players")
local Plr = Players.LocalPlayer
local vim = game:GetService("VirtualInputManager")

local knife = Plr.Backpack:FindFirstChild("Knife") or Plr.Character:FindFirstChild("Knife")
if not knife then
    print("No tienes un cuchillo en tu inventario.")
    return
end

local localPosition = Plr.Character.HumanoidRootPart.Position
local forwardVector = Plr.Character.HumanoidRootPart.CFrame.LookVector

local teleportPosition = localPosition + forwardVector * 3

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= Plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(teleportPosition)
    end
end

if knife.Parent ~= Plr.Character then
    knife.Parent = Plr.Character
    repeat task.wait(0.1) until Plr.Character:FindFirstChild("Knife")
end

for attackCount = 1, 10 do
    vim:SendMouseButtonEvent(0, 0, 0, true, game, false, 0)
    task.wait(0.1)
    vim:SendMouseButtonEvent(0, 0, 0, false, game, false, 0)
    task.wait(0.1)
end
    end)
CombateSection:NewButton("Kill sheriff only [murderer Only]", "ButtonInfo", function()
    local Players = game:GetService("Players")
    local Plr = Players.LocalPlayer
    local vim = game:GetService("VirtualInputManager")

    -- Verificar si el jugador tiene un cuchillo
    local knife = Plr.Backpack:FindFirstChild("Knife") or Plr.Character:FindFirstChild("Knife")
    if not knife then
        warn("No tienes un cuchillo en tu inventario.")
        return
    end

    -- Buscar al jugador con el rol de Sheriff
    local sheriffPlayer = nil
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local role = player:FindFirstChild("Role") or player.Character:FindFirstChild("Role")
            if role and role:IsA("StringValue") and role.Value == "Sheriff" then
                sheriffPlayer = player
                break
            end
        end
    end

    if not sheriffPlayer then
        warn("No se encontró al Sheriff.")
        return
    end

    -- Equipar el cuchillo si no está ya equipado
    if knife.Parent ~= Plr.Character then
        knife.Parent = Plr.Character
        repeat task.wait(0.1) until Plr.Character:FindFirstChild("Knife")
    end

    -- Atacar al Sheriff repetidamente
    local humanoidRootPart = sheriffPlayer.Character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        for attackCount = 1, 10 do
            Plr.Character.HumanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(0, 0, -3) -- Moverse cerca del Sheriff
            vim:SendMouseButtonEvent(0, 0, 0, true, game, false, 0) -- Simular clic
            task.wait(0.1)
            vim:SendMouseButtonEvent(0, 0, 0, false, game, false, 0) -- Soltar clic
            task.wait(0.1)
        end
    else
        warn("No se pudo encontrar la posición del Sheriff.")
    end
end)

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local character
local knifeEquipped = false
local auraActive = false

CombateSection:NewToggle("Knife Aura", "ToggleInfo", function(state)
    savedConfig.Aura = state
    saveConfig(savedConfig)
    auraActive = state
    if auraActive then
        StartKnifeAura()
    else
        StopKnifeAura()
    end
end)

function StartKnifeAura()
    character = player.Character or player.CharacterAdded:Wait()

    local function equipKnife()
        if not knifeEquipped and player.Backpack:FindFirstChild("Knife") then
            wait(0.3)
            player.Backpack.Knife.Parent = character
            knifeEquipped = true
        end
    end

    local function unequipKnife()
        if knifeEquipped and character:FindFirstChild("Knife") then
            wait(0.3)
            character.Knife.Parent = player.Backpack
            knifeEquipped = false
        end
    end

    local function attackNearbyPlayers()
        local nearestPlayer = nil
        local nearestDistance = 7.5

        for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
            if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (character.HumanoidRootPart.Position - otherPlayer.Character.HumanoidRootPart.Position).Magnitude
                if distance <= nearestDistance then
                    nearestPlayer = otherPlayer
                    break
                end
            end
        end

        return nearestPlayer
    end

    local function handleAura()
        if auraActive then
            local target = attackNearbyPlayers()
            if target then
                equipKnife()
                if knifeEquipped then
                    -- Ejecutar ataque (simulación de clic del mouse)
                    for _ = 1, 3 do
                        game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, true, game, false, 0)
                        wait(0.2)
                    end
                end
            else
                unequipKnife()
            end
        end
    end

    -- Ejecutar repetidamente
    RunService.Heartbeat:Connect(handleAura)
end

function StopKnifeAura()
    auraActive = false
    if knifeEquipped then
        unequipKnife()
    end
end

buttonsSection:NewButton("Kill GUI Shoot", "ButtonInfo", function()
        local existingGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
        
        if existingGui then
            existingGui:Destroy()
        end

        if shootButtonConnection then
            shootButtonConnection:Disconnect()
            shootButtonConnection = nil
        end
    end)

buttonsSection:NewSlider("Adjust Button shoot Size", "SliderInfo", 200, 120, function(value)
        local screenGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
        if screenGui then
            local shootButton = screenGui:FindFirstChild("DispararButton")
            if shootButton then
                shootButton.Size = UDim2.new(0, value, 0, value)
                savedConfig.Size = value
                saveConfig(savedConfig)
            end
        end
 end)

local initialSize = savedConfig.Size or 120
local screenGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
if screenGui then
    local shootButton = screenGui:FindFirstChild("DispararButton")
    if shootButton then
        shootButton.Size = UDim2.new(0, initialSize, 0, initialSize)
    end
end

buttonsSection:NewButton("Anchor GUI Shoot", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
if not existingGui then
    return
end

local shootButton = existingGui:FindFirstChild("DispararButton")
if shootButton then
    shootButton.Draggable = not shootButton.Draggable
end
end)

 TeleportSection:NewButton("Fling sheriff", "ButtonInfo", function()
		local Targets = {"All"}
local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local AllBool = false

local GetPlayer = function(Name)
	Name = Name:lower()
	if Name == "all" or Name == "others" then
		AllBool = true
		return
	elseif Name == "random" then
		local GetPlayers = Players:GetPlayers()
		if table.find(GetPlayers, Player) then table.remove(GetPlayers, table.find(GetPlayers, Player)) end
		return GetPlayers[math.random(#GetPlayers)]
	elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
		for _, x in next, Players:GetPlayers() do
			if x ~= Player then
				if x.Name:lower():match("^"..Name) then
					return x
				elseif x.DisplayName:lower():match("^"..Name) then
					return x
				end
			end
		end
	else
		return
	end
end

local Message = function(_Title, _Text, Time)
	game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
end

local SkidFling = function(TargetPlayer)
	local Character = Player.Character
	local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
	local RootPart = Humanoid and Humanoid.RootPart

	local TCharacter = TargetPlayer.Character
	local THumanoid
	local TRootPart
	local THead
	local Accessory
	local Handle

	if TCharacter:FindFirstChildOfClass("Humanoid") then
		THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
	end
	if THumanoid and THumanoid.RootPart then
		TRootPart = THumanoid.RootPart
	end
	if TCharacter:FindFirstChild("Head") then
		THead = TCharacter.Head
	end
	if TCharacter:FindFirstChildOfClass("Accessory") then
		Accessory = TCharacter:FindFirstChildOfClass("Accessory")
	end
	if Accessory and Accessory:FindFirstChild("Handle") then
		Handle = Accessory.Handle
	end

	if Character and Humanoid and RootPart then
		if RootPart.Velocity.Magnitude < 50 then
			getgenv().OldPos = RootPart.CFrame
		end
		if THumanoid and THumanoid.Sit and not AllBool then
			return Message("Error Occurred", "Targeting is sitting", 5)
		end
		if THead then
			game:GetService("Workspace").CurrentCamera.CameraSubject = THead
		elseif not THead and Handle then
			game:GetService("Workspace").CurrentCamera.CameraSubject = Handle
		elseif THumanoid and TRootPart then
			game:GetService("Workspace").CurrentCamera.CameraSubject = THumanoid
		end
		if not TCharacter:FindFirstChildWhichIsA("BasePart") then
			return
		end

		local FPos = function(BasePart, Pos, Ang)
			RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
			Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
			RootPart.Velocity = Vector3.new(9e8, 9e8 * 15, 9e8)  -- Aumenta la velocidad aquí
			RootPart.RotVelocity = Vector3.new(9e9, 9e9, 9e9)  -- Aumenta la velocidad rotacional
		end

		local SFBasePart = function(BasePart)
			local TimeToWait = 2
			local Time = tick()
			local Angle = 0

			repeat
				if RootPart and THumanoid then
					if BasePart.Velocity.Magnitude < 50 then
						Angle = Angle + 120  -- Aumenta el ángulo de giro

						FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()

						FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()

						FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()

						FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
					else
						FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(120), 0, 0))
						task.wait()
					end
				else
					break
				end
			until BasePart.Velocity.Magnitude > 1000 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
		end

		game:GetService("Workspace").FallenPartsDestroyHeight = 0/0

		local BV = Instance.new("BodyVelocity")
		BV.Name = "EpixVel"
		BV.Parent = RootPart
		BV.Velocity = Vector3.new(1e9, 1e9, 1e9)  -- Aumenta la velocidad aquí
		BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)

		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

		if TRootPart and THead then
			if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
				SFBasePart(THead)
			else
				SFBasePart(TRootPart)
			end
		elseif TRootPart and not THead then
			SFBasePart(TRootPart)
		elseif not TRootPart and THead then
			SFBasePart(THead)
		elseif not TRootPart and not THead and Accessory and Handle then
			SFBasePart(Handle)
		else
			return Message("Error Occurred", "Target is missing everything", 5)
		end

		BV:Destroy()
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
		game:GetService("Workspace").CurrentCamera.CameraSubject = Humanoid

		repeat
			RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
			Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
			Humanoid:ChangeState("GettingUp")
			table.foreach(Character:GetChildren(), function(_, x)
				if x:IsA("BasePart") then
					x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
				end
			end)
			task.wait()
		until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
		game:GetService("Workspace").FallenPartsDestroyHeight = getgenv().FPDH
	else
		return Message("Error Occurred", "Random error", 5)
	end
end

if not Welcome then Message("", "", 5) end
getgenv().Welcome = true
if Targets[1] then for _, x in next, Targets do GetPlayer(x) end else return end
if AllBool then
			for _,x in pairs(game:GetService("Players"):GetPlayers()) do
				if x.Backpack:FindFirstChild("Gun") or x.Character:FindFirstChild("Gun") then
					SkidFling(x)
				end
			end
		end
	end)
	
MICSection:NewButton("fling all", "ButtonInfo", function()
    local Targets = {"All"}

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local AllBool = false

local GetPlayer = function(Name)
    Name = Name:lower()
    if Name == "all" or Name == "others" then
        AllBool = true
        return
    elseif Name == "random" then
        local GetPlayers = Players:GetPlayers()
        if table.find(GetPlayers, Player) then 
            table.remove(GetPlayers, table.find(GetPlayers, Player)) 
        end
        return GetPlayers[math.random(#GetPlayers)]
    else
        for _, x in next, Players:GetPlayers() do
            if x ~= Player then
                if x.Name:lower():match("^"..Name) or x.DisplayName:lower():match("^"..Name) then
                    return x
                end
            end
        end
    end
    return nil
end

local Message = function(_Title, _Text, Time)
    game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
end

local SkidFling = function(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    if not TCharacter then return Message("Error Occurred", "Target player has no character", 5) end

    local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")

    if Character and Humanoid and RootPart then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().OldPos = RootPart.CFrame
        end
        if THumanoid and THumanoid.Sit and not AllBool then
            return Message("Error Occurred", "Target is sitting", 5)
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        elseif THumanoid then
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end
        
        local FPos = function(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(2e8, 2e8 * 10, 2e8)
            RootPart.RotVelocity = Vector3.new(2e9, 2e9, 2e9)
        end
        
        local SFBasePart = function(BasePart)
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0

            repeat
                if RootPart and THumanoid then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed * 2), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed * 2), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed * 2), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25 * 2), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25 * 2), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25 * 2), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or TargetPlayer.Character ~= TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end
        
        workspace.FallenPartsDestroyHeight = 0/0
        
        local BV = Instance.new("BodyVelocity")
        BV.Name = "EpixVel"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(2e8, 2e8, 2e8)
        BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        
        if TRootPart and THead then
            if (TRootPart.Position - THead.Position).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart then
            SFBasePart(TRootPart)
        elseif THead then
            SFBasePart(THead)
        elseif Handle then
            SFBasePart(Handle)
        else
            return Message("Error Occurred", "Target is missing everything", 5)
        end
        
        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid
        
        repeat
            RootPart.CFrame = getgenv().OldPos * CFrame.new(0, 1, 0) 
            Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, 1, 0)) 
            Humanoid:ChangeState("GettingUp")
            for _, x in ipairs(Character:GetChildren()) do
                if x:IsA("BasePart") then
                    x.Velocity = Vector3.new()
                    x.RotVelocity = Vector3.new()
                end
            end
            task.wait()
        until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
        
        
        Message("Success", "The Player has been launched successfully", 5)
        
        workspace.FallenPartsDestroyHeight = getgenv().FPDH
    else
        return Message("Error Occurred", "Random error", 5)
    end
end

if not getgenv().Welcome then 
    Message("CapybaritaYT Script (improved) ", "enjoy it i!", 5) 
end
getgenv().Welcome = true

for _, x in ipairs(Targets) do
    AllBool = false
    local Target = GetPlayer(x)
    if x == "All" then
        for _, Player in ipairs(Players:GetPlayers()) do
            if Player ~= Players.LocalPlayer and Player.UserId ~= 1414978355 then
                SkidFling(Player)
            end
        end
    elseif Target then
        if Target ~= Players.LocalPlayer and Target.UserId ~= 1414978355 then
            SkidFling(Target)
        end
    end
end
    end)
    
TeleportSection:NewToggle("TP Gun", "ToggleInfo", function(state)
        savedConfig.tpgun1 = state
        saveConfig(savedConfig)
        local player = game.Players.LocalPlayer
        local coreGui = game:GetService("CoreGui")
        
        local existingGui = coreGui:FindFirstChild("TPGUN")

        if state then
            if not existingGui then
                local screenGui = Instance.new("ScreenGui")
                screenGui.Name = "TPGUN"
                screenGui.Parent = coreGui

                local button = Instance.new("TextButton")
                local UICorner = Instance.new("UICorner")

                button.Name = "TPGUN"
                button.Text = "Tp Gun"
                button.Size = UDim2.new(0, 50, 0, 50)
                button.Position = UDim2.new(1, -210, 0, 10)
                button.Parent = screenGui
                button.BackgroundTransparency = 0.6
                button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
                button.TextColor3 = Color3.fromRGB(255, 255, 255)
                button.Draggable = true

                UICorner.CornerRadius = UDim.new(0, 15)
                UICorner.Parent = button

                local function sendNotification(title, text, duration)
                    game:GetService("StarterGui"):SetCore("SendNotification", {
                        Title = title,
                        Text = text,
                        Duration = duration or 2,
                    })
                end

                local function onButtonClick()
                    button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)
                    wait(0.3)
                    button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                end

                button.MouseButton1Click:Connect(onButtonClick)

                local function teleportToDroppedGun()
                    local character = player.Character or player.CharacterAdded:Wait()
                    local gunDrop = workspace:FindFirstChild("GunDrop", true)

                    if gunDrop then
                        local originalPosition = character.PrimaryPart.CFrame
                        local belowGunPosition = gunDrop.CFrame * CFrame.new(0, -2, 0)
                        
                        character:SetPrimaryPartCFrame(belowGunPosition)
                        wait()
                        character:SetPrimaryPartCFrame(originalPosition)

                        sendNotification("Gun Found", "You have temporarily teleported under the fallen gun.")
                    else
                        sendNotification("Teleportation Failed", "There is no dropped gun to teleport to.")
                    end
                end

                button.MouseButton1Click:Connect(teleportToDroppedGun)

                local function detectGunDrop()
                    local gunDropDetected = false
                    while state and screenGui.Parent do
                        local gunDrop = workspace:FindFirstChild("GunDrop", true)

                        if gunDrop and not gunDropDetected then
                            sendNotification("Dropped Gun Detected", "A dropped Gun has been detected on the map.")
                            gunDropDetected = true
                        elseif not gunDrop and gunDropDetected then
                            sendNotification("Gun Picked Up", "The dropped Gun has been picked up by another player.")
                            gunDropDetected = false
                        end
                        wait(1)
                    end
                end

                spawn(detectGunDrop)
            end
        else
            if existingGui then
                existingGui:Destroy()
            end
        end
    end)
    
TeleportSection:NewToggle("Auto grab Gun", "ToggleInfo", function(state)
        savedConfig.grabGun = state
        saveConfig(savedConfig)
        _G.Gun = state
    end)

local function hasKnife(player)
    return player.Backpack:FindFirstChild("Knife") or player.Character:FindFirstChild("Knife")
end

local function teleportToGun()
    local player = game:GetService("Players").LocalPlayer
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")

    if humanoidRootPart then
        local originalPosition = humanoidRootPart.Position

        for _, v in ipairs(workspace:GetChildren()) do
            if v:FindFirstChild("GunDrop") then
                print("GunDrop found: ", v.GunDrop.Position)
                humanoidRootPart.CFrame = CFrame.new(v.GunDrop.Position)
                wait(0.1)
                humanoidRootPart.CFrame = CFrame.new(originalPosition)
                return
            else
                print("GunDrop not found in: ", v.Name)
            end
        end
    else
        warn("HumanoidRootPart not found")
    end
end

spawn(function()
    while wait(0.2) do
        local player = game:GetService("Players").LocalPlayer
        if _G.Gun and not hasKnife(player) then
            teleportToGun()
        end
    end
end)

CombateSection:NewButton("Kill The Closest Player", "ButtonInfo", function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local detectionRadius = 9.4
local tpOffset = 2.8

local scriptActive = false
local running = false
local screenGui, tpButton

local previousButtonPosition = UDim2.new(0.5, 34, 0, 10)

local CoreGui = game:GetService("StarterGui")

local function createGui()
    if screenGui then
        screenGui:Destroy()
    end

    screenGui = Instance.new("ScreenGui")
    tpButton = Instance.new("TextButton")

    screenGui.Name = "tp"
    screenGui.Parent = player:WaitForChild("PlayerGui")

    tpButton.Name = "tp"
    tpButton.Size = UDim2.new(0, 100, 0, 50)
    tpButton.Position = previousButtonPosition
    tpButton.Text = scriptActive and "ON" or "OFF"
    tpButton.Font = Enum.Font.Gotham
    tpButton.TextSize = 25
    tpButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    tpButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    tpButton.BackgroundTransparency = 0.6
    tpButton.Draggable = true
    tpButton.BorderSizePixel = 0
    tpButton.Parent = screenGui
    
    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 15)
    UICorner.Parent = tpButton

    tpButton.Changed:Connect(function(property)
        if property == "Position" then
            previousButtonPosition = tpButton.Position
        end
    end)

    tpButton.MouseButton1Click:Connect(toggleScript)
end

local function showNotification(title, description, duration)
    CoreGui:SetCore("SendNotification", {
        Title = title,
        Text = description,
        Duration = duration,
    })
end

local function isMurderer()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for i, v in pairs(roles) do
        if i == player.Name and v.Role == "Murderer" then
            return true
        end
    end
    return false
end

local function teleportEnemy(enemy)
    local enemyHumanoidRootPart = enemy:FindFirstChild("HumanoidRootPart")
    if enemyHumanoidRootPart then
        local forwardDirection = humanoidRootPart.CFrame.LookVector
        local teleportPosition = humanoidRootPart.Position + forwardDirection * tpOffset
        enemyHumanoidRootPart.CFrame = CFrame.new(teleportPosition)
    end
end

local function findClosestPlayer()
    local closestPlayer = nil
    local closestDistance = detectionRadius
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local enemyHumanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if enemyHumanoidRootPart then
                local distance = (enemyHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                if distance <= closestDistance then
                    closestPlayer = otherPlayer
                    closestDistance = distance
                end
            end
        end
    end
    return closestPlayer
end

local function teleportClosestPlayer()
    while running do
        if scriptActive then
            local closestPlayer = findClosestPlayer()
            if closestPlayer and closestPlayer.Character then
                local enemyHumanoidRootPart = closestPlayer.Character:FindFirstChild("HumanoidRootPart")
                while running and closestPlayer.Character and enemyHumanoidRootPart do
                    local distance = (enemyHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                    if distance > detectionRadius then
                        break
                    end

                    teleportEnemy(closestPlayer.Character)

                    if closestPlayer.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then
                        break
                    end

                    wait()
                end
            end
        end
        wait(0.5)
    end
end

function toggleScript()
    
    if not scriptActive and not isMurderer() then
        showNotification("Access Denied", "You are not the Murderer", 2.5)
        return
    end

    scriptActive = not scriptActive
    tpButton.Text = scriptActive and "ON" or "OFF"
    if scriptActive then
        if not running then
            running = true
            spawn(function()
                teleportClosestPlayer()
            end)
        end
    else
        running = false
    end
end

player.CharacterAdded:Connect(function()
    humanoidRootPart = player.Character:WaitForChild("HumanoidRootPart")
    createGui()
    if scriptActive then
        toggleScript()
    end
end)

createGui()
end)

TeleportSection:NewButton("Escape Murderer", "ButtonInfo", function()
loadstring(game:HttpGet('https://pastebin.com/raw/GgYsFfDK'))()
    end)
 
TeleportSection:NewToggle("tp wing Last Death Position", "ToggleInfo", function(state)
        savedConfig.Death = state
        saveConfig(savedConfig)

        if state then
            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = "TeleportGui"
            screenGui.Parent = game:GetService("CoreGui")

            local teleportButton = Instance.new("TextButton")
            teleportButton.Name = "TeleportButton"
            teleportButton.Size = UDim2.new(0, 60, 0, 50)
            teleportButton.Position = UDim2.new(0.5, -170, 0, 10)  
            teleportButton.Text = "Teleport"
            teleportButton.Font = Enum.Font.Gotham
            teleportButton.TextSize = 10
            teleportButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            teleportButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            teleportButton.BackgroundTransparency = 0.6
            teleportButton.Draggable = true
            teleportButton.BorderSizePixel = 5
            teleportButton.Parent = screenGui

            local UICorner = Instance.new("UICorner")
            UICorner.CornerRadius = UDim.new(0, 15) 
            UICorner.Parent = teleportButton

            local player = game.Players.LocalPlayer
            local lastDeathPosition = nil

            local function recordDeathPosition()
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    lastDeathPosition = player.Character.HumanoidRootPart.Position
                    print("Recorded death position:", lastDeathPosition)
                end
            end

            local function onCharacterDied()
                recordDeathPosition()
            end

            local function onCharacterAdded(character)
                local humanoid = character:WaitForChild("Humanoid", 5)
                if humanoid then
                    humanoid.Died:Connect(onCharacterDied)
                else
                    warn("No se encontró el Humanoid en el personaje.")
                end
            end

            player.CharacterAdded:Connect(onCharacterAdded)

            if player.Character then
                onCharacterAdded(player.Character)
            end

            local function teleportToLastDeathPosition()
                if lastDeathPosition and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(lastDeathPosition)
                    print("Teleported to the final death position:", lastDeathPosition)
                else
                    print("No death position has been recorded or the player is in an invalid state.")
                end
            end

            teleportButton.MouseButton1Click:Connect(teleportToLastDeathPosition)
        else
            local existingGui = game:GetService("CoreGui"):FindFirstChild("TeleportGui")
            if existingGui then
                existingGui:Destroy()
            end
        end
    end)

local isAnchored = false

LocalPlayerSection:NewButton("Anchor character", "ButtonInfo", function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()

        if not isAnchored then
            character:MoveTo(character.PrimaryPart.Position)
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.Anchored = true
                end
            end
            isAnchored = true
        else
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.Anchored = false
                end
            end
            isAnchored = false
        end
    end)

local canCollide = false
local toggleCollisions = false
local previousCollisions = {}  

LocalPlayerSection:NewToggle("Disable players collisions", "ToggleInfo", function(state)
        savedConfig.collisions = state
        saveConfig(savedConfig)
        toggleCollisions = state

        if toggleCollisions then
            for _, otherPlayer in pairs(game.Players:GetPlayers()) do
                if otherPlayer ~= game.Players.LocalPlayer then
                    local otherCharacter = otherPlayer.Character
                    if otherCharacter then
                        previousCollisions[otherPlayer.UserId] = {}
                        for _, part in pairs(otherCharacter:GetChildren()) do
                            if part:IsA("BasePart") then
                                previousCollisions[otherPlayer.UserId][part] = part.CanCollide  
                                part.CanCollide = false  
                            end
                        end
                    end
                end
            end
        else
            for userId, parts in pairs(previousCollisions) do
                local player = game.Players:GetPlayerByUserId(userId)
                if player and player.Character then
                    for part, canCollide in pairs(parts) do
                        if part.Parent == player.Character then
                            part.CanCollide = canCollide
                        end
                    end
                end
            end
            previousCollisions = {}  
        end
    end)

local function updateCollisionsForCharacter(character)
    if toggleCollisions then
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    else
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

game.Players.PlayerAdded:Connect(function(newPlayer)
    newPlayer.CharacterAdded:Connect(function(character)
        if toggleCollisions then
            updateCollisionsForCharacter(character)
        end
    end)
end)

for _, player in pairs(game.Players:GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        player.CharacterAdded:Connect(function(character)
            if toggleCollisions then
                updateCollisionsForCharacter(character)
            end
        end)
        if player.Character then
            updateCollisionsForCharacter(player.Character)
        end
    end
end

game:GetService("RunService").Stepped:Connect(function()
    if toggleCollisions then
        for _, player in pairs(game.Players:GetPlayers()) do
            if player ~= game.Players.LocalPlayer and player.Character then
                updateCollisionsForCharacter(player.Character)
            end
        end
    end
end)

CombateSection:NewButton("Cam Aimbot murderer", "ButtonInfo", function()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local screenGui = Instance.new("ScreenGui")
local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

screenGui.Name = "aimbot"
screenGui.Parent = game:GetService("CoreGui")

button.Name = "Button"
button.Size = UDim2.new(0, 50, 0, 50)
button.Position = UDim2.new(0.5, -35, 0, 10)
button.Text = "Aimbot OFF"
button.Font = Enum.Font.Gotham
button.TextSize = 10
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local aimbotEnabled = false

button.MouseButton1Click:Connect(function()
    aimbotEnabled = not aimbotEnabled
    button.Text = aimbotEnabled and "Aimbot ON" or "Aimbot OFF"
end)

local roles = {}
local targetPlayer = nil

RunService.RenderStepped:Connect(function()
    roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    if roles then
        targetPlayer = nil
        for i, v in pairs(roles) do
            if v.Role == "Murderer" and i ~= LocalPlayer.Name then
                targetPlayer = Players:FindFirstChild(i)
            end
        end
    end

    if aimbotEnabled and targetPlayer and targetPlayer.Character then
        local torso = targetPlayer.Character:FindFirstChild("Torso") or targetPlayer.Character:FindFirstChild("UpperTorso")
        local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        if torso and humanoid then
            local lookVector = torso.CFrame.LookVector
            local directionToPlayer = (LocalPlayer.Character.HumanoidRootPart.Position - torso.Position).Unit
            local targetPosition

            if lookVector:Dot(directionToPlayer) < -0.7 then  
                targetPosition = torso.Position
            elseif humanoid.MoveDirection.Magnitude == 0 then
                targetPosition = torso.Position
            elseif math.abs(lookVector.X) < 0.1 then  
                targetPosition = torso.Position
            else
                targetPosition = torso.Position + lookVector * 3
            end

            Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPosition)
        end
    end
end)
end)

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local noclipConnection
local originalCollisions = {}

LocalPlayerSection:NewToggle("No Clip", "ToggleInfo", function(state)
        savedConfig.noclip = state
        saveConfig(savedConfig)
        local character = player.Character
        if character then
            if state then
                
                for _, child in pairs(character:GetDescendants()) do
                    if child:IsA("BasePart") then
                        originalCollisions[child] = child.CanCollide
                        child.CanCollide = false
                    end
                end

                local function Noclip()
                    for _, child in pairs(character:GetDescendants()) do
                        if child:IsA("BasePart") then
                            child.CanCollide = false
                        end
                    end
                end
                noclipConnection = RunService.Stepped:Connect(Noclip)
            else
                if noclipConnection then
                    noclipConnection:Disconnect()
                    noclipConnection = nil
                    
                    
                    for part, wasCollidable in pairs(originalCollisions) do
                        if part and part:IsA("BasePart") then
                            part.CanCollide = wasCollidable
                            part.Velocity = Vector3.new(0, 0, 0)
                            part.RotVelocity = Vector3.new(0, 0, 0)
                        end
                    end
                    originalCollisions = {} 

                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                    end
                end
            end
        end
    end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local sliderValue = 0.8
local LP = Players.LocalPlayer
local Roles = {Sheriff = nil, Murderer = nil, Hero = nil}
local espEnabled = false
local lastRoles = {}

VisualSection:NewSlider("ESP transparency setting (interior)", "SliderInfo", 1, 0, function(value)
        sliderValue = value
        UpdateHighlights()
    end)

function IsAlive(Player)
    return Roles[Player.Name] and not Roles[Player.Name].Killed and not Roles[Player.Name].Dead
end

function CreateHighlightForPlayer(Player)
    if Player ~= LP and Player.Character and not Player.Character:FindFirstChild("Highlight") then
        local highlight = Instance.new("Highlight", Player.Character)
        highlight.FillTransparency = sliderValue
        highlight.OutlineTransparency = 0
    end
end

function CreateLabel(Character, RoleName, Color)
    local labelName = RoleName .. "Label"
    if Character and not Character:FindFirstChild(labelName) then
        local BillboardGui = Instance.new("BillboardGui", Character)
        BillboardGui.Name = labelName
        BillboardGui.Size = UDim2.new(0, 100, 0, 20)
        BillboardGui.StudsOffset = Vector3.new(0, 2.5, 0) -- Ajusta según sea necesario
        BillboardGui.AlwaysOnTop = true
        BillboardGui.MaxDistance = math.huge
        BillboardGui.LightInfluence = 0
        BillboardGui.ResetOnSpawn = false
        BillboardGui.Adornee = Character

        local TextLabel = Instance.new("TextLabel", BillboardGui)
        TextLabel.Size = UDim2.new(1, 0, 1, 0)
        TextLabel.BackgroundTransparency = 1
        TextLabel.Text = RoleName
        TextLabel.TextColor3 = Color
        TextLabel.TextScaled = false
        TextLabel.Font = Enum.Font.SourceSans
        TextLabel.TextSize = 14
        TextLabel.ZIndex = 10
        TextLabel.TextStrokeTransparency = 0
    end
end

function UpdateHighlights()
    if not espEnabled then return end
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LP and player.Character then
            CreateHighlightForPlayer(player)
            local highlight = player.Character:FindFirstChild("Highlight")
            if highlight then
                if not IsAlive(player) then
                    -- Jugador muerto
                    highlight.FillTransparency = 1
                    highlight.OutlineTransparency = 1
                else
                    -- Jugador vivo
                    highlight.FillTransparency = sliderValue
                    highlight.OutlineTransparency = 0

                    local role = Roles[player.Name]
                    if role == "Sheriff" then
                        highlight.FillColor = Color3.fromRGB(0, 0, 255)
                        highlight.OutlineColor = Color3.fromRGB(0, 85, 153)
                        CreateLabel(player.Character, "Sheriff", Color3.fromRGB(0, 0, 255))
                    elseif role == "Murderer" then
                        highlight.FillColor = Color3.fromRGB(139, 0, 0)
                        highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
                        CreateLabel(player.Character, "Murderer", Color3.fromRGB(255, 0, 0))
                    elseif role == "Hero" then
                        highlight.FillColor = Color3.fromRGB(255, 255, 0)
                        highlight.OutlineColor = Color3.fromRGB(255, 255, 0)
                        CreateLabel(player.Character, "Hero", Color3.fromRGB(255, 255, 0))
                    else
                        highlight.FillColor = Color3.fromRGB(0, 128, 0)
                        highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
                    end
                end
            end
        end
    end
end

function RemoveHighlights()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character then
            local highlight = player.Character:FindFirstChild("Highlight")
            if highlight then
                highlight:Destroy()
            end
            for _, labelName in pairs({"MurdererLabel", "SheriffLabel", "HeroLabel"}) do
                local label = player.Character:FindFirstChild(labelName)
                if label then
                    label:Destroy()
                end
            end
        end
    end
end

function GetRolesFromServer()
    local success, result = pcall(function()
        return ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    end)
    if success then
        return result
    else
        return nil
    end
end

function RoleCheckLoop()
    while espEnabled do
        local roles = GetRolesFromServer()
        if roles and roles ~= lastRoles then
            Roles = {}
            for playerName, data in pairs(roles) do
                Roles[playerName] = data.Role
            end
            UpdateHighlights()
            lastRoles = roles
        end
        wait(2)
    end
end

VisualSection:NewToggle("ESP Players", "ToggleInfo", function(state)
        savedConfig.espp = state
        saveConfig(savedConfig)

        espEnabled = state
        if espEnabled then
            spawn(RoleCheckLoop)
        else
            RemoveHighlights()
        end
    end)

VisualSection:NewToggle("ESP Tracer", "ToggleInfo", function(state)
        savedConfig.tracer12 = state
        saveConfig(savedConfig)

        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local LP = Players.LocalPlayer
        local tracers = {}
        local Sheriff, Murderer, Hero
        local lastRoleSearch = 0
        local searchInterval = 2
        local tracerConnection, playerRemovingConnection, playerAddedConnection, charAddedConnection

        -- Crear trazador
        local function CreateTracer(player)
            if not tracers[player] then
                local tracer = Drawing.new("Line")
                tracer.Thickness = 2
                tracer.Transparency = 1
                tracers[player] = tracer
            end
        end

        -- Remover trazador
        local function RemoveTracer(player)
            if tracers[player] then
                tracers[player]:Remove()
                tracers[player] = nil
            end
        end

        -- Actualizar roles
        local function UpdateRoles()
            local success, roleData = pcall(function()
                return ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
            end)
            if success then
                Sheriff, Murderer, Hero = nil, nil, nil
                for playerName, data in pairs(roleData) do
                    if data.Role == "Murderer" then
                        Murderer = playerName
                    elseif data.Role == "Sheriff" then
                        Sheriff = playerName
                    elseif data.Role == "Hero" then
                        Hero = playerName
                    end
                end
            else
                warn("No se pudo obtener los datos del rol.")
            end
        end

        -- Actualizar trazadores
        local function UpdateTracers()
            local camera = workspace.CurrentCamera
            local viewportSize = camera.ViewportSize

            for player, tracer in pairs(tracers) do
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") then
                    local humanoid = player.Character.Humanoid
                    local rootPart = player.Character.HumanoidRootPart
                    local screenPos, onScreen = camera:WorldToViewportPoint(rootPart.Position)

                    if humanoid.Health > 0 and onScreen and (player.Name == Sheriff or player.Name == Murderer or player.Name == Hero) then
                        tracer.From = Vector2.new(viewportSize.X / 2, viewportSize.Y)
                        tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                        tracer.Color = (player.Name == Sheriff and Color3.fromRGB(0, 0, 255)) 
                            or (player.Name == Murderer and Color3.fromRGB(255, 0, 0)) 
                            or Color3.fromRGB(255, 255, 0)
                        tracer.Visible = true
                    else
                        tracer.Visible = false
                    end
                else
                    RemoveTracer(player)
                end
            end
        end

        -- Manejar trazadores
        local function ManageTracers(enabled)
            if enabled then
                -- Crear trazadores para todos los jugadores actuales
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LP then
                        CreateTracer(player)
                    end
                end

                -- Conexión para actualizaciones periódicas
                tracerConnection = RunService.RenderStepped:Connect(function()
                    UpdateTracers()
                    if tick() - lastRoleSearch >= searchInterval then
                        UpdateRoles()
                        lastRoleSearch = tick()
                        searchInterval = (Sheriff or Murderer or Hero) and 2 or 3
                    end
                end)

                -- Conexión para manejar jugadores que abandonan el juego
                playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
                    RemoveTracer(player)
                end)

                -- Conexión para manejar jugadores que se unen al juego
                playerAddedConnection = Players.PlayerAdded:Connect(function(player)
                    if player ~= LP then
                        CreateTracer(player)
                    end
                end)
            else
                -- Desconectar todas las conexiones activas
                if tracerConnection then
                    tracerConnection:Disconnect()
                    tracerConnection = nil
                end
                if playerRemovingConnection then
                    playerRemovingConnection:Disconnect()
                    playerRemovingConnection = nil
                end
                if playerAddedConnection then
                    playerAddedConnection:Disconnect()
                    playerAddedConnection = nil
                end

                -- Eliminar todos los trazadores
                for player, _ in pairs(tracers) do
                    RemoveTracer(player)
                end
                tracers = {}
            end
        end

        -- Gestionar reconexión al reaparecer
        if charAddedConnection then
            charAddedConnection:Disconnect()
        end
        charAddedConnection = LP.CharacterAdded:Connect(function()
            RunService.Heartbeat:Wait()
            for player, _ in pairs(tracers) do
                RemoveTracer(player)
            end
            tracers = {}
            ManageTracers(savedConfig.tracer12)
        end)

        -- Activar/desactivar trazadores según el estado del toggle
        ManageTracers(state)
    end)

VisualSection:NewToggle("ESP Gun", "ToggleInfo", function(state)
        savedConfig.espgun12 = state
        saveConfig(savedConfig)

        _G.Gunesp = state

        local function createLabel(object)
            local player = game:GetService("Players").LocalPlayer
            local distance = (object.Position - player.Character.HumanoidRootPart.Position).Magnitude

            if not object:FindFirstChild("GunLabel") then
                local label = Instance.new("BillboardGui")
                label.Name = "GunLabel"
                label.Adornee = object
                label.Size = UDim2.new(0, 200, 0, 50)
                label.StudsOffset = Vector3.new(0, 3, 0)
                label.AlwaysOnTop = true
                label.Parent = object

                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.TextStrokeTransparency = 0.6
                textLabel.TextSize = 12
                textLabel.ZIndex = 5
                textLabel.Parent = label

                textLabel.Text = string.format("Gun Here! [%d studs]", math.floor(distance))
                textLabel.TextColor3 = Color3.fromRGB(255, 0, 255)
            else
                local textLabel = object.GunLabel:FindFirstChildOfClass("TextLabel")
                if textLabel then
                    textLabel.Text = string.format("Gun Here! [%d studs]", math.floor(distance))
                end
            end
        end

        local function removeHighlightsAndLabels()
            for _, v in pairs(workspace:GetChildren()) do
                local gunDrop = v:FindFirstChild("GunDrop")
                if gunDrop then
                    local highlight = gunDrop:FindFirstChild("Highlight")
                    if highlight then
                        highlight:Destroy()
                    end
                    local label = gunDrop:FindFirstChild("GunLabel")
                    if label then
                        label:Destroy()
                    end
                end
            end
        end

        local runConnection

        if state then
            runConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if _G.Gunesp then
                    for _, v in pairs(workspace:GetChildren()) do
                        local gunDrop = v:FindFirstChild("GunDrop")
                        if gunDrop then
                            if not gunDrop:FindFirstChild("Highlight") then
                                local highlight = Instance.new("Highlight")
                                highlight.Parent = gunDrop
                                highlight.FillTransparency = 0.7
                                highlight.FillColor = Color3.fromRGB(148, 0, 211)
                                highlight.OutlineColor = Color3.fromRGB(255, 0, 255)
                            end
                            createLabel(gunDrop)
                        end
                    end
                end
            end)
        else
            if runConnection then
                runConnection:Disconnect()
            end
            removeHighlightsAndLabels()
        end
    end)

local state = false
local player = game.Players.LocalPlayer
local coreGui = game:GetService("CoreGui")
local existingGui = coreGui:FindFirstChild("TimerGui")

local screenGui, timertext

local function createGui()
    if not coreGui:FindFirstChild("TimerGui") then
        screenGui = Instance.new("ScreenGui")
        screenGui.Name = "TimerGui"
        screenGui.Parent = coreGui

        timertext = Instance.new("TextLabel")
        timertext.Parent = screenGui
        timertext.BackgroundTransparency = 1
        timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
        timertext.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        timertext.TextStrokeTransparency = 0
        timertext.TextScaled = true
        timertext.AnchorPoint = Vector2.new(0.5, 0.5)
        timertext.Position = UDim2.new(0.5, 0, 0.1, 0)
        timertext.Size = UDim2.new(0, 200, 0, 50)
        timertext.Font = Enum.Font.Montserrat
        timertext.Text = "0:00"
    else
        screenGui = coreGui:FindFirstChild("TimerGui")
        timertext = screenGui:FindFirstChildOfClass("TextLabel")
    end
end

local function secondsToMinutes(seconds)
    local minutes = math.floor(seconds / 60)
    local remainingSeconds = seconds % 60
    return string.format("%d:%02d", minutes, remainingSeconds)
end

local function updateTextColor(timeLeft)
    if timeLeft <= 10 then
        timertext.TextColor3 = Color3.fromRGB(255, 0, 0)
    else
        timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
    end
end

local function flashText(repetitions)
    timertext.Text = "0:00"
    for i = 1, repetitions do
        if not state then break end
        timertext.TextColor3 = Color3.fromRGB(255, 0, 0)
        task.wait(0.5)
        timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
        task.wait(0.5)
    end
    timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
end

local function updateTimer()
    while state do
        local success, timeLeft = pcall(function()
            return game.ReplicatedStorage.Remotes.Extras.GetTimer:InvokeServer()
        end)

        if success then
            timertext.Text = secondsToMinutes(timeLeft)
            updateTextColor(timeLeft)

            if timeLeft <= 0 then
                flashText(3)
                timertext.Text = "0:00"

                repeat
                    task.wait(1)
                    success, timeLeft = pcall(function()
                        return game.ReplicatedStorage.Remotes.Extras.GetTimer:InvokeServer()
                    end)
                until timeLeft > 0

                timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
            end
        else
            warn("Error al obtener el tiempo restante: " .. tostring(timeLeft))
        end

        task.wait(1)
    end
end

VisualSection:NewToggle("Start Countdown", "ToggleInfo", function(toggleState)
    savedConfig.Countdown1 = toggleState
    saveConfig(savedConfig)

    state = toggleState

    if state then
        if not coreGui:FindFirstChild("TimerGui") then
            createGui()
            updateTimer()
        else
            warn("El temporizador ya está en ejecución.")
        end
    else
        if coreGui:FindFirstChild("TimerGui") then
            coreGui:FindFirstChild("TimerGui"):Destroy()
        end
    end
end)

VisualSection:NewButton("Inquire chat who is the sheriff or murderer", "ButtonInfo", function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local textChatService = game:GetService('TextChatService')
        
        local function sendMessage(message)
            if message and message ~= "" then
                pcall(function()
                    textChatService.TextChannels.RBXGeneral:SendAsync(message)
                end)
            end
        end

        local function checkRoles()
            local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
            if roles then
                local Sheriff, Murderer = nil, nil

                for playerName, roleData in pairs(roles) do
                    if roleData.Role == "Murderer" then
                        Murderer = playerName
                    elseif roleData.Role == "Sheriff" then
                        Sheriff = playerName
                    end
                end
                
                if Sheriff and Murderer then
                    sendMessage(Sheriff .. " is the Sheriff and " .. Murderer .. " is the Murderer.")
                elseif Sheriff then
                    sendMessage(Sheriff .. " is the Sheriff, but there is no Murderer.")
                elseif Murderer then
                    sendMessage(Murderer .. " is the Murderer.")
                end
            end
        end

        checkRoles()
    end)

CombateSection:NewButton("Throw Knife", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("Throw")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "Throw"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Throw"
button.Size = UDim2.new(0, 60, 0, 60)
button.Position = UDim2.new(1, -70, 0, 50)
button.Text = "OFF"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Rojo cuando está "OFF"
button.BackgroundTransparency = 0.6
button.BorderSizePixel = 2
button.BorderColor3 = Color3.fromRGB(0, 0, 0)
button.Draggable = true
button.TextScaled = true
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local player = game.Players.LocalPlayer
local camera = game.Workspace.CurrentCamera
local flingActive = false

local function isPlayerVisible(target)
    local targetPosition = target.Character.HumanoidRootPart.Position
    local screenPoint = camera:WorldToScreenPoint(targetPosition)
    return screenPoint.Z > 0 and screenPoint.Y > 0 and screenPoint.Y < camera.ViewportSize.Y and screenPoint.X > 0 and screenPoint.X < camera.ViewportSize.X
end

local function getClosestVisibleEnemy()
    local closestEnemy = nil
    local closestDistance = math.huge

    for _, enemy in ipairs(game.Players:GetPlayers()) do
        if enemy ~= player and enemy.Character and enemy.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - enemy.Character.HumanoidRootPart.Position).Magnitude
            if distance < closestDistance and isPlayerVisible(enemy) then
                closestDistance = distance
                closestEnemy = enemy
            end
        end
    end

    return closestEnemy
end

local function flingKnifeAt(target)
    if not target or not player.Character or not player.Character:FindFirstChild("Knife") then return end

    local playerPosition = player.Character.HumanoidRootPart.Position
    local targetPosition = target.Character.HumanoidRootPart.Position
    
    -- Dirección desde el jugador local hacia el enemigo
    local direction = (targetPosition - playerPosition).Unit

    -- Argumentos para el lanzamiento del cuchillo
    local knifeArgs = {
        [1] = CFrame.new(playerPosition, playerPosition + direction),  -- CFrame desde la posición del jugador local hacia la dirección del enemigo
        [2] = playerPosition + direction * 50  -- Ajuste de la dirección del cuchillo, alejado del jugador local y sin colisionar con el objetivo
    }

    local throw = player.Character.Knife:FindFirstChild("Throw")
    if throw then
        throw:FireServer(unpack(knifeArgs))
    end
end

local function toggleFling()
    flingActive = not flingActive
    if flingActive then
        button.Text = "ON"
        button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        while flingActive do
            local target = getClosestVisibleEnemy()
            if target then
                flingKnifeAt(target)
            end
            wait(1.5)
        end
    else
        button.Text = "OFF"
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    end
end

button.MouseButton1Click:Connect(toggleFling)

player.CharacterAdded:Connect(function()
    if flingActive then
        toggleFling()
    end
end)
end)

LocalPlayerSection:NewButton("second life", "ButtonInfo", function()
local accessories = {}

function GodMode()
    local player = game.Players.LocalPlayer
    local char = player.Character or player.CharacterAdded:Wait()

    if char and char:FindFirstChild("Humanoid") then
        for _, accessory in pairs(char.Humanoid:GetAccessories()) do
            table.insert(accessories, accessory:Clone())
        end

        local humanoid = char:FindFirstChild("Humanoid")
        humanoid.Name = "TempHumanoid"

        local newHumanoid = humanoid:Clone()
        newHumanoid.Parent = char
        newHumanoid.Name = "Humanoid"

        newHumanoid.WalkSpeed = 18.5
        newHumanoid.JumpPower = 53
        newHumanoid.Health = math.huge
        newHumanoid.MaxHealth = math.huge

        wait(0.1)
        humanoid:Destroy()

        workspace.CurrentCamera.CameraSubject = newHumanoid

        for _, accessory in pairs(char:GetChildren()) do
            if accessory:IsA("Accessory") then
                accessory:Destroy()
            end
        end

        for _, accessory in pairs(accessories) do
            newHumanoid:AddAccessory(accessory)
        end

        accessories = {}

        local animateScript = char:FindFirstChild("Animate")
        if animateScript then
            animateScript.Disabled = true
            wait(0.1)
            animateScript.Disabled = false
        end

        newHumanoid.Died:Connect(function()
            wait(0.1)
            newHumanoid.Health = 100
        end)
    end
end

GodMode()
    end)

LocalPlayerSection:NewToggle("auto second life v1", "ToggleInfo", function(state)
        savedConfig.Se = toggleState
        saveConfig(savedConfig)

        local player = game.Players.LocalPlayer
        local StarterGui = game:GetService("StarterGui")
        local secondLifeActivated, notificationShown = false, false
        local mapConnection, characterConnection

        local function activateSecondLife()
            if not toggleState or secondLifeActivated then return end
            secondLifeActivated = true
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.Name = "1"
                local clonedHumanoid = humanoid:Clone()
                clonedHumanoid.Parent = player.Character
                clonedHumanoid.Name = "Humanoid"
                wait(0.1)
                humanoid:Destroy()
                workspace.CurrentCamera.CameraSubject = clonedHumanoid
                player.Character.Animate.Disabled = true
                wait(0.1)
                player.Character.Animate.Disabled = false
            end
        end

        local function checkNewMap()
            if toggleState and not notificationShown then
                StarterGui:SetCore("SendNotification", {
                    Title = "Second Life",
                    Text = "New map detected. Second Life will be activated soon.",
                    Duration = 3
                })
                notificationShown = true
                wait(15)
                if toggleState and not secondLifeActivated then
                    activateSecondLife()
                end
            end
        end

        local function resetSecondLife()
            secondLifeActivated, notificationShown = false, false
        end

        local function disconnectConnections()
            if mapConnection then 
                mapConnection:Disconnect() 
                mapConnection = nil 
            end
            if characterConnection then 
                characterConnection:Disconnect() 
                characterConnection = nil 
            end
        end

        if toggleState then
            resetSecondLife()
            disconnectConnections()

            mapConnection = workspace.DescendantAdded:Connect(function(descendant)
                if toggleState and (descendant.Name == "Spawn" or descendant.Name == "PlayerSpawn") then
                    checkNewMap()
                end
            end)

            characterConnection = player.CharacterAdded:Connect(function()
                if toggleState then
                    resetSecondLife()
                end
            end)
        else
            disconnectConnections()
            resetSecondLife()
        end
    end)

VisualSection:NewButton("Fps Booster", "ButtonInfo", function()
loadstring(game:HttpGet(("https://raw.githubusercontent.com/Jorgelinea/Fps/refs/heads/main/Protected_3128182632327016.txt"),true))()
    end)

VisualSection:NewButton("fake death", "ButtonInfo", function()
local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local humanoid = character:FindFirstChildOfClass("Humanoid")
if humanoid then
    humanoid.Sit = true
end

humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position) * CFrame.Angles(math.rad(-90), 0, 0)
    end)

local lp = game.Players.LocalPlayer
local knifeanim
local fakeGunActive = false

VisualSection:NewToggle("Fake Knife", "ToggleInfo", function(state)
        savedConfig.Fake = state 
        saveConfig(savedConfig)
        if state then
            if lp.Backpack:FindFirstChild("Knife") then return end
            
            local tool = Instance.new("Tool")
            tool.Name = "Knife"
            tool.Grip = CFrame.new(0, -1.17, 0.07, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            tool.GripForward = Vector3.new(0, 0, -1)
            tool.GripPos = Vector3.new(0, -1.17, 0.07)
            tool.GripRight = Vector3.new(1, 0, 0)
            tool.GripUp = Vector3.new(0, 1, 0)

            local handle = Instance.new("Part")
            handle.Size = Vector3.new(1, 3.42, 1.09)
            handle.Name = "Handle"
            handle.Transparency = 1
            handle.Parent = tool

            tool.Parent = lp.Backpack

            local animation1 = Instance.new("Animation")
            animation1.AnimationId = "rbxassetid://2467567750"
            local animation2 = Instance.new("Animation")
            animation2.AnimationId = "rbxassetid://1957890538"
            local anims = {animation1, animation2}

            lp:GetMouse().Button1Down:Connect(function()
                if tool.Parent == lp.Character then
                    local anim = lp.Character.Humanoid:LoadAnimation(anims[math.random(1, 2)])
                    anim:Play()
                end
            end)

            local knife = lp.Character:WaitForChild("KnifeDisplay")
            knife.Massless = true
            local aa = Instance.new("Attachment", handle)
            local ba = Instance.new("Attachment", knife)
            local hinge = Instance.new("HingeConstraint", knife)
            hinge.Attachment0 = aa
            hinge.Attachment1 = ba
            hinge.LimitsEnabled = true
            hinge.LowerAngle = 0
            hinge.Restitution = 0
            hinge.UpperAngle = 0

            for _, v in pairs(lp.Character:WaitForChild("UpperTorso"):GetChildren()) do
                if v:IsA("Weld") and v.Part1 == knife then
                    v:Destroy()
                    break
                end
            end

            knifeanim = game:GetService("RunService").Heartbeat:Connect(function()
                if tool.Parent == lp.Character then
                    knife.CFrame = handle.CFrame
                elseif lp.Character and knife then
                    knife.CFrame = lp.Character:WaitForChild("UpperTorso").CFrame * CFrame.new(-0.2, -0.4, 0.5)
                end
            end)

            local function animateAndWait()
                while tool.Parent == lp.Character do
                    local anim = lp.Character.Humanoid:LoadAnimation(anims[math.random(1, 2)])
                    anim:Play()
                    wait(1)
                end
            end

            spawn(animateAndWait)
        else
            if knifeanim then
                knifeanim:Disconnect()
            end
            if lp.Character:FindFirstChild("Knife") then
                lp.Character.Knife:Destroy()
            end
            if lp.Backpack:FindFirstChild("Knife") then
                lp.Backpack.Knife:Destroy()
            end
        end
    end)

TeleportSection:NewButton("Go to the Lobby", "ButtonInfo", function()
local player = game.Players.LocalPlayer
local spawns = workspace:WaitForChild("Lobby"):WaitForChild("Spawns"):GetChildren()

if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and #spawns > 0 then
    local randomSpawn = spawns[math.random(1, #spawns)]
    
    player.Character.HumanoidRootPart.CFrame = randomSpawn.CFrame + Vector3.new(0, 3, 0)
end
end)

TeleportSection:NewButton("Vote Map", "ButtonInfo", function()
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-104, 154, -18)
end)

TeleportSection:NewButton("Go to Map", "ButtonInfo", function()
for i,v in pairs (workspace:GetDescendants()) do
        if v.Name == "Spawn" then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(v.Position) * CFrame.new(0,2.5,0)
        elseif v.Name == "PlayerSpawn" then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(v.Position) * CFrame.new(0,2.5,0)
        end
    end
end)

TeleportSection:NewButton("void (Safe)", "ButtonInfo", function()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local teleportPosition = CFrame.new(-74, 6, 693)


local function blockExists(position, size)
    for _, obj in ipairs(workspace:GetChildren()) do
        if obj:IsA("Part") and obj.Position == position and obj.Size == size then
            return true
        end
    end
    return false
end

local blockSize = Vector3.new(60, 2, 60)

if not blockExists(teleportPosition.Position, blockSize) then
    local wideBlock = Instance.new("Part")
    wideBlock.Size = blockSize
    wideBlock.Position = teleportPosition.Position
    wideBlock.Anchored = true
    wideBlock.CanCollide = true
    wideBlock.Transparency = 0.5
    wideBlock.Parent = workspace
end

hrp.CFrame = teleportPosition * CFrame.new(0, 3, 0)
    end)
 
EmoteSection:NewButton("Get all the emotes", "ButtonInfo", function()
        local PlayerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
        local Emotes = PlayerGui:WaitForChild("MainGUI"):WaitForChild("Game"):FindFirstChild("Emotes")

        if Emotes then
            local success = pcall(function()
                require(game:GetService("ReplicatedStorage").Modules.EmoteModule).GeneratePage(
                    {"headless", "zombie", "zen", "ninja", "floss", "dab", "sit"},
                    Emotes,
                    "Free Emotes"
                )
            end)

            if success then
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Success",
                    Text = "Emotes obtained",
                    Duration = 3
                })
            end
        end
    end)
    
local anim = Instance.new('Animation')

EmoteSection:NewButton("Ninja", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2431864798"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)

EmoteSection:NewButton("Dab", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2445521505"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)

EmoteSection:NewButton("Floss", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2452938820"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)

EmoteSection:NewButton("Headless", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2513694073"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)

EmoteSection:NewButton("Zen", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2431812646"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)

EmoteSection:NewButton("Zombie", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2513692312"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)

EmoteSection:NewButton("Sit", "ButtonInfo", function()
        anim.AnimationId = "rbxassetid://2431845940"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end)
    
    SettingsAutofarm = {}
if _G.AutofarmSettings then
    SettingsAutofarm = _G.AutofarmSettings
else
    _G.AutofarmSettings = {}
    SettingsAutofarm = {AntiAfk = true, DelayFarm = 3}
end

if _G.AutoFarmMM2IsLoaded then return end
_G.AutoFarmMM2IsLoaded = true

Player = game.Players.LocalPlayer
Players = game.Players
RunService = game:GetService("RunService")
CoinCollectedEvent = game.ReplicatedStorage.Remotes.Gameplay.CoinCollected
RoundStartEvent = game.ReplicatedStorage.Remotes.Gameplay.RoundStart
RoundEndEvent = game.ReplicatedStorage.Remotes.Gameplay.RoundEndFade

AutofarmStarted = false
CurrentCoinType = "Candy"
AutofarmDelay = 3
ResetWhenFullBag = false 
AutofarmIN = false

bringpose = CFrame.new(math.random(-5, 5), -100, math.random(-5, 5))
safepart = Instance.new("Part")
safepart.Anchored = true
safepart.Massless = true
safepart.Transparency = 1
safepart.Size = Vector3.new(2048, 0.5, 2048)
safepart.CFrame = bringpose * CFrame.new(0, -0.9, 0)
safepart.Parent = workspace

function returncoincontaier()
    for _, v in workspace:GetChildren() do
        if v:FindFirstChild("CoinContainer") and v:IsA("Model") then
            return v:FindFirstChild("CoinContainer")
        end
    end
    return false
end

CoinCollectedEvent.OnClientEvent:Connect(function(cointype, current, max)
    AutofarmIN = true
    if cointype == CurrentCoinType and tonumber(current) == tonumber(max) then
        AutofarmIN = false
        if ResetWhenFullBag then
            if Player.Character and Player.Character:FindFirstChild("Humanoid") then
                Player.Character.Humanoid.Health = 0
            else
                Player:LoadCharacter()
            end
        end
    end
end)

function PcallTP(Position)
    if Player.Character then
        if Player.Character:FindFirstChild("HumanoidRootPart") then
            Player.Character.HumanoidRootPart.CFrame = Position
        end
    end
end

spawn(function()
    while true do
        if AutofarmStarted and AutofarmIN and Player.Character and returncoincontaier() then
            PcallTP(bringpose)
            for _, v in pairs(returncoincontaier():GetChildren()) do
                if v:GetAttribute("CoinID") == CurrentCoinType and v:FindFirstChild("TouchInterest") then
                    for i = 1, 7 do
                        PcallTP(v.CFrame)
                        task.wait(0.03)
                    end
                    break
                end
            end
            PcallTP(bringpose)
        end
        task.wait(AutofarmDelay)
    end
end)

RoundStartEvent.OnClientEvent:Connect(function()
    if AutofarmStarted then Player.Character.HumanoidRootPart.CFrame = bringpose end
    AutofarmIN = true
end)

RoundEndEvent.OnClientEvent:Connect(function()
    AutofarmIN = false
end)

for Configname, Configvalue in pairs(SettingsAutofarm) do
    if Configname == "DelayFarm" and tonumber(Configvalue) and tonumber(Configvalue) < 8 then
        AutofarmDelay = tonumber(Configvalue)
    elseif Configname == "StartAutofarm" and Configvalue == true then
        AutofarmStarted = true
    end
end

AutoFarmSection:NewToggle("Autofarm tp", "ToggleInfo", function(state)
        savedConfig.Autofarmn = state
        saveConfig(savedConfig)
        AutofarmStarted = state
    end)

AutoFarmSection:NewToggle("Reset when bag is full", "ToggleInfo", function(state)
        savedConfig.ResetWhenFullBag = state
        saveConfig(savedConfig)
        ResetWhenFullBag = state
    end)

local old
local isAntiKickEnabled = false

old = hookmetamethod(game, "__namecall", function(self, ...)
    local method = tostring(getnamecallmethod())
    
    if string.lower(method) == "kick" and isAntiKickEnabled then
        return wait(9e9)
    end
    
    return old(self, ...)
end)

local old
local isAntiKickEnabled = false

old = hookmetamethod(game, "__namecall", function(self, ...)
    local method = tostring(getnamecallmethod())
    
    if string.lower(method) == "kick" and isAntiKickEnabled then
        return wait(9e9)
    end
    
    return old(self, ...)
end)

AutoFarmSection:NewToggle("Anti Kick", "ToggleInfo", function(state)
        savedConfig.antikick = state
        saveConfig(savedConfig)

        isAntiKickEnabled = state
        if isAntiKickEnabled then
            print("Anti Kick Activado")
        else
            print("Anti Kick Desactivado")
        end
    end)

local D3RenderingDisabled = false

AutoFarmSection:NewToggle("Disable 3D rendering", "ToggleInfo", function(state)
        savedConfig.renderizado = state
        saveConfig(savedConfig)

        if not D3RenderingDisabled and state then
            D3RenderingDisabled = true
            RunService:Set3dRenderingEnabled(false)
        elseif D3RenderingDisabled and not state then
            D3RenderingDisabled = false
            RunService:Set3dRenderingEnabled(true)
        end
    end)

AutoFarmSection:NewToggle("Coin Optimization (is ass)", "ToggleInfo", function(state)
        savedConfig.Optimization = state
        saveConfig(savedConfig)
        local connections = {}
        
        local function onTouch(coin, hit)
            local player = game.Players:GetPlayerFromCharacter(hit.Parent)
            if player then
                coin.Transparency = 1
                coin.CanCollide = false
                wait(2)
                coin:Destroy()
            end
        end

        local function setupCoin(coin)
            if coin:IsA("Part") then
                local connection = coin.Touched:Connect(function(hit)
                    onTouch(coin, hit)
                end)
                table.insert(connections, connection)
            end
        end

        local function updateCoinContainer()
            local coinContainer = workspace:FindFirstChild("Normal") and workspace.Normal:FindFirstChild("CoinContainer")
            if coinContainer then
                for _, coin in ipairs(coinContainer:GetChildren()) do
                    if coin.Name == "CoinVisual" or coin.Name == "Coin_Server" then
                        setupCoin(coin)
                    end
                end
            end
        end

        while state do
            updateCoinContainer()
            
            local coinContainer = workspace:FindFirstChild("Normal") and workspace.Normal:FindFirstChild("CoinContainer")
            if coinContainer then
                local connection = coinContainer.ChildAdded:Connect(function(newCoin)
                    if newCoin.Name == "CoinVisual" or newCoin.Name == "Coin_Server" then
                        setupCoin(newCoin)
                    end
                end)
                table.insert(connections, connection)
            end
            
            wait(1)
        end

        if not state then
            for _, connection in ipairs(connections) do
                connection:Disconnect()
            end
            connections = {}
        end
    end)
    
local autoXPEnabled = false
local teletransportLoop
local player = game.Players.LocalPlayer

AutoFarmSection:NewToggle("Auto XP", "ToggleInfo", function(state)
        savedConfig.Autoxp = state 
        saveConfig(savedConfig)
        autoXPEnabled = state

        local function startTeletransportLoop()
            teletransportLoop = coroutine.create(function()
                while autoXPEnabled do
                    local character = player.Character
                    if character and character:FindFirstChild("HumanoidRootPart") then
                        for _, v in pairs(workspace:GetDescendants()) do
                            if v.Name == "Spawn" or v.Name == "PlayerSpawn" then
                                print("Mapa detectado: " .. v.Name .. " encontrado")
                                character.HumanoidRootPart.CFrame = CFrame.new(-104, 154, -18)
                                break
                            end
                        end
                    end
                    wait(0.5)
                end
            end)
            coroutine.resume(teletransportLoop)
        end

        player.CharacterAdded:Connect(function(character)
            if autoXPEnabled then
                wait()
                startTeletransportLoop()
            end
        end)

        if autoXPEnabled then
            startTeletransportLoop()
        else
            autoXPEnabled = false
        end
    end)

CombateSection:NewButton("Tp And Shoot {Beta}", "ButtonInfo", function()
local screenGui = Instance.new("ScreenGui")
local shootButton = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

screenGui.Name = "ShootMurdererGui"
screenGui.Parent = game:GetService("CoreGui")

shootButton.Name = "tpDispararButton"
shootButton.Size = UDim2.new(0, 100, 0, 100)
shootButton.Position = UDim2.new(0, 10, 0, 50)
shootButton.Text = "TP Shoot"
shootButton.Font = Enum.Font.Gotham
shootButton.TextSize = 14
shootButton.TextColor3 = Color3.fromRGB(255, 255, 255)
shootButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
shootButton.BackgroundTransparency = 0.6
shootButton.Draggable = true
shootButton.BorderSizePixel = 0
shootButton.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = shootButton

local localplayer = game.Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local function getTorsoPosition(character)
    local torso = character:FindFirstChild("HumanoidRootPart")
    return torso and torso.Position or nil
end

local function predictPosition(murderer)
    local humanoidRootPart = murderer:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        local murdererPosition = humanoidRootPart.Position
        local murdererVelocity = humanoidRootPart.Velocity
        local distanceToPlayer = (murdererPosition - localplayer.Character.HumanoidRootPart.Position).Magnitude

        local predictionTime = math.clamp(distanceToPlayer / 50, 0, 0.1)
        local predictedPosition = murdererPosition + murdererVelocity * predictionTime

        return Vector3.new(predictedPosition.X, murdererPosition.Y, predictedPosition.Z)
    end
    return nil
end

local function shootAtMurderer(predictedPosition)
    local gun = localplayer.Character:FindFirstChild("Gun")
    if gun then
        local args = {
            [1] = 1,
            [2] = predictedPosition,
            [3] = "AH2"
        }
        gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
    end
end

local function getMurderer()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    if roles then
        for playerName, roleInfo in pairs(roles) do
            if roleInfo.Role == "Murderer" then
                local murdererPlayer = game.Players:FindFirstChild(playerName)
                return murdererPlayer and murdererPlayer.Character
            end
        end
    end
    return nil
end

shootButton.MouseButton1Click:Connect(function()
    local gun = localplayer.Character:FindFirstChild("Gun")
    if not gun then return end

    local originalPosition = localplayer.Character.HumanoidRootPart.Position
    local murderer = getMurderer()

    if murderer then
        local predictedPosition = predictPosition(murderer)
        
        if predictedPosition then
            local function updatePositionBehindMurderer()
                if murderer and murderer:FindFirstChild("HumanoidRootPart") then
                    local murdererPosition = murderer.HumanoidRootPart.Position
                    local behindPosition = murdererPosition - murderer.HumanoidRootPart.CFrame.LookVector * 4
                    localplayer.Character.HumanoidRootPart.CFrame = CFrame.new(behindPosition)
                end
            end

            local followConnection
            followConnection = RunService.RenderStepped:Connect(function()
                updatePositionBehindMurderer()
            end)

            wait(0.1)
            shootAtMurderer(predictedPosition)

            followConnection:Disconnect()
            localplayer.Character.HumanoidRootPart.CFrame = CFrame.new(originalPosition)
        end
    end
end)
    end)
    
local player = game.Players.LocalPlayer
local knifeDetected = false
local knifeHitbox = nil

local function createKnifeHitbox(knifeTool)
    if knifeHitbox then
        knifeHitbox:Destroy()
    end

    knifeHitbox = Instance.new("Part")
    knifeHitbox.Name = "KnifeHitbox"
    knifeHitbox.Size = Vector3.new(getgenv().range, getgenv().range, getgenv().range)
    knifeHitbox.CanCollide = false
    knifeHitbox.Massless = true
    knifeHitbox.Transparency = 0.8
    knifeHitbox.Anchored = false
    knifeHitbox.Parent = knifeTool

    local handle = knifeTool:FindFirstChild("Handle")
    if handle then
        knifeHitbox.CFrame = handle.CFrame

        local weld = Instance.new("WeldConstraint")
        weld.Part0 = handle
        weld.Part1 = knifeHitbox
        weld.Parent = handle
    end
end

local function checkKnife()
    local knifeTool = player.Backpack:FindFirstChild("Knife") or 
                      player.Character:FindFirstChild("Knife")

    if knifeTool then
        createKnifeHitbox(knifeTool)
        knifeDetected = true
    end
end

HitboxSection:NewToggle("Knife range", "ToggleInfo", function(state)
        savedConfig.range = state
        saveConfig(savedConfig)

        if state then
            checkKnife()
        else
            if knifeHitbox then
                knifeHitbox:Destroy()
                knifeHitbox = nil
            end
            knifeDetected = false
        end
    end)

player.CharacterAdded:Connect(function(character)
    character:WaitForChild("Humanoid").Died:Wait()
    if knifeHitbox then
        knifeHitbox:Destroy()
        knifeHitbox = nil
    end
    knifeDetected = false
end)

player.CharacterAdded:Connect(function(character)
    character:WaitForChild("Knife", 10)
    if savedConfig.range then
        checkKnife()
    end
end)

HitboxSection:NewSlider("Knife range slider", "SliderInfo", 30, 7, function(value)
        getgenv().range = value
        if knifeHitbox then
            knifeHitbox.Size = Vector3.new(getgenv().range, getgenv().range, getgenv().range)
        end
        savedConfig.range = value
        saveConfig(savedConfig)
    end)

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LP = Players.LocalPlayer

local function GetPlayerByRole(roleName)
    local rolesFunction = ReplicatedStorage:FindFirstChild("GetPlayerData", true)
    if not rolesFunction then return nil end

    local success, roles = pcall(function()
        return rolesFunction:InvokeServer()
    end)

    if not success or not roles then return nil end

    for playerName, data in pairs(roles) do
        if data.Role == roleName then
            return Players:FindFirstChild(playerName)
        end
    end
    return nil
end

local function TeleportToRole(roleName)
    local character = LP.Character or LP.CharacterAdded:Wait()
    if not character or not character.PrimaryPart then return end

    local targetPlayer = GetPlayerByRole(roleName)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local targetPart = targetPlayer.Character.HumanoidRootPart
        pcall(function()
            character:SetPrimaryPartCFrame(targetPart.CFrame)
        end)
    end
end

TeleportSection:NewButton("Tp Sheriff", "ButtonInfo", function()
        TeleportToRole("Sheriff")
    end)

TeleportSection:NewButton("Tp Murderer", "ButtonInfo", function()
        TeleportToRole("Murderer")
    end)

TeleportSection:NewButton("Tp Hero", "ButtonInfo", function()
        TeleportToRole("Hero")
    end)

VisualSection:NewButton("See Murderer", "ButtonInfo", function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LP = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local function GetMurderer()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for i, v in pairs(roles) do
        if v.Role == "Murderer" then
            return i
        end
    end
    return nil
end

local function SwitchToRoleCamera(roleName)
    local rolePlayer = Players:FindFirstChild(GetMurderer())
    if rolePlayer and rolePlayer.Character and rolePlayer.Character:FindFirstChild("HumanoidRootPart") then
        Camera.CameraSubject = rolePlayer.Character.Humanoid
        Camera.CFrame = rolePlayer.Character.HumanoidRootPart.CFrame
        wait(5)  
        Camera.CameraSubject = LP.Character.Humanoid
        Camera.CFrame = LP.Character.HumanoidRootPart.CFrame
    end
end

SwitchToRoleCamera("Murderer")
end)

VisualSection:NewButton("See Sheriff", "ButtonInfo", function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LP = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local function GetSheriff()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for i, v in pairs(roles) do
        if v.Role == "Sheriff" then
            return i
        end
    end
    return nil
end

local function SwitchToRoleCamera(roleName)
    local rolePlayer = Players:FindFirstChild(GetSheriff())
    if rolePlayer and rolePlayer.Character and rolePlayer.Character:FindFirstChild("HumanoidRootPart") then
        Camera.CameraSubject = rolePlayer.Character.Humanoid
        Camera.CFrame = rolePlayer.Character.HumanoidRootPart.CFrame
        wait(5)  
        Camera.CameraSubject = LP.Character.Humanoid
        Camera.CFrame = LP.Character.HumanoidRootPart.CFrame
    end
end

SwitchToRoleCamera("Sheriff")
    end)

VisualSection:NewButton("See Hero", "ButtonInfo", function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LP = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local function GetHero()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for i, v in pairs(roles) do
        if v.Role == "Hero" then
            return i
        end
    end
    return nil
end

local function SwitchToRoleCamera(roleName)
    local rolePlayer = Players:FindFirstChild(GetHero())
    if rolePlayer and rolePlayer.Character and rolePlayer.Character:FindFirstChild("HumanoidRootPart") then
        Camera.CameraSubject = rolePlayer.Character.Humanoid
        Camera.CFrame = rolePlayer.Character.HumanoidRootPart.CFrame
        wait(5)  
        Camera.CameraSubject = LP.Character.Humanoid
        Camera.CFrame = LP.Character.HumanoidRootPart.CFrame
    end
end

SwitchToRoleCamera("Hero")
    end)
    
VisualSection:NewButton("Fe emote", "ButtonInfo", function()
loadstring(game:HttpGet("https://pastebin.com/raw/eCpipCTH"))()
end)

MICSection:NewButton("ReJoin", "ButtonInfo", function()
        local TeleportService = game:GetService("TeleportService")
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer

        local Rejoin = coroutine.create(function()
            local Success, ErrorMessage = pcall(function()
                TeleportService:Teleport(game.PlaceId, LocalPlayer)
            end)

            if not Success then
                warn(ErrorMessage)
            end
        end)
        coroutine.resume(Rejoin)
    end)
 
local defaultGravity = 190
local increasedGravity = 400
local isGravityActive = false
local speedConnection
local jumpConnection

game.Workspace.Gravity = defaultGravity

LocalPlayerSection:NewSlider("Gravity", 0, 1000, defaultGravity, function(value)
    game.Workspace.Gravity = value
end)

LocalPlayerSection:NewToggle("Gravity loop", "ToggleInfo", function(state)
        isGravityActive = state
        game.Workspace.Gravity = state and increasedGravity or defaultGravity
    end)

local function updateWalkSpeed(value)
    local player = game:GetService("Players").LocalPlayer
    if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
        player.Character.Humanoid.WalkSpeed = value
    end
end

LocalPlayerSection:NewSlider("Speed", 18, 30, savedConfig.Walkspeed or 18, function(value)
    getgenv().Walkspeed = value
    updateWalkSpeed(value)
    savedConfig.Walkspeed = value
    saveConfig(savedConfig)
end)

LocalPlayerSection:NewToggle("Loop speed", "ToggleInfo", function(state)
        getgenv().loopW = state
        savedConfig.loopW = state
        saveConfig(savedConfig)
        
        if state then
            if not speedConnection then
                speedConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    if getgenv().loopW then
                        updateWalkSpeed(getgenv().Walkspeed)
                    end
                end)
            end
        elseif speedConnection then
            speedConnection:Disconnect()
            speedConnection = nil
        end
    end)

local function updateJumpPower(value)
    local player = game:GetService("Players").LocalPlayer
    if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
        player.Character.Humanoid.JumpPower = value
    end
end

LocalPlayerSection:NewSlider("Power Jump", 53, 200, savedConfig.Jumppower or 53, function(value)
    getgenv().Jumppower = value
    updateJumpPower(value)
    savedConfig.Jumppower = value
    saveConfig(savedConfig)
end)

LocalPlayerSection:NewToggle("Power Jump/Loop", "ToggleInfo", function(state)
        getgenv().loopJ = state
        savedConfig.loopJ = state
        saveConfig(savedConfig)

        if state then
            if not jumpConnection then
                jumpConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    if getgenv().loopJ then
                        updateJumpPower(getgenv().Jumppower)
                    end
                end)
            end
        elseif jumpConnection then
            jumpConnection:Disconnect()
            jumpConnection = nil
        end
    end)

LocalPlayerSection:NewToggle("Infinite Jump", "ToggleInfo", function(state)
        savedConfig.jumpi = state
        saveConfig(savedConfig)
        getgenv().InfJ = state

        game:GetService("UserInputService").JumpRequest:Connect(function()
            if getgenv().InfJ then
                local humanoid = game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:ChangeState("Jumping")
                end
            end
        end)
    end)

CoreGui:SetCore("SendNotification", {
    Title = "v10.0.0",
    Text = "I already loaded the script completely",
    Duration = 8,
    Button1 = "OK"
})

CoreGui:SetCore("SendNotification", {
    Title = "",
    Text = "did you know this script was made by one dev?",
    Duration = 8,
})

print("Script loaded successfully.")
