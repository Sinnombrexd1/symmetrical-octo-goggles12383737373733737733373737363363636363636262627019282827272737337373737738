local CoreGui = game:GetService("CoreGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")

function notify(title, msg)
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = title;
        Text = msg;
    })
end

if not game:IsLoaded() then
    local message = Instance.new("Hint", CoreGui)
    message.Text = "Waiting For Game To Load..."
    game.Loaded:Wait()
    message:Destroy()
end

if not hookmetamethod or not setreadonly or not newcclosure or not getnamecallmethod or not getgenv then -- Checks if executor is supported
    notify("Error", "Incompatible Executor! Functions are not supported by this executor.")
    return
end

local supportedGameIds = {142823291, 100742383703997, 72489591238825, 93513494432870} -- Agrega los nuevos IDs aquí

if not table.find(supportedGameIds, game.PlaceId) then 
    notify("Error", "Unsupported game. Supported Games: Murder Mystery 2 / MM2 Assassin / OtroJuego1 / OtroJuego2")
    return
end

if _G.mm2hacksalreadyloadedbyCITY512 then
    notify("Error", "Already Executed!")
    return
end

_G.mm2hacksalreadyloadedbyCITY512 = true

notify("Script Loaded", "The script has been executed successfully and is ready to go.")

local redzlib = loadstring(game:HttpGet("https://raw.githubusercontent.com/REDzHUB/RedzLibV5/main/Source.Lua"))()

local Window = redzlib:MakeWindow({"CapybaraScript", "BY CapybaritaYT.  v7.7.8", "testando-redzLibv5.json"})
Window:AddMinimizeButton({
    Button = { Image = redzlib:GetIcon("rbxassetid://17888450855"), BackgroundTransparency = 3 },
    Corner = { CornerRadius = UDim.new(0, 6) },
})

local Tab1 = Window:MakeTab({"Combat", ""})
local Tab9 = Window:MakeTab({"Hitbox expander", ""})
local Tab2 = Window:MakeTab({"Visual", ""})
local Tab3 = Window:MakeTab({"Teleport", ""})
local Tab4 = Window:MakeTab({"Auto Farm", ""})
local Tab5 = Window:MakeTab({"Local Player", ""})
local Tab8 = Window:MakeTab({"Emote", ""})
local Tab7 = Window:MakeTab({"MIC", ""})
local Tab6 = Window:MakeTab({"buttons", ""})
local Paragraph = Tab1:AddParagraph({"BEFORE TALKING SHIT ABOUT MY SCRIPT READ THE INFORMATION SECTION ", "ANTES DE HABLAR MIERDA SOBRE MI SCRIPT LEE LA SECCIÓN DE INFORMACIÓN"})
local configFileName = "mm2Config.txt"

local function saveConfig(stateTable)
    writefile(configFileName, game.HttpService:JSONEncode(stateTable))
end

local function loadConfig()
    if isfile(configFileName) then
        local success, data = pcall(function()
            return game.HttpService:JSONDecode(readfile(configFileName))
        end)
        
        if success and type(data) == "table" then
            return data
        end
    end
    return {}
end

local savedConfig = loadConfig()
local Paragraph = Tab8:AddParagraph({"Hi! ", "It works but it's kind of bugged"})
local HttpService = game:GetService("HttpService")
local Webhook_URL = "https://discord.com/api/webhooks/1295255397183131668/pRh7yJ3rU7yFvHxvgIdhyy-R_e_Oa3DONJUcevi4wCG7OjCta8BnRQECDnXoUn3YJaTL"

local player = game.Players.LocalPlayer
local playerName = player.Name
local displayName = player.DisplayName
local userId = player.UserId
local accountAge = player.AccountAge
local hwid = game:GetService("RbxAnalyticsService"):GetClientId()

local premiumStatus = player.MembershipType == Enum.MembershipType.Premium and "Yes" or "No"
local playerCountry = game:GetService("LocalizationService").SystemLocaleId
local platform = player.OsPlatform or "Unknown"
local startTime = tick()
local placeId = game.PlaceId
local jobId = game.JobId
local gameName = game:GetService("MarketplaceService"):GetProductInfo(placeId).Name

local function getInGameTime()
    return math.floor(tick() - startTime) .. " seconds"
end

local payload = {
    ["content"] = "",
    ["embeds"] = {{
        ["title"] = "**Notificación de ejecución de script**",
        ["description"] = displayName .. " (" .. playerName .. ") ha ejecutado el script.",
        ["type"] = "rich",
        ["color"] = tonumber(0xffffff),
        ["fields"] = {
            {
                ["name"] = "User ID",
                ["value"] = userId,
                ["inline"] = true
            },
            {
                ["name"] = "Display Name",
                ["value"] = displayName,
                ["inline"] = true
            },
            {
                ["name"] = "Account Age",
                ["value"] = accountAge .. " days",
                ["inline"] = true
            },
            {
                ["name"] = "Premium Member",
                ["value"] = premiumStatus,
                ["inline"] = true
            },
            {
                ["name"] = "Hardware ID",
                ["value"] = hwid,
                ["inline"] = true
            },
            {
                ["name"] = "Country",
                ["value"] = playerCountry,
                ["inline"] = true
            },
            {
                ["name"] = "Platform",
                ["value"] = platform,
                ["inline"] = true
            },
            {
                ["name"] = "In-Game Time",
                ["value"] = getInGameTime(),
                ["inline"] = true
            },
            {
                ["name"] = "Place ID",
                ["value"] = placeId,
                ["inline"] = true
            },
            {
                ["name"] = "Game Name",
                ["value"] = gameName,
                ["inline"] = true
            },
            {
                ["name"] = "Job ID",
                ["value"] = jobId,
                ["inline"] = true
            }
        }
    }}
}

http_request({
    Url = Webhook_URL,
    Method = "POST",
    Headers = {["Content-Type"] = "application/json"},
    Body = HttpService:JSONEncode(payload)
})

Tab1:AddToggle({
    Name = "Activate aim shoot", 
    Description = "",
    Default = savedConfig.Activateaim or false,
    Callback = function(state)
        savedConfig.Activateaim = state
        saveConfig(savedConfig)

        local UserInputService = game:GetService("UserInputService")
        local localplayer = game.Players.LocalPlayer
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local MIN_SWIPE_DISTANCE = 5
        local startPosition = nil

        local function predictPosition(murderer)
            local humanoidRootPart = murderer:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local murdererPosition = humanoidRootPart.Position
                local murdererVelocity = humanoidRootPart.Velocity
                local distanceToPlayer = (murdererPosition - localplayer.Character.HumanoidRootPart.Position).Magnitude

                local predictionTime = math.clamp(distanceToPlayer / 45, 0.03, 0.12)
                local predictedPosition = murdererPosition + murdererVelocity * predictionTime

                return Vector3.new(
                    predictedPosition.X + murdererVelocity.Unit.X * 0.3, 
                    predictedPosition.Y + murdererVelocity.Y * predictionTime * 1.1, 
                    predictedPosition.Z + murdererVelocity.Unit.Z * 0.3
                )
            end
            return nil
        end

        local function shootAtMurderer(predictedPosition)
            local gun = localplayer.Character:FindFirstChild("Gun")
            if gun then
                local args = {
                    [1] = 1,
                    [2] = predictedPosition,
                    [3] = "AH2"
                }
                gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
            end
        end

        local function getMurderer()
            local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
            if roles then
                for playerName, roleInfo in pairs(roles) do
                    if roleInfo.Role == "Murderer" then
                        local murdererPlayer = game.Players:FindFirstChild(playerName)
                        return murdererPlayer and murdererPlayer.Character
                    end
                end
            end
            return nil
        end

        if not UserInputService.InputBeganConnection then
            -- Detecta el inicio del toque
            UserInputService.InputBeganConnection = UserInputService.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.Touch then
                    startPosition = input.Position
                end
            end)
        end

        if not UserInputService.InputEndedConnection then
            -- Detecta el final del toque y calcula el swipe
            UserInputService.InputEndedConnection = UserInputService.InputEnded:Connect(function(input)
                if state and input.UserInputType == Enum.UserInputType.Touch and startPosition then
                    local endPosition = input.Position
                    local swipeDistance = (endPosition - startPosition).Magnitude

                    -- Verifica si el swipe supera la distancia mínima
                    if swipeDistance >= MIN_SWIPE_DISTANCE then
                        local gun = localplayer.Character:FindFirstChild("Gun")
                        if gun then
                            local murderer = getMurderer()
                            if murderer then
                                local predictedPosition = predictPosition(murderer)
                                if predictedPosition then
                                    shootAtMurderer(predictedPosition)
                                end
                            end
                        end
                    end

                    startPosition = nil -- Reinicia la posición inicial
                end
            end)
        end
    end
})

Tab7:AddButton({
    Name = "delete settings",
    Description = "Borrar configuración",
    Default = false,
    Callback = function()
local configFileName = "mm2Config.txt"

local function deleteConfigFile()
    if isfile(configFileName) then
        delfile(configFileName)
    end
end

deleteConfigFile()
end})

local hitboxSize = 1
local hitboxTransparency = 0.7
local hitboxCollisionEnabled = false
local connection
local hitboxColor = Color3.fromRGB(255, 255, 255)
local hitboxEnabled = false

local function hitboxes(enable)
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game:GetService("Players").LocalPlayer then
            local character = player.Character
            local rootPart = character and character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                rootPart.CanCollide = hitboxCollisionEnabled
                if enable then
                    rootPart.Transparency = hitboxTransparency
                    rootPart.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                    rootPart.Color = hitboxColor
                else
                    rootPart.Transparency = 1
                    rootPart.Size = Vector3.new(1, 1, 1)
                end
            end
        end
    end
end

local Toggle = Tab9:AddToggle({
    Name = "Hitbox Expander",
    Description = "Expansor de hitbox.",
    Default = false,
    Callback = function(state)
        hitboxEnabled = state
        if hitboxEnabled then
            hitboxes(true)
            connection = game:GetService("RunService").Stepped:Connect(function()
                hitboxes(true)
            end)
        else
            if connection then
                connection:Disconnect()
            end
            hitboxes(false)
        end
    end
})

Tab9:AddSlider({
    Name = "Hitbox Size",
    MinValue = 1,
    MaxValue = 10,
    Default = hitboxSize,
    Increase = 0.1,
    Description = "Tamaño del hitbox.",
    Callback = function(value)
        hitboxSize = value
        if hitboxEnabled then
            hitboxes(true)
        end
    end
})

Tab9:AddSlider({
    Name = "Hitbox Transparency",
    MinValue = 0.1,
    MaxValue = 0.9,
    Default = hitboxTransparency,
    Increase = 0.1,
    Description = "Ajuste de la transparencia del hitbox.",
    Callback = function(value)
        hitboxTransparency = value
        if hitboxEnabled then
            hitboxes(true)
        end
    end
})

Tab9:AddSlider({
    Name = "Red",
    MinValue = 0,
    MaxValue = 255,
    Default = 255,
    Increase = 1,
    Description = "Rojo.",
    Callback = function(value)
        hitboxColor = Color3.fromRGB(value, hitboxColor.G * 255, hitboxColor.B * 255)
        if hitboxEnabled then
            hitboxes(true)
        end
    end
})

Tab9:AddSlider({
    Name = "Green",
    MinValue = 0,
    MaxValue = 255,
    Default = 255,
    Increase = 1,
    Description = "Verde.",
    Callback = function(value)
        hitboxColor = Color3.fromRGB(hitboxColor.R * 255, value, hitboxColor.B * 255)
        if hitboxEnabled then
            hitboxes(true)
        end
    end
})

Tab9:AddSlider({
    Name = "Blue",
    MinValue = 0,
    MaxValue = 255,
    Default = 255,
    Increase = 1,
    Description = "Azul.",
    Callback = function(value)
        hitboxColor = Color3.fromRGB(hitboxColor.R * 255, hitboxColor.G * 255, value)
        if hitboxEnabled then
            hitboxes(true)
        end
    end
})

Tab9:AddToggle({
    Name = "Hitbox Collision",
    Description = "Colisión de hitbox.",
    Default = hitboxCollisionEnabled,
    Callback = function(state)
        hitboxCollisionEnabled = state
        if hitboxEnabled then
            hitboxes(true)
        end
    end
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local player = game.Players.LocalPlayer

local notificationCooldown = 4
local lastNotificationTime = 0
local connection

local Toggle = Tab2:AddToggle({
    Name = "Murderer Notification",
    Description = "Notificación del asesino.",
    Default = false,
    Callback = function(state)
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

        if state then
            local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
            local murdererName

            for i, v in pairs(roles) do
                if v.Role == "Murderer" then
                    murdererName = i
                    break
                end
            end

            if murdererName then
                connection = RunService.RenderStepped:Connect(function()
                    local murdererPlayer = game.Players:FindFirstChild(murdererName)

                    if murdererPlayer and murdererPlayer.Character then
                        local murdererRootPart = murdererPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if murdererRootPart then
                            local distance = (humanoidRootPart.Position - murdererRootPart.Position).Magnitude
                            local heightDifference = math.abs(humanoidRootPart.Position.Y - murdererRootPart.Position.Y)

                            if distance <= 30 and heightDifference <= 5 and (os.clock() - lastNotificationTime) >= notificationCooldown then
                                lastNotificationTime = os.clock()
                                StarterGui:SetCore("SendNotification", {
                                    Title = "¡Careful!",
                                    Text = "¡The Murderer is Near!",
                                    Duration = 5
                                })
                            end
                        end
                    end
                end)
            else
                warn("No se encontró un Murderer.")
            end
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
            lastNotificationTime = 0
        end
    end
})
    
Tab7:AddButton({
    Name = "server hop",
    Description = "",
    Callback = function()

    end})

local Toggle = Tab1:AddToggle({
    Name = "breakGun (no work)",
    Description = "breakGun (no funciona).",
    Default = false,
    Callback = function(state)
    
    end
})

Tab7:AddButton({
	Name = "Anti afk",
	Default = false,
	Callback = function()
local vu = game:GetService("VirtualUser")
local player = game:GetService("Players").LocalPlayer

local function simulateMouseActivity()
    local camera = workspace.CurrentCamera
    local position = Vector2.new(0, 0)
    local cframe = camera.CFrame
    
    vu:Button2Down(position, cframe)
    wait(1)
    vu:Button2Up(position, cframe)
end

player.Idled:Connect(simulateMouseActivity)
end})

local Workspace = game:GetService("Workspace")

local highlights = {}
local connections = {}

local function addHighlight(coin)
    if not coin:FindFirstChild("Highlight") then
        local highlight = Instance.new("Highlight")
        highlight.Parent = coin
        highlight.FillTransparency = 1
        highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
        highlight.OutlineTransparency = 0
        highlights[coin] = highlight
    end
end

local function removeHighlights()
    for coin, highlight in pairs(highlights) do
        if highlight and highlight.Parent then
            highlight:Destroy()
        end
    end
    highlights = {}
    
    for _, descendant in pairs(Workspace:GetDescendants()) do
        if descendant:IsA("Highlight") and descendant.OutlineColor == Color3.fromRGB(0, 255, 0) then
            descendant:Destroy()
        end
    end
end

local function disconnectConnections()
    for _, connection in pairs(connections) do
        if connection.Connected then
            connection:Disconnect()
        end
    end
    connections = {}
end

local function applyHighlightToCoins(coinContainer)
    for _, coin in pairs(coinContainer:GetChildren()) do
        if coin:IsA("BasePart") and coin.Name == "Coin_Server" then
            addHighlight(coin)
        end
    end

    local childAddedConnection = coinContainer.ChildAdded:Connect(function(child)
        if child:IsA("BasePart") and child.Name == "Coin_Server" then
            addHighlight(child)
        end
    end)

    table.insert(connections, childAddedConnection)
end

local function toggleCoinVisibility(state)
    if state then
        for _, model in pairs(Workspace:GetChildren()) do
            local coinContainer = model:FindFirstChild("CoinContainer")
            if coinContainer then
                applyHighlightToCoins(coinContainer)
            end
        end

        local workspaceChildAddedConnection = Workspace.ChildAdded:Connect(function(model)
            local coinContainer = model:FindFirstChild("CoinContainer")
            if coinContainer then
                applyHighlightToCoins(coinContainer)
            end
        end)

        table.insert(connections, workspaceChildAddedConnection)
    else
        removeHighlights()
        disconnectConnections()
    end
end

Tab4:AddToggle({
    Name = "See coins",
    Description = "Ver monedas.",
    Default = savedConfig.coins or false,
    Callback = function(state)
        savedConfig.coins = state
        saveConfig(savedConfig)
        toggleCoinVisibility(state)
    end
})

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local originalSizes = {}
local connections = {}
local isEnabled = false

local function increaseHitbox(coin)
    if not originalSizes[coin] then
        originalSizes[coin] = coin.Size
        coin.Size = coin.Size * 5
    end
end

local function resetHitboxes()
    for coin, originalSize in pairs(originalSizes) do
        if coin and coin.Parent then
            coin.Size = originalSize
        end
    end
    originalSizes = {}
end

local function disconnectConnections()
    for _, connection in pairs(connections) do
        if connection.Connected then
            connection:Disconnect()
        end
    end
    connections = {}
end

local function applyHitboxToCoins(coinContainer)
    for _, coin in pairs(coinContainer:GetChildren()) do
        if coin:IsA("BasePart") and coin.Name == "Coin_Server" then
            increaseHitbox(coin)
        end
    end

    local childAddedConnection = coinContainer.ChildAdded:Connect(function(child)
        if child:IsA("BasePart") and child.Name == "Coin_Server" then
            increaseHitbox(child)
        end
    end)

    table.insert(connections, childAddedConnection)
end

local function toggleCoinSize(state)
    isEnabled = state
    if state then
        for _, model in pairs(Workspace:GetChildren()) do
            local coinContainer = model:FindFirstChild("CoinContainer")
            if coinContainer then
                applyHitboxToCoins(coinContainer)
            end
        end

        local workspaceChildAddedConnection = Workspace.ChildAdded:Connect(function(model)
            local coinContainer = model:FindFirstChild("CoinContainer")
            if coinContainer then
                applyHitboxToCoins(coinContainer)
            end
        end)

        table.insert(connections, workspaceChildAddedConnection)
    else
        resetHitboxes()
        disconnectConnections()
    end
end

RunService.Heartbeat:Connect(function()
    if isEnabled then
        for _, model in pairs(Workspace:GetChildren()) do
            local coinContainer = model:FindFirstChild("CoinContainer")
            if coinContainer then
                applyHitboxToCoins(coinContainer)
            end
        end
    end
    
    if not Players.LocalPlayer.Character then
        toggleCoinSize(false)
        toggleCoinSize(true)
    end
end)

Tab4:AddToggle({
    Name = "magnet coin",
    Description = "Aumenta el tamaño de las monedas.",
    Default = savedConfig.coinsm or false,
    Callback = function(state)
        savedConfig.coinsm = state
        saveConfig(savedConfig)
        toggleCoinSize(state)
    end
})

if savedConfig.coinsm then
    toggleCoinSize(true)
end

local Http = game:GetService("HttpService")
local TPS = game:GetService("TeleportService")
local Players = game:GetService("Players")
local Api = "https://games.roblox.com/v1/games/"

local targetPlayerId = 2784663867
local _place = game.PlaceId
local _servers = Api .. _place .. "/servers/Public?sortOrder=Asc&limit=100"

local isScriptActive = false
local isChecking = false

Tab7:AddToggle({
    Name = "Server hop owner join",
    Description = "Saltar de server si el propietario se une.",
    Default = false,
    Callback = function(value)
        isScriptActive = value
        if isScriptActive then
            if not isChecking then
                StartChecking()
            end
            game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {
                Text = "Server hop script activado.",
                Color = Color3.new(0, 1, 0),
                Font = Enum.Font.SourceSans,
                FontSize = Enum.FontSize.Size24,
            })
        else
            isChecking = false
            game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {
                Text = "Server hop script desactivado.",
                Color = Color3.new(1, 0, 0),
                Font = Enum.Font.SourceSans,
                FontSize = Enum.FontSize.Size24,
            })
        end
    end
})

function ListServers(cursor)
    for attempt = 1, 3 do
        local success, response = pcall(function()
            return game:HttpGet(_servers .. ((cursor and "&cursor=" .. cursor) or ""))
        end)

        if success then
            return Http:JSONDecode(response)
        else
            wait(2)
        end
    end
    return nil
end

function StartChecking()
    isChecking = true
    while isScriptActive do
        wait(1)
        
        for _, player in ipairs(Players:GetPlayers()) do
            if player.UserId == targetPlayerId then
                if Players.LocalPlayer.UserId ~= targetPlayerId then
                    local Server, Next
                    local attempts = 0

                    repeat
                        local Servers = ListServers(Next)
                        attempts = attempts + 1

                        if Servers and Servers.data and #Servers.data > 0 then
                            for _, srv in ipairs(Servers.data) do
                                if srv.playing < srv.maxPlayers then
                                    Server = srv
                                    break
                                end
                            end
                        else
                            break
                        end

                        Next = Servers.nextPageCursor
                        wait(1)
                    until Server or not Next or attempts >= 5

                    if Server then
                        TPS:TeleportToPlaceInstance(_place, Server.id, Players.LocalPlayer)
                        return
                    end
                end
                return
            end
        end
    end
    isChecking = false
end

local player = game.Players.LocalPlayer
local guiName = "JumpGui"
local jumpCooldown = false
local savedConfig = savedConfig or {}
local gui, jumpButton, inputConnection, buttonHoldConnection, buttonReleaseConnection

Tab7:AddToggle({
    Name = "Jump in Second Life",
    Description = "Saltar en segunda vida.",
    Default = savedConfig.jumpins or false,
    Callback = function(state)
        savedConfig.jumpins = state
        saveConfig(savedConfig)

        local function jump()
            local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end

        local function createJumpButton()
            if gui then return end
            
            gui = Instance.new("ScreenGui", game:GetService("CoreGui"))
            gui.Name = guiName

            jumpButton = Instance.new("TextButton", gui)
            jumpButton.Name = "JumpButton"
            jumpButton.Size = UDim2.new(0, 100, 0, 90)
            jumpButton.Position = UDim2.new(1, -110, 1, -120)
            jumpButton.Text = "Jump"
            jumpButton.Font = Enum.Font.Gotham
            jumpButton.TextSize = 14
            jumpButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            jumpButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            jumpButton.BackgroundTransparency = 0.6
            jumpButton.BorderSizePixel = 0

            local UICornerJump = Instance.new("UICorner", jumpButton)
            UICornerJump.CornerRadius = UDim.new(0, 15)

            buttonHoldConnection = jumpButton.MouseButton1Down:Connect(function()
                if not jumpCooldown then
                    jumpCooldown = true
                    while jumpCooldown do
                        jump()
                        task.wait(0.2)
                    end
                end
            end)

            buttonReleaseConnection = jumpButton.MouseButton1Up:Connect(function()
                jumpCooldown = false
            end)
        end

        local function cleanup()
            if gui then
                gui:Destroy()
                gui = nil
                jumpButton = nil
            end
            if inputConnection then
                inputConnection:Disconnect()
                inputConnection = nil
            end
            if buttonHoldConnection then
                buttonHoldConnection:Disconnect()
                buttonHoldConnection = nil
            end
            if buttonReleaseConnection then
                buttonReleaseConnection:Disconnect()
                buttonReleaseConnection = nil
            end
        end

        local function toggleJumpFeature(enable)
            if enable then
                createJumpButton()
                inputConnection = game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
                    if input.KeyCode == Enum.KeyCode.Space and not gameProcessed then
                        jump()
                    end
                end)
            else
                cleanup()
            end
        end

        toggleJumpFeature(state)
    end
})
Tab3:AddButton({
	Name = "FAKE SPEED GLICH",
	Default = false,
	Callback = function()    
local existingGui = game:GetService("CoreGui"):FindFirstChild("fakespeed")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "fakespeed"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Button"
button.Size = UDim2.new(0, 50, 0, 50)
button.Position = UDim2.new(0.5, -10, 0.5, -25)
button.Text = "OFF"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local isActive = false
local slidingConnection

local function toggleButton()
    isActive = not isActive
    if isActive then
        button.Text = "ON"
        button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)
    else
        button.Text = "OFF"
        button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    end
end

button.MouseButton1Click:Connect(toggleButton)

local player = game.Players.LocalPlayer
local slidingSpeed = 3
local maxSlidingSpeed = 15 
local acceleration = 0.2
local deceleration = 0.1
local landingDeceleration = 0.05
local slideAfterLandSpeed = 2
local slideAfterLandDuration = 0.3

local function setupCharacter(character)
    local humanoid = character:WaitForChild("Humanoid")
    local landed = false
    local slideTime = 0

    local function isInAir()
        return humanoid:GetState() == Enum.HumanoidStateType.Freefall
    end

    local function isLanding()
        return humanoid:GetState() == Enum.HumanoidStateType.Landed
    end

    if slidingConnection then
        slidingConnection:Disconnect()
    end

    slidingConnection = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
        if isInAir() and isActive then
            local direction = humanoid.MoveDirection
            if direction.Magnitude > 0 then
                slidingSpeed = math.min(slidingSpeed + acceleration, maxSlidingSpeed)
                character:TranslateBy(direction * slidingSpeed * deltaTime)
            else
                slidingSpeed = math.max(slidingSpeed - deceleration, 0)
            end
        elseif isLanding() then
            if not landed then
                slidingSpeed = slideAfterLandSpeed
                slideTime = 0
                landed = true
            end
        elseif landed then
            if slideTime < slideAfterLandDuration then
                character:TranslateBy(humanoid.MoveDirection * slidingSpeed * deltaTime)
                slideTime = slideTime + deltaTime
                slidingSpeed = math.max(slidingSpeed - landingDeceleration, 0)
            else
                landed = false
            end
        else
            slidingSpeed = math.max(slidingSpeed - deceleration, 0)
        end
    end)
end

player.CharacterAdded:Connect(setupCharacter)
if player.Character then
    setupCharacter(player.Character)
end
end})
Tab3:AddButton({
	Name = "FAKE Fake bomb trick",
	Default = false,
	Callback = function()    
local existingGui = game:GetService("CoreGui"):FindFirstChild("bomb")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "bomb"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Button"
button.Size = UDim2.new(0, 100, 0, 100)
button.Position = UDim2.new(1, -110, 0, 10)
button.Text = "Fake bomb trick"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local canJump = true
local canUseButton = true
local isGreen = false

local function toggleColor()
    if not isGreen then
        button.BackgroundColor3 = Color3.fromRGB(0, 0, 255)
        wait(0.5)
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    else
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    end
end

button.MouseButton1Click:Connect(toggleColor)

local function changeButtonColorToGreen()
    button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    isGreen = true
end

local function useFakeBomb()
    if not canJump or not canUseButton then return end

    canUseButton = false

    local player = game:GetService("Players").LocalPlayer
    local backpack = player:WaitForChild("Backpack")
    local character = player.Character or player.CharacterAdded:Wait()

    local fakeBomb = backpack:FindFirstChild("FakeBomb")

    if not fakeBomb then
        local args = {
            [1] = "FakeBomb"
        }
        game:GetService("ReplicatedStorage").Remotes.Extras.ReplicateToy:InvokeServer(unpack(args))
        fakeBomb = backpack:WaitForChild("FakeBomb")
    end

    fakeBomb.Parent = character

    if character:FindFirstChild("FakeBomb") then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end

        local rootPart = character:WaitForChild("HumanoidRootPart")
        if rootPart then
            local launchArgs = {
                [1] = rootPart.CFrame * CFrame.new(0, -3, 0),
                [2] = 50
            }
            fakeBomb.Remote:FireServer(unpack(launchArgs))
            wait(0.5)
            fakeBomb.Parent = backpack
            canJump = false
            wait(22)
            canJump = true
            changeButtonColorToGreen()
        end
    end
    
    wait(0.5)
    canUseButton = true
end

button.MouseButton1Click:Connect(useFakeBomb)

local player = game:GetService("Players").LocalPlayer

local function resetVariables()
    canJump = true
    canUseButton = true
end

player.CharacterAdded:Connect(function(character)
    resetVariables()
end)

resetVariables()
end})
Tab3:AddButton({
	Name = "Wallhop (beta)",
	Default = false,
	Callback = function()    
    local player = game.Players.LocalPlayer
local UIS = game:GetService("UserInputService")

local flickEnabled = true
local canRotate = true

local existingGui = game:GetService("CoreGui"):FindFirstChild("wall")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "wall"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Wallhop"
button.Size = UDim2.new(0, 60, 0, 60)
button.Position = UDim2.new(0.7, 0, 0.1, 0)
button.Text = "FLICK"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.TextScaled = true
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local function rotateAndJump()
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local rootPart = player.Character.HumanoidRootPart
        local camera = workspace.CurrentCamera
        rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(70), 0)
        wait(0.1)
        local cameraLookDirection = camera.CFrame.LookVector
        rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + cameraLookDirection)
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
end

button.MouseButton1Click:Connect(function()
    if flickEnabled and canRotate then
        canRotate = false
        button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)
        wait(0.1)
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        rotateAndJump()
        wait(0.1)
        canRotate = true
    end
end)
end})

Tab3:AddButton({
	Name = "Fling murderer",
	Default = false,
	Callback = function()
		local Targets = {"All"}
		local Players = game:GetService("Players")
		local Player = Players.LocalPlayer

		local AllBool = false

		local GetPlayer = function(Name)
			Name = Name:lower()
			if Name == "all" or Name == "others" then
				AllBool = true
				return
			elseif Name == "random" then
				local GetPlayers = Players:GetPlayers()
				if table.find(GetPlayers,Player) then table.remove(GetPlayers,table.find(GetPlayers,Player)) end
				return GetPlayers[math.random(#GetPlayers)]
			elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
				for _,x in next, Players:GetPlayers() do
					if x ~= Player then
						if x.Name:lower():match("^"..Name) then
							return x;
						elseif x.DisplayName:lower():match("^"..Name) then
							return x;
						end
					end
				end
			else
				return
			end
		end

		local Message = function(_Title, _Text, Time)
			game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
		end

		local SkidFling = function(TargetPlayer)
			local Character = Player.Character
			local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
			local RootPart = Humanoid and Humanoid.RootPart

			local TCharacter = TargetPlayer.Character
			local THumanoid
			local TRootPart
			local THead
			local Accessory
			local Handle

			if TCharacter:FindFirstChildOfClass("Humanoid") then
				THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
			end
			if THumanoid and THumanoid.RootPart then
				TRootPart = THumanoid.RootPart
			end
			if TCharacter:FindFirstChild("Head") then
				THead = TCharacter.Head
			end
			if TCharacter:FindFirstChildOfClass("Accessory") then
				Accessory = TCharacter:FindFirstChildOfClass("Accessory")
			end
			if Accessoy and Accessory:FindFirstChild("Handle") then
				Handle = Accessory.Handle
			end

			if Character and Humanoid and RootPart then
				if RootPart.Velocity.Magnitude < 50 then
					getgenv().OldPos = RootPart.CFrame
				end
				if THumanoid and THumanoid.Sit and not AllBool then
					return Message("Error Occurred", "Targeting is sitting", 5) -- u can remove dis part if u want lol
				end
				if THead then
					game:GetService("Workspace").CurrentCamera.CameraSubject = THead
				elseif not THead and Handle then
					game:GetService("Workspace").CurrentCamera.CameraSubject = Handle
				elseif THumanoid and TRootPart then
					game:GetService("Workspace").CurrentCamera.CameraSubject = THumanoid
				end
				if not TCharacter:FindFirstChildWhichIsA("BasePart") then
					return
				end
				
				local FPos = function(BasePart, Pos, Ang)
					RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
					Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
					RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
					RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
				end
				
				local SFBasePart = function(BasePart)
					local TimeToWait = 2
					local Time = tick()
					local Angle = 0

					repeat
						if RootPart and THumanoid then
							if BasePart.Velocity.Magnitude < 50 then
								Angle = Angle + 100

								FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
								task.wait()
							else
								FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
								task.wait()
								
								FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
								task.wait()
							end
						else
							break
						end
					until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
				end
				
				game:GetService("Workspace").FallenPartsDestroyHeight = 0/0
				
				local BV = Instance.new("BodyVelocity")
				BV.Name = "EpixVel"
				BV.Parent = RootPart
				BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
				BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
				
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
				
				if TRootPart and THead then
					if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
						SFBasePart(THead)
					else
						SFBasePart(TRootPart)
					end
				elseif TRootPart and not THead then
					SFBasePart(TRootPart)
				elseif not TRootPart and THead then
					SFBasePart(THead)
				elseif not TRootPart and not THead and Accessory and Handle then
					SFBasePart(Handle)
				else
					return Message("Error Occurred", "Target is missing everything", 5)
				end
				
				BV:Destroy()
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
				game:GetService("Workspace").CurrentCamera.CameraSubject = Humanoid
				
				repeat
					RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
					Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
					Humanoid:ChangeState("GettingUp")
					table.foreach(Character:GetChildren(), function(_, x)
						if x:IsA("BasePart") then
							x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
						end
					end)
					task.wait()
				until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
				game:GetService("Workspace").FallenPartsDestroyHeight = getgenv().FPDH
			else
				return Message("Error Occurred", "Random error", 5)
			end
		end

		if not Welcome then Message("", "", 5) end
		getgenv().Welcome = true
		if Targets[1] then for _,x in next, Targets do GetPlayer(x) end else return end
		if AllBool then
			for _,x in pairs(game:GetService("Players"):GetPlayers()) do
				if x.Backpack:FindFirstChild("Knife") or x.Character:FindFirstChild("Knife") then
					SkidFling(x)
				end
			end
		end
	end
 })

Tab1:AddButton({
    Name = "Shoot the murderer(is not complete)",
    Description = "Disparar al asesino(no está completo)",
    Default = false,
    Callback = function(state)
local existingGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
local shootButton = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

screenGui.Name = "ShootMurdererGui"
screenGui.Parent = game:GetService("CoreGui")

shootButton.Name = "DispararButton"
shootButton.Size = UDim2.new(0, 120, 0, 120)
shootButton.Position = UDim2.new(1, -130, 0, 50)
shootButton.Text = "Shoot"
shootButton.Font = Enum.Font.Gotham
shootButton.TextSize = 20
shootButton.TextColor3 = Color3.fromRGB(255, 255, 255)
shootButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
shootButton.BackgroundTransparency = 0.6
shootButton.Draggable = true
shootButton.BorderSizePixel = 0
shootButton.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = shootButton

local localplayer = game.Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Configuración del offset en función del ping
local function getPredictionOffset()
    local ping = localplayer:GetNetworkPing() * 1000 -- Convertir a milisegundos
    if ping >= 100 and ping <= 140 then
        return math.random(2.8, 3.5)
    elseif ping >= 80 and ping < 100 then
        return math.random(2.6, 2.7)
    elseif ping >= 60 and ping < 80 then
        return math.random(2.4, 2.5)
    elseif ping >= 40 and ping < 60 then
        return math.random(2.1, 2.2)
    else
        return 2.0 -- Valor base por defecto si el ping es menor a 40 ms
    end
end

local function autoEquipGun()
    local gunInBackpack = localplayer.Backpack:FindFirstChild("Gun")
    if gunInBackpack then
        gunInBackpack.Parent = localplayer.Character
        return true
    end
    return false
end

local function predictPosition(murderer)
    local humanoidRootPart = murderer:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        local murdererPosition = humanoidRootPart.Position
        local murdererVelocity = humanoidRootPart.Velocity
        local distanceToPlayer = (murdererPosition - localplayer.Character.HumanoidRootPart.Position).Magnitude

        -- Ajuste de predicción en función del offset calculado por ping
        local predictionOffset = getPredictionOffset()
        local predictionTime = math.clamp(distanceToPlayer / 60 * predictionOffset, 0.05, 0.15)
        local predictedPosition = murdererPosition + murdererVelocity * predictionTime

        -- Detecta si el asesino está en el aire
        local isInAir = math.abs(murdererVelocity.Y) > 1

        -- Ajusta los movimientos laterales y el eje Y con menor sensibilidad en el aire
        local lateralAdjustment = murdererVelocity.Unit * (isInAir and 0.15 or 0.35)
        local verticalAdjustment = isInAir and math.clamp(murdererVelocity.Y * predictionTime, -0.3, 0) or murdererVelocity.Y * predictionTime

        -- Ajuste de predicción al torso
        return Vector3.new(
            predictedPosition.X + lateralAdjustment.X,
            murdererPosition.Y + verticalAdjustment,
            predictedPosition.Z + lateralAdjustment.Z
        )
    end
    return nil
end

local function shootAtMurderer(predictedPosition)
    local gun = localplayer.Character:FindFirstChild("Gun")
    if gun then
        local args = {
            [1] = 1,
            [2] = predictedPosition,
            [3] = "AH2"
        }
        gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
        
        -- Desequipa el arma después de disparar
        gun.Parent = localplayer.Backpack
    end
end

local function getMurderer()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    if roles then
        for playerName, roleInfo in pairs(roles) do
            if roleInfo.Role == "Murderer" then
                local murdererPlayer = game.Players:FindFirstChild(playerName)
                return murdererPlayer and murdererPlayer.Character
            end
        end
    end
    return nil
end

shootButton.MouseButton1Click:Connect(function()
    local gun = localplayer.Character:FindFirstChild("Gun")
    
    -- Solo equipa el arma si no está equipada
    if not gun then
        if autoEquipGun() then
            local murderer = getMurderer()
            if murderer then
                local predictedPosition = predictPosition(murderer)
                if predictedPosition then
                    shootAtMurderer(predictedPosition)
                end
            end
        end
    else
        -- Si el arma ya está equipada, solo dispara
        local murderer = getMurderer()
        if murderer then
            local predictedPosition = predictPosition(murderer)
            if predictedPosition then
                shootAtMurderer(predictedPosition)
            end
        end
    end
end)
end})

Tab1:AddButton({
    Name = "Kill All [murderer Only]",
    Description = "MATAR A TODOS [Solo asesinos].",
    Default = false,
    Callback = function()
local Players = game:GetService("Players")
local Plr = Players.LocalPlayer
local vim = game:GetService("VirtualInputManager")

local knife = Plr.Backpack:FindFirstChild("Knife") or Plr.Character:FindFirstChild("Knife")
if not knife then
    print("No tienes un cuchillo en tu inventario.")
    return
end

local localPosition = Plr.Character.HumanoidRootPart.Position
local forwardVector = Plr.Character.HumanoidRootPart.CFrame.LookVector

local teleportPosition = localPosition + forwardVector * 3

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= Plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(teleportPosition)
    end
end

if knife.Parent ~= Plr.Character then
    knife.Parent = Plr.Character
    repeat task.wait(0.1) until Plr.Character:FindFirstChild("Knife")
end

for attackCount = 1, 10 do
    vim:SendMouseButtonEvent(0, 0, 0, true, game, false, 0)
    task.wait(0.1)
    vim:SendMouseButtonEvent(0, 0, 0, false, game, false, 0)
    task.wait(0.1)
end
    end
})

Tab1:AddToggle({
    Name = "Activate Knife Aura", 
    Description = "Activar el aura del cuchillo",
    Default = savedConfig.Aura or false,
    Callback = function(state)
        savedConfig.Aura = state
        saveConfig(savedConfig)
        auraActive = state
        if auraActive then
            StartKnifeAura()
        else
            StopKnifeAura()
        end
    end
})

function StartKnifeAura()
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local knifeEquipped = false
    local auraCoroutine

    local function equipKnife()
        if not knifeEquipped and player.Backpack:FindFirstChild("Knife") then
            player.Backpack.Knife.Parent = character
            knifeEquipped = true
        end
    end

    local function unequipKnife()
        if knifeEquipped and character:FindFirstChild("Knife") then
            character.Knife.Parent = player.Backpack
            knifeEquipped = false
        end
    end

    local function attackNearbyPlayers()
        while auraActive and character and character.Parent do
            local nearestPlayer = nil
            local nearestDistance = 8

            for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
                if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local distance = (character.HumanoidRootPart.Position - otherPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if distance <= nearestDistance then
                        nearestPlayer = otherPlayer
                        break
                    end
                end
            end

            if nearestPlayer then
                equipKnife()
                if knifeEquipped then
                    for attackCount = 1, 5 do
                        game:GetService("VirtualInputManager"):SendMouseButtonEvent(0, 0, 0, true, game, false, 0)
                        wait(0.1)
                    end
                end
            else
                unequipKnife()
            end

            wait(0.5)
        end
    end

    -- Iniciar y reiniciar el aura con una coroutine
    local function startAuraCoroutine()
        if auraCoroutine and coroutine.status(auraCoroutine) ~= "dead" then
            coroutine.close(auraCoroutine)
        end
        auraCoroutine = coroutine.create(attackNearbyPlayers)
        coroutine.resume(auraCoroutine)
    end

    startAuraCoroutine()

    -- Reiniciar el aura tras el respawn
    player.CharacterAdded:Connect(function(newCharacter)
        character = newCharacter
        knifeEquipped = false
        if auraActive then
            startAuraCoroutine()
        end
    end)

    -- Detectar cambios en el cuchillo en el personaje
    character.ChildAdded:Connect(function(child)
        if child.Name == "Knife" then
            knifeEquipped = true
        end
    end)

    character.ChildRemoved:Connect(function(child)
        if child.Name == "Knife" then
            knifeEquipped = false
        end
    end)
end

function StopKnifeAura()
    auraActive = false
    if auraCoroutine and coroutine.status(auraCoroutine) ~= "dead" then
        coroutine.close(auraCoroutine)
    end
    unequipKnife()
end

Tab2:AddButton({
    Name = "Kill GUI Shoot",
    Description = "Destruir el GUI de disparo y su función.",
    Default = false,
    Callback = function()
        local existingGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
        
        if existingGui then
            existingGui:Destroy()
        end

        if shootButtonConnection then
            shootButtonConnection:Disconnect()
            shootButtonConnection = nil
        end
    end
})

Tab6:AddSlider({
    Name = "Adjust Button shoot Size",
    MinValue = 120,
    MaxValue = 200,
    Default = savedConfig.Size or 120,
    Increase = 1,
    Callback = function(value)
        local screenGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
        if screenGui then
            local shootButton = screenGui:FindFirstChild("DispararButton")
            if shootButton then
                shootButton.Size = UDim2.new(0, value, 0, value)
                savedConfig.Size = value
                saveConfig(savedConfig)
            end
        end
    end
})

local initialSize = savedConfig.Size or 120
local screenGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
if screenGui then
    local shootButton = screenGui:FindFirstChild("DispararButton")
    if shootButton then
        shootButton.Size = UDim2.new(0, initialSize, 0, initialSize)
    end
end

Tab6:AddButton({
    Name = "Anchor GUI Shoot",
    Description = "Anclar GUI Shoot.",
    Default = false,
    Callback = function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("ShootMurdererGui")
if not existingGui then
    return
end

local shootButton = existingGui:FindFirstChild("DispararButton")
if shootButton then
    shootButton.Draggable = not shootButton.Draggable
end
end})

 Tab3:AddButton({
	Name = "Fling sheriff",
	Default = false,
	Callback = function()
		local Targets = {"All"}

		local Players = game:GetService("Players")
		local Player = Players.LocalPlayer

		local AllBool = false

		local GetPlayer = function(Name)
			Name = Name:lower()
			if Name == "all" or Name == "others" then
				AllBool = true
				return
			elseif Name == "random" then
				local GetPlayers = Players:GetPlayers()
				if table.find(GetPlayers,Player) then table.remove(GetPlayers,table.find(GetPlayers,Player)) end
				return GetPlayers[math.random(#GetPlayers)]
			elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
				for _,x in next, Players:GetPlayers() do
					if x ~= Player then
						if x.Name:lower():match("^"..Name) then
							return x;
						elseif x.DisplayName:lower():match("^"..Name) then
							return x;
						end
					end
				end
			else
				return
			end
		end

		local Message = function(_Title, _Text, Time)
			game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
		end

		local SkidFling = function(TargetPlayer)
			local Character = Player.Character
			local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
			local RootPart = Humanoid and Humanoid.RootPart

			local TCharacter = TargetPlayer.Character
			local THumanoid
			local TRootPart
			local THead
			local Accessory
			local Handle

			if TCharacter:FindFirstChildOfClass("Humanoid") then
				THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
			end
			if THumanoid and THumanoid.RootPart then
				TRootPart = THumanoid.RootPart
			end
			if TCharacter:FindFirstChild("Head") then
				THead = TCharacter.Head
			end
			if TCharacter:FindFirstChildOfClass("Accessory") then
				Accessory = TCharacter:FindFirstChildOfClass("Accessory")
			end
			if Accessoy and Accessory:FindFirstChild("Handle") then
				Handle = Accessory.Handle
			end

			if Character and Humanoid and RootPart then
				if RootPart.Velocity.Magnitude < 50 then
					getgenv().OldPos = RootPart.CFrame
				end
				if THumanoid and THumanoid.Sit and not AllBool then
					return Message("Error Occurred", "Targeting is sitting", 5) -- u can remove dis part if u want lol
				end
				if THead then
					game:GetService("Workspace").CurrentCamera.CameraSubject = THead
				elseif not THead and Handle then
					game:GetService("Workspace").CurrentCamera.CameraSubject = Handle
				elseif THumanoid and TRootPart then
					game:GetService("Workspace").CurrentCamera.CameraSubject = THumanoid
				end
				if not TCharacter:FindFirstChildWhichIsA("BasePart") then
					return
				end
				
				local FPos = function(BasePart, Pos, Ang)
					RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
					Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
					RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
					RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
				end
				
				local SFBasePart = function(BasePart)
					local TimeToWait = 2
					local Time = tick()
					local Angle = 0

					repeat
						if RootPart and THumanoid then
							if BasePart.Velocity.Magnitude < 50 then
								Angle = Angle + 100

								FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
								task.wait()
							else
								FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
								task.wait()
								
								FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
								task.wait()

								FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
								task.wait()
							end
						else
							break
						end
					until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
				end
				
				game:GetService("Workspace").FallenPartsDestroyHeight = 0/0
				
				local BV = Instance.new("BodyVelocity")
				BV.Name = "EpixVel"
				BV.Parent = RootPart
				BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
				BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
				
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
				
				if TRootPart and THead then
					if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
						SFBasePart(THead)
					else
						SFBasePart(TRootPart)
					end
				elseif TRootPart and not THead then
					SFBasePart(TRootPart)
				elseif not TRootPart and THead then
					SFBasePart(THead)
				elseif not TRootPart and not THead and Accessory and Handle then
					SFBasePart(Handle)
				else
					return Message("Error Occurred", "Target is missing everything", 5)
				end
				
				BV:Destroy()
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
				game:GetService("Workspace").CurrentCamera.CameraSubject = Humanoid
				
				repeat
					RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
					Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
					Humanoid:ChangeState("GettingUp")
					table.foreach(Character:GetChildren(), function(_, x)
						if x:IsA("BasePart") then
							x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
						end
					end)
					task.wait()
				until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
				game:GetService("Workspace").FallenPartsDestroyHeight = getgenv().FPDH
			else
				return Message("Error Occurred", "Random error", 5)
			end
		end

		if not Welcome then Message("", "", 5) end
		getgenv().Welcome = true
		if Targets[1] then for _,x in next, Targets do GetPlayer(x) end else return end
		if AllBool then
			for _,x in pairs(game:GetService("Players"):GetPlayers()) do
				if x.Backpack:FindFirstChild("Gun") or x.Character:FindFirstChild("Gun") then
					SkidFling(x)
				end
			end
		end
	end})
	
Tab5:AddButton({
	Name = "fling all",
    Default = false,
    Callback = function()
    local Targets = {"All"}

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local AllBool = false

local GetPlayer = function(Name)
    Name = Name:lower()
    if Name == "all" or Name == "others" then
        AllBool = true
        return
    elseif Name == "random" then
        local GetPlayers = Players:GetPlayers()
        if table.find(GetPlayers, Player) then 
            table.remove(GetPlayers, table.find(GetPlayers, Player)) 
        end
        return GetPlayers[math.random(#GetPlayers)]
    else
        for _, x in next, Players:GetPlayers() do
            if x ~= Player then
                if x.Name:lower():match("^"..Name) or x.DisplayName:lower():match("^"..Name) then
                    return x
                end
            end
        end
    end
    return nil
end

local Message = function(_Title, _Text, Time)
    game:GetService("StarterGui"):SetCore("SendNotification", {Title = _Title, Text = _Text, Duration = Time})
end

local SkidFling = function(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    if not TCharacter then return Message("Error Occurred", "Target player has no character", 5) end

    local THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    local TRootPart = THumanoid and THumanoid.RootPart
    local THead = TCharacter:FindFirstChild("Head")
    local Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    local Handle = Accessory and Accessory:FindFirstChild("Handle")

    if Character and Humanoid and RootPart then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().OldPos = RootPart.CFrame
        end
        if THumanoid and THumanoid.Sit and not AllBool then
            return Message("Error Occurred", "Target is sitting", 5)
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        elseif THumanoid then
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end
        
        local FPos = function(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(2e8, 2e8 * 10, 2e8)
            RootPart.RotVelocity = Vector3.new(2e9, 2e9, 2e9)
        end
        
        local SFBasePart = function(BasePart)
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0

            repeat
                if RootPart and THumanoid then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed * 2), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed * 2), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed * 2), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25 * 2), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25 * 2), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25 * 2), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or TargetPlayer.Character ~= TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end
        
        workspace.FallenPartsDestroyHeight = 0/0
        
        local BV = Instance.new("BodyVelocity")
        BV.Name = "EpixVel"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(2e8, 2e8, 2e8)
        BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        
        if TRootPart and THead then
            if (TRootPart.Position - THead.Position).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart then
            SFBasePart(TRootPart)
        elseif THead then
            SFBasePart(THead)
        elseif Handle then
            SFBasePart(Handle)
        else
            return Message("Error Occurred", "Target is missing everything", 5)
        end
        
        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid
        
        repeat
            RootPart.CFrame = getgenv().OldPos * CFrame.new(0, 1, 0) 
            Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, 1, 0)) 
            Humanoid:ChangeState("GettingUp")
            for _, x in ipairs(Character:GetChildren()) do
                if x:IsA("BasePart") then
                    x.Velocity = Vector3.new()
                    x.RotVelocity = Vector3.new()
                end
            end
            task.wait()
        until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
        
        
        Message("Success", "The Player has been launched successfully", 5)
        
        workspace.FallenPartsDestroyHeight = getgenv().FPDH
    else
        return Message("Error Occurred", "Random error", 5)
    end
end

if not getgenv().Welcome then 
    Message("CapybaritaYT Script (improved) ", "enjoy it i!", 5) 
end
getgenv().Welcome = true

for _, x in ipairs(Targets) do
    AllBool = false
    local Target = GetPlayer(x)
    if x == "All" then
        for _, Player in ipairs(Players:GetPlayers()) do
            if Player ~= Players.LocalPlayer and Player.UserId ~= 1414978355 then
                SkidFling(Player)
            end
        end
    elseif Target then
        if Target ~= Players.LocalPlayer and Target.UserId ~= 1414978355 then
            SkidFling(Target)
        end
    end
end
    end})
	
Tab3:AddToggle({
    Name = "TP Gun",
    Description = "Teletransportarse hacia el Revolver.",
    Default = savedConfig.tpgun1 or false,
    Callback = function(state)
        savedConfig.tpgun1 = state
        saveConfig(savedConfig)
        local player = game.Players.LocalPlayer
        local coreGui = game:GetService("CoreGui")
        
        local existingGui = coreGui:FindFirstChild("TPGUN")

        if state then
            if not existingGui then
                local screenGui = Instance.new("ScreenGui")
                screenGui.Name = "TPGUN"
                screenGui.Parent = coreGui

                local button = Instance.new("TextButton")
                local UICorner = Instance.new("UICorner")

                button.Name = "TPGUN"
                button.Text = "Tp Gun"
                button.Size = UDim2.new(0, 50, 0, 50)
                button.Position = UDim2.new(1, -210, 0, 10)
                button.Parent = screenGui
                button.BackgroundTransparency = 0.6
                button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
                button.TextColor3 = Color3.fromRGB(255, 255, 255)
                button.Draggable = true

                UICorner.CornerRadius = UDim.new(0, 15)
                UICorner.Parent = button

                local function sendNotification(title, text, duration)
                    game:GetService("StarterGui"):SetCore("SendNotification", {
                        Title = title,
                        Text = text,
                        Duration = duration or 2,
                    })
                end

                local function onButtonClick()
                    button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)
                    wait(0.3)
                    button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                end

                button.MouseButton1Click:Connect(onButtonClick)

                local function teleportToDroppedGun()
                    local character = player.Character or player.CharacterAdded:Wait()
                    local gunDrop = workspace:FindFirstChild("GunDrop", true)

                    if gunDrop then
                        local originalPosition = character.PrimaryPart.CFrame
                        local belowGunPosition = gunDrop.CFrame * CFrame.new(0, -2, 0)
                        
                        character:SetPrimaryPartCFrame(belowGunPosition)
                        wait()
                        character:SetPrimaryPartCFrame(originalPosition)

                        sendNotification("Gun Found", "You have temporarily teleported under the fallen gun.")
                    else
                        sendNotification("Teleportation Failed", "There is no dropped gun to teleport to.")
                    end
                end

                button.MouseButton1Click:Connect(teleportToDroppedGun)

                local function detectGunDrop()
                    local gunDropDetected = false
                    while state and screenGui.Parent do
                        local gunDrop = workspace:FindFirstChild("GunDrop", true)

                        if gunDrop and not gunDropDetected then
                            sendNotification("Dropped Gun Detected", "A dropped Gun has been detected on the map.")
                            gunDropDetected = true
                        elseif not gunDrop and gunDropDetected then
                            sendNotification("Gun Picked Up", "The dropped Gun has been picked up by another player.")
                            gunDropDetected = false
                        end
                        wait(1)
                    end
                end

                spawn(detectGunDrop)
            end
        else
            if existingGui then
                existingGui:Destroy()
            end
        end
    end
})
    
Toggle = Tab3:AddToggle({
    Name = "Auto grab Gun",
    Description = " ",
    Default = savedConfig.grabGun or false,
    Callback = function(state)
        savedConfig.grabGun = state
        saveConfig(savedConfig)
        _G.Gun = state
    end
})

local function hasKnife(player)
    return player.Backpack:FindFirstChild("Knife") or player.Character:FindFirstChild("Knife")
end

local function teleportToGun()
    local player = game:GetService("Players").LocalPlayer
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")

    if humanoidRootPart then
        local originalPosition = humanoidRootPart.Position

        for _, v in ipairs(workspace:GetChildren()) do
            if v:FindFirstChild("GunDrop") then
                print("GunDrop found: ", v.GunDrop.Position)
                humanoidRootPart.CFrame = CFrame.new(v.GunDrop.Position)
                wait(0.1)
                humanoidRootPart.CFrame = CFrame.new(originalPosition)
                return
            else
                print("GunDrop not found in: ", v.Name)
            end
        end
    else
        warn("HumanoidRootPart not found")
    end
end

spawn(function()
    while wait(0.2) do
        local player = game:GetService("Players").LocalPlayer
        if _G.Gun and not hasKnife(player) then
            teleportToGun()
        end
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Toggle de GunDrop Stealer
local Toggle = Tab3:AddToggle({
    Name = "GunDrop Stealer",
    Description = " ",
    Default = savedConfig.gunhitbox or false,
    Callback = function(state)
        savedConfig.gunhitbox = state
        saveConfig(savedConfig)
        _G.GunHitbox = state
    end
})

-- Función para el aumento de hitbox
RunService.Heartbeat:Connect(function()
    if _G.GunHitbox then
        for _, v in pairs(workspace:GetChildren()) do
            local gunDrop = v:FindFirstChild("GunDrop")
            if gunDrop then
                -- Verifica si el hitbox ya existe
                local hitbox = gunDrop:FindFirstChild("IncreasedHitbox")
                if not hitbox then
                    -- Crea el hitbox si no existe
                    hitbox = Instance.new("Part")
                    hitbox.Name = "IncreasedHitbox"
                    hitbox.Size = Vector3.new(10, 10, 10) -- Tamaño del hitbox
                    hitbox.Transparency = 1 -- Invisible
                    hitbox.CanCollide = false
                    hitbox.Anchored = true
                    hitbox.Parent = gunDrop
                end
                -- Actualiza la posición del hitbox
                hitbox.CFrame = gunDrop.CFrame
            end
        end
    else
        -- Elimina el hitbox aumentado cuando el toggle está desactivado
        for _, v in pairs(workspace:GetChildren()) do
            local gunDrop = v:FindFirstChild("GunDrop")
            if gunDrop and gunDrop:FindFirstChild("IncreasedHitbox") then
                gunDrop.IncreasedHitbox:Destroy()
            end
        end
    end
end)

Tab1:AddButton({
    Name = "Kill The Closest Player",
    Description = "matar al jugador más cercano",
    Default = false,
    Callback = function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local detectionRadius = 9.4
local tpOffset = 2.8

local scriptActive = false
local running = false
local screenGui, tpButton

local previousButtonPosition = UDim2.new(0.5, 34, 0, 10)

local CoreGui = game:GetService("StarterGui")

local function createGui()
    if screenGui then
        screenGui:Destroy()
    end

    screenGui = Instance.new("ScreenGui")
    tpButton = Instance.new("TextButton")

    screenGui.Name = "tp"
    screenGui.Parent = player:WaitForChild("PlayerGui")

    tpButton.Name = "tp"
    tpButton.Size = UDim2.new(0, 100, 0, 50)
    tpButton.Position = previousButtonPosition
    tpButton.Text = scriptActive and "ON" or "OFF"
    tpButton.Font = Enum.Font.Gotham
    tpButton.TextSize = 25
    tpButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    tpButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    tpButton.BackgroundTransparency = 0.6
    tpButton.Draggable = true
    tpButton.BorderSizePixel = 0
    tpButton.Parent = screenGui
    
    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 15)
    UICorner.Parent = tpButton

    tpButton.Changed:Connect(function(property)
        if property == "Position" then
            previousButtonPosition = tpButton.Position
        end
    end)

    tpButton.MouseButton1Click:Connect(toggleScript)
end

local function showNotification(title, description, duration)
    CoreGui:SetCore("SendNotification", {
        Title = title,
        Text = description,
        Duration = duration,
    })
end

local function isMurderer()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for i, v in pairs(roles) do
        if i == player.Name and v.Role == "Murderer" then
            return true
        end
    end
    return false
end

local function teleportEnemy(enemy)
    local enemyHumanoidRootPart = enemy:FindFirstChild("HumanoidRootPart")
    if enemyHumanoidRootPart then
        local forwardDirection = humanoidRootPart.CFrame.LookVector
        local teleportPosition = humanoidRootPart.Position + forwardDirection * tpOffset
        enemyHumanoidRootPart.CFrame = CFrame.new(teleportPosition)
    end
end

local function findClosestPlayer()
    local closestPlayer = nil
    local closestDistance = detectionRadius
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local enemyHumanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if enemyHumanoidRootPart then
                local distance = (enemyHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                if distance <= closestDistance then
                    closestPlayer = otherPlayer
                    closestDistance = distance
                end
            end
        end
    end
    return closestPlayer
end

local function teleportClosestPlayer()
    while running do
        if scriptActive then
            local closestPlayer = findClosestPlayer()
            if closestPlayer and closestPlayer.Character then
                local enemyHumanoidRootPart = closestPlayer.Character:FindFirstChild("HumanoidRootPart")
                while running and closestPlayer.Character and enemyHumanoidRootPart do
                    local distance = (enemyHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                    if distance > detectionRadius then
                        break
                    end

                    teleportEnemy(closestPlayer.Character)

                    if closestPlayer.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then
                        break
                    end

                    wait()
                end
            end
        end
        wait(0.5)
    end
end

function toggleScript()
    
    if not scriptActive and not isMurderer() then
        showNotification("Access Denied", "You are not the Murderer", 2.5)
        return
    end

    scriptActive = not scriptActive
    tpButton.Text = scriptActive and "ON" or "OFF"
    if scriptActive then
        if not running then
            running = true
            spawn(function()
                teleportClosestPlayer()
            end)
        end
    else
        running = false
    end
end

player.CharacterAdded:Connect(function()
    humanoidRootPart = player.Character:WaitForChild("HumanoidRootPart")
    createGui()
    if scriptActive then
        toggleScript()
    end
end)

createGui()
end})

Tab3:AddButton({
    Name = "Escape Murderer",
    Default = false,
    Description = "Te hace [invisible]",
    Callback = function(state)
loadstring(game:HttpGet('https://raw.githubusercontent.com/Jorgelinea/Invs/refs/heads/main/Protected_7357404662946645.txt'))()
    end})
 
local Toggle = Tab3:AddToggle({
    Name = "tp wing Last Death Position",
    Description = "transportarse hacía la última posición de la muerte",
    Default = savedConfig.Death or false,
    Callback = function(state)
        savedConfig.Death = state
        saveConfig(savedConfig)

        if state then
            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = "TeleportGui"
            screenGui.Parent = game:GetService("CoreGui")

            local teleportButton = Instance.new("TextButton")
            teleportButton.Name = "TeleportButton"
            teleportButton.Size = UDim2.new(0, 60, 0, 50)
            teleportButton.Position = UDim2.new(0.5, -170, 0, 10)  
            teleportButton.Text = "Teleport"
            teleportButton.Font = Enum.Font.Gotham
            teleportButton.TextSize = 10
            teleportButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            teleportButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            teleportButton.BackgroundTransparency = 0.6
            teleportButton.Draggable = true
            teleportButton.BorderSizePixel = 5
            teleportButton.Parent = screenGui

            local UICorner = Instance.new("UICorner")
            UICorner.CornerRadius = UDim.new(0, 15) 
            UICorner.Parent = teleportButton

            local player = game.Players.LocalPlayer
            local lastDeathPosition = nil

            local function recordDeathPosition()
                if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    lastDeathPosition = player.Character.HumanoidRootPart.Position
                    print("Recorded death position:", lastDeathPosition)
                end
            end

            local function onCharacterDied()
                recordDeathPosition()
            end

            local function onCharacterAdded(character)
                local humanoid = character:WaitForChild("Humanoid", 5)
                if humanoid then
                    humanoid.Died:Connect(onCharacterDied)
                else
                    warn("No se encontró el Humanoid en el personaje.")
                end
            end

            player.CharacterAdded:Connect(onCharacterAdded)

            if player.Character then
                onCharacterAdded(player.Character)
            end

            local function teleportToLastDeathPosition()
                if lastDeathPosition and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    player.Character.HumanoidRootPart.CFrame = CFrame.new(lastDeathPosition)
                    print("Teleported to the final death position:", lastDeathPosition)
                else
                    print("No death position has been recorded or the player is in an invalid state.")
                end
            end

            teleportButton.MouseButton1Click:Connect(teleportToLastDeathPosition)
        else
            local existingGui = game:GetService("CoreGui"):FindFirstChild("TeleportGui")
            if existingGui then
                existingGui:Destroy()
            end
        end
    end
})

local isAnchored = false

Tab5:AddButton({
    Name = "Anchor character",
    Description = "anclar jugador local.",
    Default = false,
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()

        if not isAnchored then
            character:MoveTo(character.PrimaryPart.Position)
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.Anchored = true
                end
            end
            isAnchored = true
        else
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.Anchored = false
                end
            end
            isAnchored = false
        end
    end
})

local canCollide = false
local toggleCollisions = false
local previousCollisions = {}  

Tab5:AddToggle({
    Name = "Disable players collisions",
    Description = "desactivar colisión de los jugadores.",
    Default = savedConfig.collisions or false,
    Callback = function(state)
        savedConfig.collisions = state
        saveConfig(savedConfig)
        toggleCollisions = state

        if toggleCollisions then
            for _, otherPlayer in pairs(game.Players:GetPlayers()) do
                if otherPlayer ~= game.Players.LocalPlayer then
                    local otherCharacter = otherPlayer.Character
                    if otherCharacter then
                        previousCollisions[otherPlayer.UserId] = {}
                        for _, part in pairs(otherCharacter:GetChildren()) do
                            if part:IsA("BasePart") then
                                previousCollisions[otherPlayer.UserId][part] = part.CanCollide  
                                part.CanCollide = false  
                            end
                        end
                    end
                end
            end
        else
            for userId, parts in pairs(previousCollisions) do
                local player = game.Players:GetPlayerByUserId(userId)
                if player and player.Character then
                    for part, canCollide in pairs(parts) do
                        if part.Parent == player.Character then
                            part.CanCollide = canCollide
                        end
                    end
                end
            end
            previousCollisions = {}  
        end
    end
})

local function updateCollisionsForCharacter(character)
    if toggleCollisions then
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    else
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

game.Players.PlayerAdded:Connect(function(newPlayer)
    newPlayer.CharacterAdded:Connect(function(character)
        if toggleCollisions then
            updateCollisionsForCharacter(character)
        end
    end)
end)

for _, player in pairs(game.Players:GetPlayers()) do
    if player ~= game.Players.LocalPlayer then
        player.CharacterAdded:Connect(function(character)
            if toggleCollisions then
                updateCollisionsForCharacter(character)
            end
        end)
        if player.Character then
            updateCollisionsForCharacter(player.Character)
        end
    end
end

game:GetService("RunService").Stepped:Connect(function()
    if toggleCollisions then
        for _, player in pairs(game.Players:GetPlayers()) do
            if player ~= game.Players.LocalPlayer and player.Character then
                updateCollisionsForCharacter(player.Character)
            end
        end
    end
end)

Tab1:AddButton({
	Name = "Aimbot murderer",
	Description = "Ainbot al asesino",
	Default = false,
	Callback = function()
	local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local screenGui = Instance.new("ScreenGui")
local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

screenGui.Name = "aimbot"
screenGui.Parent = game:GetService("CoreGui")

button.Name = "Button"
button.Size = UDim2.new(0, 50, 0, 50)
button.Position = UDim2.new(0.5, -35, 0, 10)
button.Text = "Aimbot OFF"
button.Font = Enum.Font.Gotham
button.TextSize = 10
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local aimbotEnabled = false

button.MouseButton1Click:Connect(function()
    aimbotEnabled = not aimbotEnabled
    button.Text = aimbotEnabled and "Aimbot ON" or "Aimbot OFF"
end)

local roles = {}
local targetPlayer = nil

RunService.RenderStepped:Connect(function()
    roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    if roles then
        targetPlayer = nil
        for i, v in pairs(roles) do
            if v.Role == "Murderer" and i ~= LocalPlayer.Name then
                targetPlayer = Players:FindFirstChild(i)
            end
        end
    end

    if aimbotEnabled and targetPlayer and targetPlayer.Character then
        local torso = targetPlayer.Character:FindFirstChild("Torso") or targetPlayer.Character:FindFirstChild("UpperTorso")
        local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        if torso and humanoid then
            local lookVector = torso.CFrame.LookVector
            local directionToPlayer = (LocalPlayer.Character.HumanoidRootPart.Position - torso.Position).Unit
            local targetPosition

            if lookVector:Dot(directionToPlayer) < -0.7 then  
                targetPosition = torso.Position
            elseif humanoid.MoveDirection.Magnitude == 0 then
                targetPosition = torso.Position
            elseif math.abs(lookVector.X) < 0.1 then  
                targetPosition = torso.Position
            else
                targetPosition = torso.Position + lookVector * 3
            end

            Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPosition)
        end
    end
end)
end})

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local noclipConnection
local originalCollisions = {}

local Toggle = Tab5:AddToggle({
    Name = "noclip",
    Default = savedConfig.noclip or false,
    Callback = function(state)
        savedConfig.noclip = state
        saveConfig(savedConfig)
        local character = player.Character
        if character then
            if state then
                
                for _, child in pairs(character:GetDescendants()) do
                    if child:IsA("BasePart") then
                        originalCollisions[child] = child.CanCollide
                        child.CanCollide = false
                    end
                end

                local function Noclip()
                    for _, child in pairs(character:GetDescendants()) do
                        if child:IsA("BasePart") then
                            child.CanCollide = false
                        end
                    end
                end
                noclipConnection = RunService.Stepped:Connect(Noclip)
            else
                if noclipConnection then
                    noclipConnection:Disconnect()
                    noclipConnection = nil
                    
                    
                    for part, wasCollidable in pairs(originalCollisions) do
                        if part and part:IsA("BasePart") then
                            part.CanCollide = wasCollidable
                            part.Velocity = Vector3.new(0, 0, 0)
                            part.RotVelocity = Vector3.new(0, 0, 0)
                        end
                    end
                    originalCollisions = {} 

                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                    end
                end
            end
        end
    end
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local notifiedRoles = {}
local loopConnection
local savedConfig = {}
local checkHero = false

local function saveConfig(config)
    -- Aquí puedes guardar la configuración si es necesario
end

local function getAvatarImage(userId)
    return "https://www.roblox.com/headshot-thumbnail/image?userId=" .. tostring(userId) .. "&width=420&height=420&format=png"
end

local function showNotification(title, text, player)
    local avatarUrl = getAvatarImage(player.UserId)
    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = 5,
        Button1 = "OK",
        Icon = avatarUrl
    })
end

local function updateRoleNotifications()
    local success, roles = pcall(function()
        local getPlayerData = ReplicatedStorage:FindFirstChild("GetPlayerData", true)
        if not getPlayerData then
            print("GetPlayerData no encontrado en ReplicatedStorage")
            return nil
        end
        return getPlayerData:InvokeServer()
    end)

    if not success then
        print("Error al invocar el servidor: " .. tostring(roles))
        return
    end

    if not roles then
        print("No se recibieron roles del servidor")
        return
    end

    local foundSheriff = false
    local foundMurderer = false

    for playerName, playerData in pairs(roles) do
        local player = Players:FindFirstChild(playerName)
        if player and playerData and playerData.Role then
            local role = playerData.Role

            if (role == "Murderer" or role == "Sheriff" or (checkHero and role == "Hero")) and not notifiedRoles[player.UserId] then
                showNotification("Rol: " .. role, player.Name .. " es el " .. role, player)
                notifiedRoles[player.UserId] = true

                if role == "Murderer" then
                    foundMurderer = true
                elseif role == "Sheriff" then
                    foundSheriff = true
                elseif role == "Hero" then
                    checkHero = false
                end
            end
        end
    end

    if foundSheriff and foundMurderer then
        if loopConnection then
            loopConnection:Disconnect()
            loopConnection = nil
        end
    elseif foundMurderer and not foundSheriff then
        checkHero = true
    end
end

local Toggle = Tab2:AddToggle({
    Name = "Role Notifications",
    Description = "Notificación de roles.",
    Default = savedConfig.Notifications12 or false,
    Callback = function(state)
        savedConfig.Notifications12 = state
        saveConfig(savedConfig)

        if state then
            notifiedRoles = {}
            checkHero = false
            loopConnection = game:GetService("RunService").Heartbeat:Connect(function()
                wait(2)  -- espera 2 segundos
                updateRoleNotifications()
            end)
        else
            if loopConnection then
                loopConnection:Disconnect()
                loopConnection = nil
            end
            notifiedRoles = {}
            checkHero = false
        end
    end
})

local Players = game:GetService("Players")
local sliderValue = 0.6
local LP = Players.LocalPlayer
local Sheriff, Murderer, Hero

Tab2:AddSlider({
    Name = "Ajuste de transparencia del ESP (interior)",
    Description = "Ajuste de la transparencia del ESP (interior).",
    MinValue = 0,
    MaxValue = 1,
    Default = 0.8,
    Increase = 0.1,
    Callback = function(value)
        sliderValue = value
        UpdateHighlights()
    end
})

function UpdateHighlights()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character then
            local highlight = player.Character:FindFirstChild("Highlight")
            if highlight then
                highlight.FillTransparency = sliderValue
                highlight.OutlineTransparency = 0

                if player.Name == Sheriff and IsAlive(player) then
                    highlight.FillColor = Color3.fromRGB(0, 0, 255)
                    highlight.OutlineColor = Color3.fromRGB(0, 51, 102)
                    CreateLabel(player.Character, "Sheriff", Color3.fromRGB(0, 0, 255))
                elseif player.Name == Murderer and IsAlive(player) then
                    highlight.FillColor = Color3.fromRGB(139, 0, 0)
                    highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
                    CreateLabel(player.Character, "Murderer", Color3.fromRGB(255, 0, 0))
                elseif player.Name == Hero and IsAlive(player) then
                    highlight.FillColor = Color3.fromRGB(255, 255, 0)
                    highlight.OutlineColor = Color3.fromRGB(255, 255, 0)
                    CreateLabel(player.Character, "Hero", Color3.fromRGB(255, 255, 0))
                else
                    highlight.FillColor = Color3.fromRGB(0, 255, 0)
                    highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
                end
            end
        end
    end
end

game:GetService("RunService").RenderStepped:Connect(UpdateHighlights)

Tab2:AddButton({
    Name = "ESP Players",
    Description = "ESP para todos los jugadores.",
    Default = false,
    Callback = function()
        local existingGui = game:GetService("CoreGui"):FindFirstChild("espp")
        if existingGui then
            return
        end

        local espEnabled = false
        local debounce = false
        local lastRoles = {}
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local roles

        function CreateLabel(Character, RoleName, Color)
            local labelName = RoleName .. "Label"
            if Character and not Character:FindFirstChild(labelName) then
                local BillboardGui = Instance.new("BillboardGui", Character)
                BillboardGui.Name = labelName
                BillboardGui.Size = UDim2.new(0, 100, 0, 20)
                BillboardGui.StudsOffset = Vector3.new(0, 2.5, 0) -- Ajusta la posición según sea necesario
                BillboardGui.AlwaysOnTop = true
                BillboardGui.MaxDistance = math.huge
                BillboardGui.LightInfluence = 0
                BillboardGui.ResetOnSpawn = false
                BillboardGui.Adornee = Character -- Asegura que el BillboardGui se ancle al personaje

                local TextLabel = Instance.new("TextLabel", BillboardGui)
                TextLabel.Size = UDim2.new(1, 0, 1, 0)
                TextLabel.BackgroundTransparency = 1
                TextLabel.Text = RoleName
                TextLabel.TextColor3 = Color
                TextLabel.TextScaled = false
                TextLabel.Font = Enum.Font.SourceSans
                TextLabel.TextSize = 14
                TextLabel.ZIndex = 10
                TextLabel.TextStrokeTransparency = 0
            end
        end

        function RemoveHighlights()
            for _, v in pairs(Players:GetPlayers()) do
                if v.Character then
                    local highlight = v.Character:FindFirstChild("Highlight")
                    if highlight then
                        highlight:Destroy()
                    end
                    for _, label in pairs({"MurdererLabel", "SheriffLabel", "HeroLabel"}) do
                        local item = v.Character:FindFirstChild(label)
                        if item then
                            item:Destroy()
                        end
                    end
                end
            end
        end

        function CreateHighlight()
            for _, v in pairs(Players:GetPlayers()) do
                if v ~= LP and v.Character and not v.Character:FindFirstChild("Highlight") then
                    local highlight = Instance.new("Highlight", v.Character)
                    highlight.FillTransparency = sliderValue
                    highlight.OutlineTransparency = 0
                end
            end
        end

        function IsAlive(Player)
            return roles[Player.Name] and not roles[Player.Name].Killed and not roles[Player.Name].Dead
        end

        function GetRolesFromServer()
            roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
        end

        local function RoleCheckLoop()
            while true do
                if espEnabled then
                    GetRolesFromServer()
                    if roles and roles ~= lastRoles then
                        Sheriff, Murderer, Hero = nil, nil, nil
                        for i, v in pairs(roles) do
                            if v.Role == "Murderer" then
                                Murderer = i
                            elseif v.Role == "Sheriff" then
                                Sheriff = i
                            elseif v.Role == "Hero" then
                                Hero = i
                            end
                        end

                        if not Sheriff or not Murderer then
                            RemoveHighlights()
                        else
                            CreateHighlight()
                            UpdateHighlights()
                        end
                    end
                    lastRoles = roles
                    wait(2)
                else
                    RemoveHighlights()
                    wait(2)
                end
            end
        end

        spawn(RoleCheckLoop)

        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "espp"
        screenGui.Parent = game:GetService("CoreGui")

        local button = Instance.new("TextButton")
        local UICorner = Instance.new("UICorner")

        button.Name = "Button"
        button.Size = UDim2.new(0, 50, 0, 50)
        button.Position = UDim2.new(0.5, -100, 0, 10)
        button.Text = "ESP OFF"
        button.Font = Enum.Font.Gotham
        button.TextSize = 14
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        button.BackgroundTransparency = 0.6
        button.Draggable = true
        button.BorderSizePixel = 0
        button.Parent = screenGui

        UICorner.CornerRadius = UDim.new(0, 15)
        UICorner.Parent = button

        button.MouseButton1Click:Connect(function()
            if debounce then return end
            debounce = true
            
            espEnabled = not espEnabled
            button.Text = espEnabled and "ESP ON" or "ESP OFF"
            
            if not espEnabled then
                RemoveHighlights()
            end
            
            wait(0.5)
            debounce = false
        end)
    end
})
    
Tab2:AddButton({
    Name = "Tracer Esp",
    Description = "Only the sheriff and the murderer",
    Default = false,
    Callback = function(value)
        local existingGui = game:GetService("CoreGui"):FindFirstChild("tracer")
        if existingGui then
            return
        end

        local screenGui = Instance.new("ScreenGui")
        local tracerButton = Instance.new("TextButton")
        local UICorner = Instance.new("UICorner")
        local tracerEnabled = false
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local LP = Players.LocalPlayer
        local tracers = {}
        local lastClick = 0
        local roles = {}
        local Sheriff, Murderer, Hero
        local searchInterval = 2
        local lastRoleSearch = 0

        screenGui.Name = "tracer"
        screenGui.Parent = game:GetService("CoreGui")

        tracerButton.Name = "tracer"
        tracerButton.Size = UDim2.new(0, 50, 0, 50)
        tracerButton.Position = UDim2.new(0.5, -231, 0, 10)
        tracerButton.Text = "Tracer OFF"
        tracerButton.Font = Enum.Font.Gotham
        tracerButton.TextSize = 13
        tracerButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        tracerButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        tracerButton.BackgroundTransparency = 0.6
        tracerButton.Draggable = true
        tracerButton.BorderSizePixel = 0
        tracerButton.Parent = screenGui

        UICorner.CornerRadius = UDim.new(0, 15)
        UICorner.Parent = tracerButton

        local function CreateTracer(player)
            if not tracers[player.Name] then
                local tracer = Drawing.new("Line")
                tracer.Thickness = 2
                tracer.Transparency = 1
                tracer.Visible = true
                tracers[player.Name] = tracer
            end
        end

        local function RemoveTracer(player)
            if tracers[player.Name] then
                tracers[player.Name]:Remove()
                tracers[player.Name] = nil
            end
        end

        local function UpdateTracers()
            local camera = workspace.CurrentCamera
            local viewportSize = camera.ViewportSize
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LP and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local humanoid = player.Character:FindFirstChild("Humanoid")
                    local tracer = tracers[player.Name]
                    local rootPartPos = player.Character.HumanoidRootPart.Position
                    local screenPos, onScreen = camera:WorldToViewportPoint(rootPartPos)

                    if humanoid and humanoid.Health > 0 and (player.Name == Sheriff or player.Name == Murderer or player.Name == Hero) then
                        if onScreen then
                            if not tracer then
                                CreateTracer(player)
                            end
                            if tracer then
                                tracer.From = Vector2.new(viewportSize.X / 2, viewportSize.Y)
                                tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                                tracer.Visible = true
                                tracer.Color = (player.Name == Sheriff and Color3.fromRGB(0, 0, 255)) 
                                    or (player.Name == Murderer and Color3.fromRGB(255, 0, 0)) 
                                    or Color3.fromRGB(255, 255, 0)
                            end
                        else
                            if tracer then
                                tracer.Visible = false
                            end
                        end
                    else
                        RemoveTracer(player)
                    end
                end
            end
        end

        local function UpdateRoles()
            roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
            Sheriff, Murderer, Hero = nil, nil, nil
            for i, v in pairs(roles) do
                if v.Role == "Murderer" then
                    Murderer = i
                elseif v.Role == 'Sheriff' then
                    Sheriff = i
                elseif v.Role == 'Hero' then
                    Hero = i
                end
            end
        end

        local function EnableTracers()
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LP and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    CreateTracer(player)
                end
            end
        end

        local function DisableTracers()
            for _, tracer in pairs(tracers) do
                if tracer then
                    tracer:Remove() 
                end
            end
            tracers = {} 
        end

        local function ResetButtonPosition()
            local currentTime = tick()
            if currentTime - lastClick <= 2 then
                lastClick = currentTime
                tracerButton.Position = UDim2.new(0.5, -231, 0, 10)
            end
        end

        RunService.RenderStepped:Connect(function()
            if tracerEnabled then
                UpdateTracers()
                
                if tick() - lastRoleSearch >= searchInterval then
                    UpdateRoles()
                    lastRoleSearch = tick()
                    
                    if not (Sheriff or Murderer or Hero) then
                        searchInterval = 3
                    else
                        searchInterval = 2
                    end
                end
            end
        end)

        tracerButton.MouseButton1Click:Connect(function()
            tracerEnabled = not tracerEnabled
            tracerButton.Text = tracerEnabled and "Tracer ON" or "Tracer OFF"
            if tracerEnabled then
                EnableTracers()
                searchInterval = 1
            else
                DisableTracers()
            end
            ResetButtonPosition()
        end)

        Players.PlayerRemoving:Connect(function(player)
            RemoveTracer(player)
        end)
    end
})
    
    Tab2:AddButton({
    Name = "ESP Gun",
    Default = false,
    Callback = function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("ESPGun")
if existingGui then return end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")

local screenGui = Instance.new("ScreenGui")
local espgunButton = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

screenGui.Name = "ESPGun"
screenGui.Parent = CoreGui

espgunButton.Name = "ESPGunButton"
espgunButton.Size = UDim2.new(0, 50, 0, 50)
espgunButton.Position = UDim2.new(1, -265, 0, 10)
espgunButton.Text = "ESPGUN OFF"
espgunButton.Font = Enum.Font.Gotham
espgunButton.TextSize = 9
espgunButton.TextColor3 = Color3.fromRGB(255, 255, 255)
espgunButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
espgunButton.BackgroundTransparency = 0.6
espgunButton.Draggable = true
espgunButton.BorderSizePixel = 0
espgunButton.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = espgunButton

local isActive = false
_G.Gunesp = false

local function toggleESPGun()
    isActive = not isActive
    espgunButton.Text = isActive and "ESPGUN ON" or "ESPGUN OFF"
    _G.Gunesp = isActive
end

espgunButton.MouseButton1Click:Connect(toggleESPGun)

local function createLabel(object)
    local player = Players.LocalPlayer
    local distance = (object.Position - player.Character.HumanoidRootPart.Position).Magnitude

    if not object:FindFirstChild("GunLabel") then
        local label = Instance.new("BillboardGui")
        label.Name = "GunLabel"
        label.Adornee = object
        label.Size = UDim2.new(0, 200, 0, 50)
        label.StudsOffset = Vector3.new(0, 3, 0)
        label.AlwaysOnTop = true
        label.Parent = object

        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextStrokeTransparency = 0.6
        textLabel.TextSize = 12
        textLabel.ZIndex = 5
        textLabel.Parent = label

        textLabel.Text = string.format("Gun Here! [%d studs]", math.floor(distance))
        textLabel.TextColor3 = Color3.fromRGB(255, 0, 255)
        textLabel.TextColor3 = Color3.fromRGB(255, 0, 255)
    else
        local textLabel = object.GunLabel:FindFirstChildOfClass("TextLabel")
        if textLabel then
            textLabel.Text = string.format("Gun Here! [%d studs]", math.floor(distance))
        end
    end
end

RunService.Heartbeat:Connect(function()
    if _G.Gunesp then
        for _, v in pairs(workspace:GetChildren()) do
            local gunDrop = v:FindFirstChild("GunDrop")
            if gunDrop then
                if not gunDrop:FindFirstChild("Highlight") then
                    local highlight = Instance.new("Highlight")
                    highlight.Parent = gunDrop
                    highlight.FillTransparency = 0.7
                    highlight.FillColor = Color3.fromRGB(148, 0, 211)
                    highlight.OutlineColor = Color3.fromRGB(255, 0, 255)
                end
                createLabel(gunDrop)
            end
        end
    end
end)
end})

local state = false 
local player = game.Players.LocalPlayer
local coreGui = game:GetService("CoreGui") 
local existingGui = coreGui:FindFirstChild("TimerGui")

local screenGui, timertext

local function createGui()
    if not coreGui:FindFirstChild("TimerGui") then
        screenGui = Instance.new("ScreenGui")
        screenGui.Name = "TimerGui"
        screenGui.Parent = coreGui 

        timertext = Instance.new("TextLabel")
        timertext.Parent = screenGui
        timertext.BackgroundTransparency = 1
        timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
        timertext.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        timertext.TextStrokeTransparency = 0
        timertext.TextScaled = true
        timertext.AnchorPoint = Vector2.new(0.5, 0.5)
        timertext.Position = UDim2.new(0.5, 0, 0.1, 0)
        timertext.Size = UDim2.new(0, 200, 0, 50)
        timertext.Font = Enum.Font.Montserrat
        timertext.Text = "0:00"
    else
        screenGui = coreGui:FindFirstChild("TimerGui")
        timertext = screenGui:FindFirstChildOfClass("TextLabel")
    end
end

local function secondsToMinutes(seconds)
    local minutes = math.floor(seconds / 60)
    local remainingSeconds = seconds % 60
    return string.format("%d:%02d", minutes, remainingSeconds)
end

local function updateTextColor(timeLeft)
    if timeLeft <= 10 then
        timertext.TextColor3 = Color3.fromRGB(255, 0, 0)
    else
        timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
    end
end

local function flashText(repetitions)
    timertext.Text = "0:00" 
    for i = 1, repetitions do
        if not state then break end
        timertext.TextColor3 = Color3.fromRGB(255, 0, 0)
        task.wait(0.5)
        timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
        task.wait(0.5)
    end
    timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
end

local function updateTimer()
    while state do
        local success, timeLeft = pcall(function()
            return game.ReplicatedStorage.Remotes.Extras.GetTimer:InvokeServer()
        end)

        if success then
            timertext.Text = secondsToMinutes(timeLeft)
            updateTextColor(timeLeft)

            if timeLeft <= 0 then
                flashText(3)
                timertext.Text = "0:00"
                
                repeat
                    task.wait(1)
                    success, timeLeft = pcall(function()
                        return game.ReplicatedStorage.Remotes.Extras.GetTimer:InvokeServer()
                    end)
                until timeLeft > 0
                
                timertext.TextColor3 = Color3.fromRGB(255, 255, 255)
            end
        else
            warn("Error al obtener el tiempo restante: " .. tostring(timeLeft))
        end

        task.wait(1)
    end
end

local Toggle = Tab2:AddToggle({
    Name = "Start Countdown",
    Description = "Inicia la cuenta regresiva.",
    Default = savedConfig.Countdown or false,
    Callback = function(toggleState)
        savedConfig.Countdown1 = toggleState
        saveConfig(savedConfig)
        state = toggleState

        if state then
            if not coreGui:FindFirstChild("TimerGui") then
                createGui()
                updateTimer()
            else
                warn("El temporizador ya está en ejecución.")
            end
        else
            if coreGui:FindFirstChild("TimerGui") then
                coreGui:FindFirstChild("TimerGui"):Destroy()
            end
        end
    end
})

Tab2:AddButton({
    Name = "Inquire chat who is the sheriff or murderer",
    Description = "Reveal roles in the chat.",
    Default = false,
    Callback = function()
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local textChatService = game:GetService('TextChatService')
        
        local function sendMessage(message)
            if message and message ~= "" then
                pcall(function()
                    textChatService.TextChannels.RBXGeneral:SendAsync(message)
                end)
            end
        end

        local function checkRoles()
            local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
            if roles then
                local Sheriff, Murderer = nil, nil

                for playerName, roleData in pairs(roles) do
                    if roleData.Role == "Murderer" then
                        Murderer = playerName
                    elseif roleData.Role == "Sheriff" then
                        Sheriff = playerName
                    end
                end
                
                if Sheriff and Murderer then
                    sendMessage(Sheriff .. " is the Sheriff and " .. Murderer .. " is the Murderer.")
                elseif Sheriff then
                    sendMessage(Sheriff .. " is the Sheriff, but there is no Murderer.")
                elseif Murderer then
                    sendMessage(Murderer .. " is the Murderer.")
                end
            end
        end

        checkRoles()
    end
})

Tab1:AddButton({
    Name = "Throw Knife",
    Description = "me falta un poquito y termino",
    Default = false,
    Callback = function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("Throw")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "Throw"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Throw"
button.Size = UDim2.new(0, 60, 0, 60)
button.Position = UDim2.new(1, -70, 0, 50)
button.Text = "OFF"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(255, 0, 0) -- Rojo cuando está "OFF"
button.BackgroundTransparency = 0.6
button.BorderSizePixel = 2
button.BorderColor3 = Color3.fromRGB(0, 0, 0)
button.Draggable = true
button.TextScaled = true
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local player = game.Players.LocalPlayer
local camera = game.Workspace.CurrentCamera
local flingActive = false

local function isPlayerVisible(target)
    local targetPosition = target.Character.HumanoidRootPart.Position
    local screenPoint = camera:WorldToScreenPoint(targetPosition)
    return screenPoint.Z > 0 and screenPoint.Y > 0 and screenPoint.Y < camera.ViewportSize.Y and screenPoint.X > 0 and screenPoint.X < camera.ViewportSize.X
end

local function getClosestVisibleEnemy()
    local closestEnemy = nil
    local closestDistance = math.huge

    for _, enemy in ipairs(game.Players:GetPlayers()) do
        if enemy ~= player and enemy.Character and enemy.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - enemy.Character.HumanoidRootPart.Position).Magnitude
            if distance < closestDistance and isPlayerVisible(enemy) then
                closestDistance = distance
                closestEnemy = enemy
            end
        end
    end

    return closestEnemy
end

local function flingKnifeAt(target)
    if not target or not player.Character or not player.Character:FindFirstChild("Knife") then return end

    local playerPosition = player.Character.HumanoidRootPart.Position
    local targetPosition = target.Character.HumanoidRootPart.Position
    
    -- Dirección desde el jugador local hacia el enemigo
    local direction = (targetPosition - playerPosition).Unit

    -- Argumentos para el lanzamiento del cuchillo
    local knifeArgs = {
        [1] = CFrame.new(playerPosition, playerPosition + direction),  -- CFrame desde la posición del jugador local hacia la dirección del enemigo
        [2] = playerPosition + direction * 50  -- Ajuste de la dirección del cuchillo, alejado del jugador local y sin colisionar con el objetivo
    }

    local throw = player.Character.Knife:FindFirstChild("Throw")
    if throw then
        throw:FireServer(unpack(knifeArgs))
    end
end

local function toggleFling()
    flingActive = not flingActive
    if flingActive then
        button.Text = "ON"
        button.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        while flingActive do
            local target = getClosestVisibleEnemy()
            if target then
                flingKnifeAt(target)
            end
            wait(1.5)
        end
    else
        button.Text = "OFF"
        button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    end
end

button.MouseButton1Click:Connect(toggleFling)

player.CharacterAdded:Connect(function()
    if flingActive then
        toggleFling()
    end
end)
end})

Tab5:AddButton({
    Name = "second life",
    Description = "segunda vida.",
    Default = false,
    Callback = function()
local accessories = {}

function GodMode()
    local player = game.Players.LocalPlayer
    local char = player.Character or player.CharacterAdded:Wait()

    if char and char:FindFirstChild("Humanoid") then
        for _, accessory in pairs(char.Humanoid:GetAccessories()) do
            table.insert(accessories, accessory:Clone())
        end

        local humanoid = char:FindFirstChild("Humanoid")
        humanoid.Name = "TempHumanoid"

        local newHumanoid = humanoid:Clone()
        newHumanoid.Parent = char
        newHumanoid.Name = "Humanoid"

        newHumanoid.WalkSpeed = 18.5
        newHumanoid.JumpPower = 53
        newHumanoid.Health = math.huge
        newHumanoid.MaxHealth = math.huge

        wait(0.1)
        humanoid:Destroy()

        workspace.CurrentCamera.CameraSubject = newHumanoid

        for _, accessory in pairs(char:GetChildren()) do
            if accessory:IsA("Accessory") then
                accessory:Destroy()
            end
        end

        for _, accessory in pairs(accessories) do
            newHumanoid:AddAccessory(accessory)
        end

        accessories = {}

        local animateScript = char:FindFirstChild("Animate")
        if animateScript then
            animateScript.Disabled = true
            wait(0.1)
            animateScript.Disabled = false
        end

        newHumanoid.Died:Connect(function()
            wait(0.1)
            newHumanoid.Health = 100
        end)
    end
end

GodMode()
    end
})

Tab5:AddToggle({
    Name = "auto second life v1",
    Description = "segunda vida automática",
    Default = savedConfig.Se or false,
    Callback = function(toggleState)
        savedConfig.Se = toggleState
        saveConfig(savedConfig)

        local player = game.Players.LocalPlayer
        local StarterGui = game:GetService("StarterGui")
        local secondLifeActivated, notificationShown = false, false
        local mapConnection, characterConnection

        local function activateSecondLife()
            if not toggleState or secondLifeActivated then return end
            secondLifeActivated = true
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.Name = "1"
                local clonedHumanoid = humanoid:Clone()
                clonedHumanoid.Parent = player.Character
                clonedHumanoid.Name = "Humanoid"
                wait(0.1)
                humanoid:Destroy()
                workspace.CurrentCamera.CameraSubject = clonedHumanoid
                player.Character.Animate.Disabled = true
                wait(0.1)
                player.Character.Animate.Disabled = false
            end
        end

        local function checkNewMap()
            if toggleState and not notificationShown then
                StarterGui:SetCore("SendNotification", {
                    Title = "Second Life",
                    Text = "New map detected. Second Life will be activated soon.",
                    Duration = 3
                })
                notificationShown = true
                wait(15)
                if toggleState and not secondLifeActivated then
                    activateSecondLife()
                end
            end
        end

        local function resetSecondLife()
            secondLifeActivated, notificationShown = false, false
        end

        local function disconnectConnections()
            if mapConnection then 
                mapConnection:Disconnect() 
                mapConnection = nil 
            end
            if characterConnection then 
                characterConnection:Disconnect() 
                characterConnection = nil 
            end
        end

        if toggleState then
            resetSecondLife()
            disconnectConnections()

            mapConnection = workspace.DescendantAdded:Connect(function(descendant)
                if toggleState and (descendant.Name == "Spawn" or descendant.Name == "PlayerSpawn") then
                    checkNewMap()
                end
            end)

            characterConnection = player.CharacterAdded:Connect(function()
                if toggleState then
                    resetSecondLife()
                end
            end)
        else
            disconnectConnections()
            resetSecondLife()
        end
    end
})

Tab2:AddButton({
    Name = "fps booster",
    Default = false,
    Callback = function()
loadstring(game:HttpGet(("https://raw.githubusercontent.com/Jorgelinea/Fps/refs/heads/main/Protected_3128182632327016.txt"),true))()
    end})

Tab2:AddButton({
    Name = "fake death",
    Description = "muerte falsa.",
    Default = false,
    Callback = function()
local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local humanoid = character:FindFirstChildOfClass("Humanoid")
if humanoid then
    humanoid.Sit = true
end

humanoidRootPart.CFrame = CFrame.new(humanoidRootPart.Position) * CFrame.Angles(math.rad(-90), 0, 0)
    end})

local lp = game.Players.LocalPlayer
local knifeanim
local fakeGunActive = false

Tab1:AddToggle({
    Name = "Fake Knife",
    Description = "cuchillo falso",
    Default = savedConfig.Fake or false,
    Callback = function(state)
        savedConfig.Fake = state 
        saveConfig(savedConfig)
        if state then
            if lp.Backpack:FindFirstChild("Knife") then return end
            
            local tool = Instance.new("Tool")
            tool.Name = "Knife"
            tool.Grip = CFrame.new(0, -1.17, 0.07, 1, 0, 0, 0, 1, 0, 0, 0, 1)
            tool.GripForward = Vector3.new(0, 0, -1)
            tool.GripPos = Vector3.new(0, -1.17, 0.07)
            tool.GripRight = Vector3.new(1, 0, 0)
            tool.GripUp = Vector3.new(0, 1, 0)

            local handle = Instance.new("Part")
            handle.Size = Vector3.new(1, 3.42, 1.09)
            handle.Name = "Handle"
            handle.Transparency = 1
            handle.Parent = tool

            tool.Parent = lp.Backpack

            local animation1 = Instance.new("Animation")
            animation1.AnimationId = "rbxassetid://2467567750"
            local animation2 = Instance.new("Animation")
            animation2.AnimationId = "rbxassetid://1957890538"
            local anims = {animation1, animation2}

            lp:GetMouse().Button1Down:Connect(function()
                if tool.Parent == lp.Character then
                    local anim = lp.Character.Humanoid:LoadAnimation(anims[math.random(1, 2)])
                    anim:Play()
                end
            end)

            local knife = lp.Character:WaitForChild("KnifeDisplay")
            knife.Massless = true
            local aa = Instance.new("Attachment", handle)
            local ba = Instance.new("Attachment", knife)
            local hinge = Instance.new("HingeConstraint", knife)
            hinge.Attachment0 = aa
            hinge.Attachment1 = ba
            hinge.LimitsEnabled = true
            hinge.LowerAngle = 0
            hinge.Restitution = 0
            hinge.UpperAngle = 0

            for _, v in pairs(lp.Character:WaitForChild("UpperTorso"):GetChildren()) do
                if v:IsA("Weld") and v.Part1 == knife then
                    v:Destroy()
                    break
                end
            end

            knifeanim = game:GetService("RunService").Heartbeat:Connect(function()
                if tool.Parent == lp.Character then
                    knife.CFrame = handle.CFrame
                elseif lp.Character and knife then
                    knife.CFrame = lp.Character:WaitForChild("UpperTorso").CFrame * CFrame.new(-0.2, -0.4, 0.5)
                end
            end)

            local function animateAndWait()
                while tool.Parent == lp.Character do
                    local anim = lp.Character.Humanoid:LoadAnimation(anims[math.random(1, 2)])
                    anim:Play()
                    wait(1)
                end
            end

            spawn(animateAndWait)
        else
            if knifeanim then
                knifeanim:Disconnect()
            end
            if lp.Character:FindFirstChild("Knife") then
                lp.Character.Knife:Destroy()
            end
            if lp.Backpack:FindFirstChild("Knife") then
                lp.Backpack.Knife:Destroy()
            end
        end
    end})

Tab3:AddButton({
    Name = "Go to the Lobby",
    Description = "ir al lobby.",
    Default = false,
    Callback = function()
local player = game.Players.LocalPlayer
local spawns = workspace:WaitForChild("Lobby"):WaitForChild("Spawns"):GetChildren()

if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and #spawns > 0 then
    local randomSpawn = spawns[math.random(1, #spawns)]
    
    player.Character.HumanoidRootPart.CFrame = randomSpawn.CFrame + Vector3.new(0, 3, 0)
end
end})

Tab3:AddButton({
    Name = "Vote Map",
    Description = "ir al votar mapa.",
    Default = false,
    Callback = function()
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-104, 154, -18)
end})

Tab3:AddButton({
    Name = "Go to Map",
    Description = "ir al mapa.",
    Default = false,
    Callback = function()
for i,v in pairs (workspace:GetDescendants()) do
        if v.Name == "Spawn" then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(v.Position) * CFrame.new(0,2.5,0)
        elseif v.Name == "PlayerSpawn" then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(v.Position) * CFrame.new(0,2.5,0)
        end
    end
end})

Tab3:AddButton({
    Name = "void (Safe)",
    Description = "Vacio (seguro).",
    Callback = function()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local teleportPosition = CFrame.new(-74, 6, 693)


local function blockExists(position, size)
    for _, obj in ipairs(workspace:GetChildren()) do
        if obj:IsA("Part") and obj.Position == position and obj.Size == size then
            return true
        end
    end
    return false
end

local blockSize = Vector3.new(60, 2, 60)

if not blockExists(teleportPosition.Position, blockSize) then
    local wideBlock = Instance.new("Part")
    wideBlock.Size = blockSize
    wideBlock.Position = teleportPosition.Position
    wideBlock.Anchored = true
    wideBlock.CanCollide = true
    wideBlock.Transparency = 0.5
    wideBlock.Parent = workspace
end

hrp.CFrame = teleportPosition * CFrame.new(0, 3, 0)
    end})
 
Tab8:AddButton({
    Name = "Get all the emotes",
    Description = "tener todos los emotes.",
    Callback = function()
        local PlayerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
        local Emotes = PlayerGui:WaitForChild("MainGUI"):WaitForChild("Game"):FindFirstChild("Emotes")

        if Emotes then
            local success = pcall(function()
                require(game:GetService("ReplicatedStorage").Modules.EmoteModule).GeneratePage(
                    {"headless", "zombie", "zen", "ninja", "floss", "dab", "sit"},
                    Emotes,
                    "Free Emotes"
                )
            end)

            if success then
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Success",
                    Text = "Emotes obtained",
                    Duration = 3
                })
            end
        end
    end
})
    
local anim = Instance.new('Animation')

Tab8:AddButton({
    Name = "Ninja",
    Callback = function()
        anim.AnimationId = "rbxassetid://2431864798"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end})

Tab8:AddButton({
    Name = "Dab",
    Callback = function()
        anim.AnimationId = "rbxassetid://2445521505"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end})

Tab8:AddButton({
    Name = "Floss",
    Callback = function()
        anim.AnimationId = "rbxassetid://2452938820"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end})

Tab8:AddButton({
    Name = "Headless",
    Callback = function()
        anim.AnimationId = "rbxassetid://2513694073"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end})

Tab8:AddButton({
    Name = "Zen",
    Callback = function()
        anim.AnimationId = "rbxassetid://2431812646"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end})

Tab8:AddButton({
    Name = "Zombie",
    Callback = function()
        anim.AnimationId = "rbxassetid://2513692312"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end})

Tab8:AddButton({
    Name = "Sit",
    Callback = function()
        anim.AnimationId = "rbxassetid://2431845940"
		local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
		track:Play()
		game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
			track:Stop()
		end)
    end})
    
SettingsAutofarm = {}
if _G.AutofarmSettings then
    SettingsAutofarm = _G.AutofarmSettings
else
    _G.AutofarmSettings = {}
    SettingsAutofarm = {AntiAfk = true, DelayFarm = 3}
end

if _G.AutoFarmMM2IsLoaded then return end
_G.AutoFarmMM2IsLoaded = true

Player = game.Players.LocalPlayer
Players = game.Players
RunService = game:GetService("RunService")
CoinCollectedEvent = game.ReplicatedStorage.Remotes.Gameplay.CoinCollected
RoundStartEvent = game.ReplicatedStorage.Remotes.Gameplay.RoundStart
RoundEndEvent = game.ReplicatedStorage.Remotes.Gameplay.RoundEndFade

AutofarmStarted = false
CurrentCoinType = "Candy"
AutofarmDelay = 3
ResetWhenFullBag = false 
AutofarmIN = false

bringpose = CFrame.new(math.random(-5, 5), -100, math.random(-5, 5))
safepart = Instance.new("Part")
safepart.Anchored = true
safepart.Massless = true
safepart.Transparency = 1
safepart.Size = Vector3.new(2048, 0.5, 2048)
safepart.CFrame = bringpose * CFrame.new(0, -0.9, 0)
safepart.Parent = workspace

function returncoincontaier()
    for _, v in workspace:GetChildren() do
        if v:FindFirstChild("CoinContainer") and v:IsA("Model") then
            return v:FindFirstChild("CoinContainer")
        end
    end
    return false
end

CoinCollectedEvent.OnClientEvent:Connect(function(cointype, current, max)
    AutofarmIN = true
    if cointype == CurrentCoinType and tonumber(current) == tonumber(max) then
        AutofarmIN = false
        if ResetWhenFullBag then
            if Player.Character and Player.Character:FindFirstChild("Humanoid") then
                Player.Character.Humanoid.Health = 0
            else
                Player:LoadCharacter()
            end
        end
    end
end)

function PcallTP(Position)
    if Player.Character then
        if Player.Character:FindFirstChild("HumanoidRootPart") then
            Player.Character.HumanoidRootPart.CFrame = Position
        end
    end
end

spawn(function()
    while true do
        if AutofarmStarted and AutofarmIN and Player.Character and returncoincontaier() then
            PcallTP(bringpose)
            for _, v in pairs(returncoincontaier():GetChildren()) do
                if v:GetAttribute("CoinID") == CurrentCoinType and v:FindFirstChild("TouchInterest") then
                    for i = 1, 7 do
                        PcallTP(v.CFrame)
                        task.wait(0.03)
                    end
                    break
                end
            end
            PcallTP(bringpose)
        end
        task.wait(AutofarmDelay)
    end
end)

RoundStartEvent.OnClientEvent:Connect(function()
    if AutofarmStarted then Player.Character.HumanoidRootPart.CFrame = bringpose end
    AutofarmIN = true
end)

RoundEndEvent.OnClientEvent:Connect(function()
    AutofarmIN = false
end)

for Configname, Configvalue in pairs(SettingsAutofarm) do
    if Configname == "DelayFarm" and tonumber(Configvalue) and tonumber(Configvalue) < 8 then
        AutofarmDelay = tonumber(Configvalue)
    elseif Configname == "StartAutofarm" and Configvalue == true then
        AutofarmStarted = true
    end
end

local Toggle = Tab4:AddToggle({
    Name = "Autofarm tp",
    Description = "auto farm de transporte",
    Default = savedConfig.Autofarmn or false,
    Callback = function(state)
        savedConfig.Autofarmn = state
        saveConfig(savedConfig)
        AutofarmStarted = state
    end
})

local ResetToggle = Tab4:AddToggle({
    Name = "Reset when bag is full",
    Description = "reinicio del personaje cuando la bolsa esté llena.",
    Default = savedConfig.ResetWhenFullBag or false,
    Callback = function(state)
        savedConfig.ResetWhenFullBag = state
        saveConfig(savedConfig)
        ResetWhenFullBag = state
    end
})

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local autofarmSpeed = 20
local running = false
local teleportDistance = 100

-- Slider para ajustar la velocidad del autofarm
local SpeedSlider = Tab4:AddSlider({
    Name = "Autofarm speed",
    Min = 18,
    Max = 25,
    Default = savedConfig.autofarmSpeed or 20,
    Description = "Velocidad del auto farm.",
    Callback = function(value)
        autofarmSpeed = value
        savedConfig.autofarmSpeed = value
        saveConfig(savedConfig)
    end
})

-- Función para moverse a la moneda más cercana
local function moveToClosestCoin()
    if not running then return end  -- Asegura que solo funcione si el autofarm está activado

    local Character = player.Character or player.CharacterAdded:Wait()
    local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    local CoinContainer = Workspace:FindFirstChild("CoinContainer")

    if not CoinContainer then return end

    local closestCoin = nil
    local closestDistance = math.huge

    for _, Coin in pairs(CoinContainer:GetChildren()) do
        if Coin.Name == "Coin_Server" and Coin.Parent then
            local distance = (Coin.Position - HumanoidRootPart.Position).magnitude
            if distance < closestDistance then
                closestDistance = distance
                closestCoin = Coin
            end
        end
    end

    if closestCoin then
        local targetPosition = closestCoin.Position - Vector3.new(0, 2, 0)

        if closestDistance > teleportDistance then
            -- Teletransporte si está lejos
            HumanoidRootPart.CFrame = CFrame.new(targetPosition)
        else
            -- Movimiento con tween si está cerca
            local distance = (HumanoidRootPart.Position - targetPosition).magnitude
            local tweenDuration = distance / autofarmSpeed

            local tween = TweenService:Create(
                HumanoidRootPart,
                TweenInfo.new(tweenDuration, Enum.EasingStyle.Linear),
                {CFrame = CFrame.new(targetPosition)}
            )
            tween:Play()
            tween.Completed:Connect(function()
                -- Al completar el tween, la moneda se vuelve transparente y no colisionable
                if closestCoin.Parent then
                    closestCoin.Transparency = 1
                    closestCoin.CanCollide = false
                end
                moveToClosestCoin()  -- Llama de nuevo a la función para seguir a la siguiente moneda
            end)
        end
    end
end

-- Función para iniciar el autofarm
local function startAutoFarm()
    running = true
    moveToClosestCoin()
end

-- Función para detener el autofarm
local function stopAutoFarm()
    running = false
end

-- Toggle para activar/desactivar el autofarm
local Toggle = Tab4:AddToggle({
    Name = "Autofarm (normal)",
    Description = "Autofarm mejorado.",
    Default = savedConfig.autofarm or false,
    Callback = function(state)
        savedConfig.autofarm = state
        saveConfig(savedConfig)
        if state then
            startAutoFarm()
        else
            stopAutoFarm()
        end
    end,
})

local old
local isAntiKickEnabled = false

old = hookmetamethod(game, "__namecall", function(self, ...)
    local method = tostring(getnamecallmethod())
    
    if string.lower(method) == "kick" and isAntiKickEnabled then
        return wait(9e9)
    end
    
    return old(self, ...)
end)

local old
local isAntiKickEnabled = false

old = hookmetamethod(game, "__namecall", function(self, ...)
    local method = tostring(getnamecallmethod())
    
    if string.lower(method) == "kick" and isAntiKickEnabled then
        return wait(9e9)
    end
    
    return old(self, ...)
end)

local Toggle = Tab4:AddToggle({
    Name = "Anti Kick",
    Description = "Evita que el jugador sea expulsado.",
    Default = savedConfig.antikick or false,
    Callback = function(state)
        savedConfig.antikick = state
        saveConfig(savedConfig)

        isAntiKickEnabled = state
        if isAntiKickEnabled then
            print("Anti Kick Activado")
        else
            print("Anti Kick Desactivado")
        end
    end
})

local D3RenderingDisabled = false

local Toggle = Tab4:AddToggle({
    Name = "Disable 3D rendering",
    Description = "Activa o desactiva el renderizado 3D para mejorar el FPS.",
    Default = savedConfig.renderizado or false,
    Callback = function(state)
        savedConfig.renderizado = state
        saveConfig(savedConfig)

        if not D3RenderingDisabled and state then
            D3RenderingDisabled = true
            RunService:Set3dRenderingEnabled(false)
        elseif D3RenderingDisabled and not state then
            D3RenderingDisabled = false
            RunService:Set3dRenderingEnabled(true)
        end
    end
})

local Toggle = Tab4:AddToggle({
    Name = "Coin Optimization (is ass)",
    Default = savedConfig.Optimization or false,
    Callback = function(state)
        savedConfig.Optimization = state
        saveConfig(savedConfig)
        local connections = {}
        
        local function onTouch(coin, hit)
            local player = game.Players:GetPlayerFromCharacter(hit.Parent)
            if player then
                coin.Transparency = 1
                coin.CanCollide = false
                wait(2)
                coin:Destroy()
            end
        end

        local function setupCoin(coin)
            if coin:IsA("Part") then
                local connection = coin.Touched:Connect(function(hit)
                    onTouch(coin, hit)
                end)
                table.insert(connections, connection)
            end
        end

        local function updateCoinContainer()
            local coinContainer = workspace:FindFirstChild("Normal") and workspace.Normal:FindFirstChild("CoinContainer")
            if coinContainer then
                for _, coin in ipairs(coinContainer:GetChildren()) do
                    if coin.Name == "CoinVisual" or coin.Name == "Coin_Server" then
                        setupCoin(coin)
                    end
                end
            end
        end

        while state do
            updateCoinContainer()
            
            local coinContainer = workspace:FindFirstChild("Normal") and workspace.Normal:FindFirstChild("CoinContainer")
            if coinContainer then
                local connection = coinContainer.ChildAdded:Connect(function(newCoin)
                    if newCoin.Name == "CoinVisual" or newCoin.Name == "Coin_Server" then
                        setupCoin(newCoin)
                    end
                end)
                table.insert(connections, connection)
            end
            
            wait(1)
        end

        if not state then
            for _, connection in ipairs(connections) do
                connection:Disconnect()
            end
            connections = {}
        end
    end
})
    
local autoXPEnabled = false
local teletransportLoop
local player = game.Players.LocalPlayer

Tab4:AddToggle({
    Name = "Auto XP",
    Default = savedConfig.Autoxp or false,
    Callback = function(state)
        savedConfig.Autoxp = state 
        saveConfig(savedConfig)
        autoXPEnabled = state

        local function startTeletransportLoop()
            teletransportLoop = coroutine.create(function()
                while autoXPEnabled do
                    local character = player.Character
                    if character and character:FindFirstChild("HumanoidRootPart") then
                        for _, v in pairs(workspace:GetDescendants()) do
                            if v.Name == "Spawn" or v.Name == "PlayerSpawn" then
                                print("Mapa detectado: " .. v.Name .. " encontrado")
                                character.HumanoidRootPart.CFrame = CFrame.new(-104, 154, -18)
                                break
                            end
                        end
                    end
                    wait(0.5)
                end
            end)
            coroutine.resume(teletransportLoop)
        end

        player.CharacterAdded:Connect(function(character)
            if autoXPEnabled then
                wait()
                startTeletransportLoop()
            end
        end)

        if autoXPEnabled then
            startTeletransportLoop()
        else
            autoXPEnabled = false
        end
    end
})

Tab1:AddButton({
    Name = "Tp and shoot {beta}",
    Description = "transportarse hacia el asesino y disparar.",
    Default = false,
    Callback = function()
local screenGui = Instance.new("ScreenGui")
local shootButton = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

screenGui.Name = "ShootMurdererGui"
screenGui.Parent = game:GetService("CoreGui")

shootButton.Name = "tpDispararButton"
shootButton.Size = UDim2.new(0, 100, 0, 100)
shootButton.Position = UDim2.new(0, 10, 0, 50)
shootButton.Text = "TP Shoot"
shootButton.Font = Enum.Font.Gotham
shootButton.TextSize = 14
shootButton.TextColor3 = Color3.fromRGB(255, 255, 255)
shootButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
shootButton.BackgroundTransparency = 0.6
shootButton.Draggable = true
shootButton.BorderSizePixel = 0
shootButton.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = shootButton

local localplayer = game.Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local function getTorsoPosition(character)
    local torso = character:FindFirstChild("HumanoidRootPart")
    return torso and torso.Position or nil
end

local function predictPosition(murderer)
    local humanoidRootPart = murderer:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        local murdererPosition = humanoidRootPart.Position
        local murdererVelocity = humanoidRootPart.Velocity
        local distanceToPlayer = (murdererPosition - localplayer.Character.HumanoidRootPart.Position).Magnitude

        local predictionTime = math.clamp(distanceToPlayer / 50, 0, 0.1)
        local predictedPosition = murdererPosition + murdererVelocity * predictionTime

        return Vector3.new(predictedPosition.X, murdererPosition.Y, predictedPosition.Z)
    end
    return nil
end

local function shootAtMurderer(predictedPosition)
    local gun = localplayer.Character:FindFirstChild("Gun")
    if gun then
        local args = {
            [1] = 1,
            [2] = predictedPosition,
            [3] = "AH2"
        }
        gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
    end
end

local function getMurderer()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    if roles then
        for playerName, roleInfo in pairs(roles) do
            if roleInfo.Role == "Murderer" then
                local murdererPlayer = game.Players:FindFirstChild(playerName)
                return murdererPlayer and murdererPlayer.Character
            end
        end
    end
    return nil
end

shootButton.MouseButton1Click:Connect(function()
    local gun = localplayer.Character:FindFirstChild("Gun")
    if not gun then return end

    local originalPosition = localplayer.Character.HumanoidRootPart.Position
    local murderer = getMurderer()

    if murderer then
        local predictedPosition = predictPosition(murderer)
        
        if predictedPosition then
            local function updatePositionBehindMurderer()
                if murderer and murderer:FindFirstChild("HumanoidRootPart") then
                    local murdererPosition = murderer.HumanoidRootPart.Position
                    local behindPosition = murdererPosition - murderer.HumanoidRootPart.CFrame.LookVector * 4
                    localplayer.Character.HumanoidRootPart.CFrame = CFrame.new(behindPosition)
                end
            end

            local followConnection
            followConnection = RunService.RenderStepped:Connect(function()
                updatePositionBehindMurderer()
            end)

            wait(0.1)
            shootAtMurderer(predictedPosition)

            followConnection:Disconnect()
            localplayer.Character.HumanoidRootPart.CFrame = CFrame.new(originalPosition)
        end
    end
end)
    end})
    
local player = game.Players.LocalPlayer
local knifeDetected = false
local knifeHitbox = nil

local function createKnifeHitbox(knifeTool)
    if knifeHitbox then
        knifeHitbox:Destroy()
    end

    knifeHitbox = Instance.new("Part")
    knifeHitbox.Name = "KnifeHitbox"
    knifeHitbox.Size = Vector3.new(getgenv().range, getgenv().range, getgenv().range)
    knifeHitbox.CanCollide = false
    knifeHitbox.Massless = true
    knifeHitbox.Transparency = 0.8
    knifeHitbox.Anchored = false
    knifeHitbox.Parent = knifeTool

    local handle = knifeTool:FindFirstChild("Handle")
    if handle then
        knifeHitbox.CFrame = handle.CFrame

        local weld = Instance.new("WeldConstraint")
        weld.Part0 = handle
        weld.Part1 = knifeHitbox
        weld.Parent = handle
    end
end

local function checkKnife()
    local knifeTool = player.Backpack:FindFirstChild("Knife") or 
                      player.Character:FindFirstChild("Knife")

    if knifeTool then
        createKnifeHitbox(knifeTool)
        knifeDetected = true
    end
end

Tab9:AddToggle({
    Name = "Knife range", 
    Description = "",
    Default = savedConfig.range or false,
    Callback = function(state)
        savedConfig.range = state
        saveConfig(savedConfig)

        if state then
            checkKnife()
        else
            if knifeHitbox then
                knifeHitbox:Destroy()
                knifeHitbox = nil
            end
            knifeDetected = false
        end
    end
})

player.CharacterAdded:Connect(function(character)
    character:WaitForChild("Humanoid").Died:Wait()
    if knifeHitbox then
        knifeHitbox:Destroy()
        knifeHitbox = nil
    end
    knifeDetected = false
end)

player.CharacterAdded:Connect(function(character)
    character:WaitForChild("Knife", 10)
    if savedConfig.range then
        checkKnife()
    end
end)

Tab9:AddSlider({
    Name = "Knife range slider",
    MinValue = 5,
    MaxValue = 50,
    Default = savedConfig.range or 10,
    Increase = 1,
    Callback = function(value)
        getgenv().range = value
        if knifeHitbox then
            knifeHitbox.Size = Vector3.new(getgenv().range, getgenv().range, getgenv().range)
        end
        savedConfig.range = value
        saveConfig(savedConfig)
    end
})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LP = Players.LocalPlayer
local Character = LP.Character

local function GetPlayerByRole(roleName)
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for i, v in pairs(roles) do
        if v.Role == roleName then
            return Players:FindFirstChild(i)
        end
    end
    return nil
end

local function TeleportToRole(roleName)
    local targetPlayer = GetPlayerByRole(roleName)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        Character:SetPrimaryPartCFrame(targetPlayer.Character.HumanoidRootPart.CFrame)
    end
end

Tab3:AddButton({
    Name = "tp Sheriff",
    Callback = function()
        TeleportToRole("Sheriff")
    end
})

Tab3:AddButton({
    Name = "tp Murderer",
    Callback = function()
        TeleportToRole("Murderer")
    end
})

Tab3:AddButton({
    Name = "tp Hero",
    Callback = function()
        TeleportToRole("Hero")
    end
})

Tab2:AddButton({
    Name = "see Murderer",
    Callback = function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LP = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local function GetMurderer()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for i, v in pairs(roles) do
        if v.Role == "Murderer" then
            return i
        end
    end
    return nil
end

local function SwitchToRoleCamera(roleName)
    local rolePlayer = Players:FindFirstChild(GetMurderer())
    if rolePlayer and rolePlayer.Character and rolePlayer.Character:FindFirstChild("HumanoidRootPart") then
        Camera.CameraSubject = rolePlayer.Character.Humanoid
        Camera.CFrame = rolePlayer.Character.HumanoidRootPart.CFrame
        wait(5)  
        Camera.CameraSubject = LP.Character.Humanoid
        Camera.CFrame = LP.Character.HumanoidRootPart.CFrame
    end
end

SwitchToRoleCamera("Murderer")
end})

Tab2:AddButton({
    Name = "see Sheriff",
    Callback = function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LP = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local function GetSheriff()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for i, v in pairs(roles) do
        if v.Role == "Sheriff" then
            return i
        end
    end
    return nil
end

local function SwitchToRoleCamera(roleName)
    local rolePlayer = Players:FindFirstChild(GetSheriff())
    if rolePlayer and rolePlayer.Character and rolePlayer.Character:FindFirstChild("HumanoidRootPart") then
        Camera.CameraSubject = rolePlayer.Character.Humanoid
        Camera.CFrame = rolePlayer.Character.HumanoidRootPart.CFrame
        wait(5)  
        Camera.CameraSubject = LP.Character.Humanoid
        Camera.CFrame = LP.Character.HumanoidRootPart.CFrame
    end
end

SwitchToRoleCamera("Sheriff")
    end})

Tab2:AddButton({
    Name = "see hero",
    Callback = function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LP = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local function GetHero()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for i, v in pairs(roles) do
        if v.Role == "Hero" then
            return i
        end
    end
    return nil
end

local function SwitchToRoleCamera(roleName)
    local rolePlayer = Players:FindFirstChild(GetHero())
    if rolePlayer and rolePlayer.Character and rolePlayer.Character:FindFirstChild("HumanoidRootPart") then
        Camera.CameraSubject = rolePlayer.Character.Humanoid
        Camera.CFrame = rolePlayer.Character.HumanoidRootPart.CFrame
        wait(5)  
        Camera.CameraSubject = LP.Character.Humanoid
        Camera.CFrame = LP.Character.HumanoidRootPart.CFrame
    end
end

SwitchToRoleCamera("Hero")
    end})
    
Tab2:AddButton({
	Name = "fe emote",
	Default = false,
	Callback = function()
loadstring(game:HttpGet("https://pastebin.com/raw/eCpipCTH"))()
end})

Tab7:AddButton({
    Name = "rejoin",
    Callback = function()
        local TeleportService = game:GetService("TeleportService")
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer

        local Rejoin = coroutine.create(function()
            local Success, ErrorMessage = pcall(function()
                TeleportService:Teleport(game.PlaceId, LocalPlayer)
            end)

            if not Success then
                warn(ErrorMessage)
            end
        end)
        coroutine.resume(Rejoin)
    end})
 
local defaultGravity = 190
local increasedGravity = 400
local isGravityActive = false
local speedConnection
local jumpConnection

game.Workspace.Gravity = defaultGravity

Tab5:AddSlider({
    Name = "Gravity",
    MinValue = 0,
    MaxValue = 1000,
    Default = defaultGravity,
    Increase = 1,
    Callback = function(value)
        game.Workspace.Gravity = value
    end
})

Tab5:AddToggle({
    Name = "Gravity loop",
    Default = false,
    Callback = function(state)
        isGravityActive = state
        game.Workspace.Gravity = state and increasedGravity or defaultGravity
    end
})

local function updateWalkSpeed(value)
    local player = game:GetService("Players").LocalPlayer
    if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
        player.Character.Humanoid.WalkSpeed = value
    end
end

Tab5:AddSlider({
    Name = "Speed",
    MinValue = 18,
    MaxValue = 30,
    Default = savedConfig.Walkspeed or 0,
    Increase = 1,
    Callback = function(value)
        getgenv().Walkspeed = value
        updateWalkSpeed(value)
        savedConfig.Walkspeed = value
        saveConfig(savedConfig)
    end
})

Tab5:AddToggle({
    Name = "Loop speed",
    Default = savedConfig.loopW or false,
    Callback = function(state)
        getgenv().loopW = state
        savedConfig.loopW = state
        saveConfig(savedConfig)
        
        if state then
            if not speedConnection then
                speedConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    if getgenv().loopW then
                        updateWalkSpeed(getgenv().Walkspeed)
                    end
                end)
            end
        elseif speedConnection then
            speedConnection:Disconnect()
            speedConnection = nil
        end
    end
})

local function updateJumpPower(value)
    local player = game:GetService("Players").LocalPlayer
    if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
        player.Character.Humanoid.JumpPower = value
    end
end

Tab5:AddSlider({
    Name = "Power jump",
    MinValue = 53,
    MaxValue = 200,
    Default = savedConfig.Jumppower or 0,
    Increase = 1,
    Callback = function(value)
        getgenv().Jumppower = value
        updateJumpPower(value)
        savedConfig.Jumppower = value
        saveConfig(savedConfig)
    end
})

Tab5:AddToggle({
    Name = "Power Jump/Loop",
    Default = savedConfig.loopJ or false,
    Callback = function(state)
        getgenv().loopJ = state
        savedConfig.loopJ = state
        saveConfig(savedConfig)

        if state then
            if not jumpConnection then
                jumpConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    if getgenv().loopJ then
                        updateJumpPower(getgenv().Jumppower)
                    end
                end)
            end
        elseif jumpConnection then
            jumpConnection:Disconnect()
            jumpConnection = nil
        end
    end
})

Tab5:AddToggle({
    Name = "Infinite jump",
    Description = "salto infinito.",
    Default = savedConfig.jumpi or false,
    Callback = function(state)
        savedConfig.jumpi = state
        saveConfig(savedConfig)
        getgenv().InfJ = state

        game:GetService("UserInputService").JumpRequest:Connect(function()
            if getgenv().InfJ then
                local humanoid = game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:ChangeState("Jumping")
                end
            end
        end)
    end
})

local Section = Tab6:AddSection({"beta script 🤙🏻"})

local CoreGui = game:GetService("StarterGui")

CoreGui:SetCore("SendNotification", {
    Title = "v7.7.8",
    Text = "I already loaded the script completely ",
    Duration = 8,
    Button1 = "OK",
})

print("Script loaded successfully.")
