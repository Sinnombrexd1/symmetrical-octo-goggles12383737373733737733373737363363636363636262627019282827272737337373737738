local Players = game:GetService("Players")
local Workspace = game:GetService('Workspace')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local RunService = game:GetService('RunService')
local Lighting = game:GetService('Lighting')
local UIS = game:GetService('UserInputService')
local ScriptContext = game:GetService('ScriptContext')
local Camera = Workspace.CurrentCamera
local player = Players.LocalPlayer
local Mouse = player:GetMouse()
local Terrain = Workspace.Terrain
local VirtualUser = game:GetService("VirtualUser")
local LocalPlayer = Players.LocalPlayer
local PlayerScripts = LocalPlayer:FindFirstChildOfClass("PlayerScripts")
local RawMetatable = getrawmetatable(game)
local OldNameCall = RawMetatable.__namecall
local UserInputService = game:GetService('UserInputService')

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Sinnombrexd1/Whwhwhwhwansjw/refs/heads/main/Lib", true))()

local ui = Library:CreateUI("Murder Mystery 2 / 27", "By CapybaraScript")
task.wait(0.3)
local tab1 = ui:AddTab("Combat")
local tab2 = ui:AddTab("Hitbox expander")
local tab3 = ui:AddTab("Visual")
local tab4 = ui:AddTab("Teleport")
local tab5 = ui:AddTab("Auto Farm")
local tab6 = ui:AddTab("Local Player")
local tab7 = ui:AddTab("Emote")
local tab8 = ui:AddTab("MIC")
local tab9 = ui:AddTab("buttons")

local configFileName = "mm2Config.txt"

local function saveConfig(stateTable)
    writefile(configFileName, game.HttpService:JSONEncode(stateTable))
end

local function loadConfig()
    if isfile(configFileName) then
        local success, data = pcall(function()
            return game.HttpService:JSONDecode(readfile(configFileName))
        end)
        
        if success and type(data) == "table" then
            return data
        end
    end
    return {}
end

local savedConfig = loadConfig()

setfpscap(math.huge)
print("Fps unblock")

local blockPosition = Vector3.new(-74, 6, 693)
local blockSize = Vector3.new(100, 2, 100)
local wallHeight = 5

local function blockExists(pos, size)
    for _, obj in ipairs(workspace:GetChildren()) do
        if obj:IsA("Part") and obj.Position == pos and obj.Size == size then
            return true
        end
    end
    return false
end

if not blockExists(blockPosition, blockSize) then
    local wideBlock = Instance.new("Part")
    wideBlock.Size = blockSize
    wideBlock.Position = blockPosition
    wideBlock.Anchored = true
    wideBlock.CanCollide = true
    wideBlock.Transparency = 0.5
    wideBlock.Parent = workspace
    
    local wallSize = Vector3.new(60, wallHeight, 2)
    local wallPositions = {
        blockPosition + Vector3.new(0, wallHeight / 2, 30),
        blockPosition + Vector3.new(0, wallHeight / 2, -30),
        blockPosition + Vector3.new(30, wallHeight / 2, 0),
        blockPosition + Vector3.new(-30, wallHeight / 2, 0),
    }

    for _, pos in ipairs(wallPositions) do
        local wall = Instance.new("Part")
        wall.Size = wallSize
        wall.Position = pos
        wall.Anchored = true
        wall.CanCollide = true
        wall.Transparency = 0.5
        wall.Parent = workspace
    end
end
 
local SilentAim = {CurrentPrediction = Vector3.zero}
local SilentAimEnabled = false
local KnifeAimEnabled = false
local GunSharpnessEnabled = false
local PredictionType = "Normal"
local VisualTracerPredictionEnabled = false
local VisualTracerDrawing = nil
local VisualPredictionCircle = nil

local HorizontalOffsetMultiplier = 0.23
local VerticalOffsetMultiplier = 0.03
local HorizontalDistanceMultiplier = 0.3
local VerticalDistanceMultiplier = 0.1
local MaxDistanceForMultiplier = 33
local SharpnessMultiplier = 0.20

function ToggleSilentAim(state)
    SilentAimEnabled = state
end

function ToggleKnifeAim(state)
    KnifeAimEnabled = state
end

function ToggleGunSharpness(state)
    GunSharpnessEnabled = state
end

function ToggleVisualTracerPrediction(state)
    VisualTracerPredictionEnabled = state
    if state then
        if not VisualTracerDrawing then
            VisualTracerDrawing = Drawing.new("Line")
            VisualTracerDrawing.Thickness = 2
            VisualTracerDrawing.Color = Color3.new(1, 0, 0)
            VisualTracerDrawing.Visible = true
        end
        if not VisualPredictionCircle then
            VisualPredictionCircle = Drawing.new("Circle")
            VisualPredictionCircle.Radius = 10
            VisualPredictionCircle.Thickness = 2
            VisualPredictionCircle.Filled = false
            VisualPredictionCircle.Visible = true
        end
    else
        if VisualTracerDrawing then
            VisualTracerDrawing:Remove()
            VisualTracerDrawing = nil
        end
        if VisualPredictionCircle then
            VisualPredictionCircle:Remove()
            VisualPredictionCircle = nil
        end
    end
end

Library.addToggle(tab1, "Gun Silent Aim", false, function(state) ToggleSilentAim(state) end)
Library.addToggle(tab1, "Knife Silent Aim", false, function(state) ToggleKnifeAim(state) end)
Library.addToggle(tab1, "Gun Sharpness Shooter", false, function(state) ToggleGunSharpness(state) end)
Library.addToggle(tab1, "Visual Tracer Prediction", false, function(state) ToggleVisualTracerPrediction(state) end)
Library.addDropdown(tab1, "Prediction Type", {"Normal", "Dynamic", "Static"}, function(selected) PredictionType = selected end)

local Rays = {}
local KnifeSpeed = 30
local KnifePredictionMultiplier = 0.4

function PlayerHasKnifeOrGun()
    local Backpack = LocalPlayer:FindFirstChild("Backpack")
    local Character = LocalPlayer.Character
    local HasKnife = Backpack and Backpack:FindFirstChild("Knife") or (Character and Character:FindFirstChild("Knife"))
    local HasGun = Backpack and Backpack:FindFirstChild("Gun") or (Character and Character:FindFirstChild("Gun"))
    return HasKnife, HasGun
end

function Rays:GetGunPrediction()
    local LocalRoot = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart
    if not LocalRoot then return end
    local function GetClosestPlayer()
        local ClosestPlayer, ClosestDistance = nil, math.huge
        for _, Player in pairs(Players:GetPlayers()) do
            if Player ~= LocalPlayer then
                local TargetRoot = Player.Character and Player.Character.PrimaryPart
                if TargetRoot then
                    local Distance = (LocalRoot.Position - TargetRoot.Position).Magnitude
                    if Distance < ClosestDistance then
                        ClosestPlayer, ClosestDistance = Player, Distance
                    end
                end
            end
        end
        return ClosestPlayer
    end
    local Target = GetClosestPlayer()
    if Target then
        local TargetRoot = Target.Character and Target.Character.PrimaryPart
        if TargetRoot then
            local TargetVelocity = TargetRoot.AssemblyLinearVelocity
            local rawDistance = (LocalRoot.Position - TargetRoot.Position).Magnitude
            local clampedDistance = math.min(rawDistance, MaxDistanceForMultiplier)
            local distanceFactorH = (clampedDistance / 20) * HorizontalDistanceMultiplier
            local distanceFactorV = (clampedDistance / 20) * VerticalDistanceMultiplier
            local Prediction
            if PredictionType == "Dynamic" then
                Prediction = TargetRoot.Position + (TargetVelocity * Vector3.new(1, 0, 1) * HorizontalOffsetMultiplier * distanceFactorH) + Vector3.new(0, math.clamp(TargetVelocity.Y * VerticalOffsetMultiplier * distanceFactorV, -2, 2), 0)
            elseif PredictionType == "Static" then
                Prediction = TargetRoot.Position
            else
                Prediction = TargetRoot.Position + (TargetVelocity * Vector3.new(1, 0, 1) * HorizontalOffsetMultiplier * distanceFactorH)
            end
            if GunSharpnessEnabled then
                Prediction = Prediction + (TargetVelocity * SharpnessMultiplier * clampedDistance / 20)
            end
            return Prediction
        end
    end
    return nil
end

function Rays:GetKnifePrediction()
    local LocalRoot = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart
    if not LocalRoot then return end
    local function GetClosestPlayer()
        local ClosestPlayer, ClosestDistance = nil, math.huge
        for _, Player in pairs(Players:GetPlayers()) do
            if Player ~= LocalPlayer then
                local TargetRoot = Player.Character and Player.Character.PrimaryPart
                if TargetRoot then
                    local Distance = (LocalRoot.Position - TargetRoot.Position).Magnitude
                    if Distance < ClosestDistance then
                        ClosestPlayer, ClosestDistance = Player, Distance
                    end
                end
            end
        end
        return ClosestPlayer
    end
    local Target = GetClosestPlayer()
    if Target then
        local TargetRoot = Target.Character and Target.Character.PrimaryPart
        if TargetRoot then
            local TargetVelocity = TargetRoot.AssemblyLinearVelocity
            local Distance = (LocalRoot.Position - TargetRoot.Position).Magnitude
            
            local TravelTime = Distance / KnifeSpeed
            local VelocityFactor = 0.3 
            local Prediction = TargetRoot.Position + (TargetVelocity * TravelTime * VelocityFactor)
            
            Prediction = Prediction + Vector3.new(0, math.clamp(TargetVelocity.Y * VerticalOffsetMultiplier * -1, -1, 1), 0)

            return Prediction
        end
    end
    return nil
end

RunService.RenderStepped:Connect(function()
    local HasKnife, HasGun = PlayerHasKnifeOrGun()

    if VisualPredictionCircle then
        if HasGun then
            VisualPredictionCircle.Color = Color3.new(0, 0, 1)
        elseif HasKnife then
            VisualPredictionCircle.Color = Color3.new(0, 1, 0)
        else
            VisualPredictionCircle.Visible = false
        end
    end

    if SilentAimEnabled then
        if HasGun then
            SilentAim.CurrentPrediction = Rays:GetGunPrediction() or SilentAim.CurrentPrediction
        elseif HasKnife then
            SilentAim.CurrentPrediction = Rays:GetKnifePrediction() or SilentAim.CurrentPrediction
        else
            SilentAim.CurrentPrediction = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart.Position or SilentAim.CurrentPrediction
        end
    end

    if VisualTracerPredictionEnabled and VisualTracerDrawing and VisualPredictionCircle then
        local Camera = workspace.CurrentCamera
        local LocalRoot = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart
        if LocalRoot then
            local startPos, onScreenStart = Camera:WorldToViewportPoint(LocalRoot.Position)
            local endPos, onScreenEnd = Camera:WorldToViewportPoint(SilentAim.CurrentPrediction)
            if onScreenStart and onScreenEnd then
                VisualTracerDrawing.From = Vector2.new(startPos.X, startPos.Y)
                VisualTracerDrawing.To = Vector2.new(endPos.X, endPos.Y)
                VisualTracerDrawing.Visible = true
                VisualPredictionCircle.Position = Vector2.new(endPos.X, endPos.Y)
                VisualPredictionCircle.Visible = true
            else
                VisualTracerDrawing.Visible = false
                VisualPredictionCircle.Visible = false
            end
        end
    end
end)

setreadonly(RawMetatable, false)
RawMetatable.__namecall = newcclosure(function(Object, ...)
    local NamecallMethod = getnamecallmethod()
    local Arguments = {...}
    if SilentAimEnabled then
        if NamecallMethod == "InvokeServer" and tostring(Object) == "RemoteFunction" then
            local Success, Error = pcall(function()
                Arguments[2] = SilentAim.CurrentPrediction
            end)
            if Error then warn("Error! :", Error) end
        end
    end
    if KnifeAimEnabled then
        if NamecallMethod == "FireServer" and tostring(Object) == "Throw" then
            local Success, Error = pcall(function()
                Arguments[1] = CFrame.new(SilentAim.CurrentPrediction)
            end)
            if Error then warn("Error! :", Error) end
        end
    end
    return OldNameCall(Object, unpack(Arguments))
end)

Library.addButton(tab1, "Shoot the murderer (Button)", function()
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PredictionBox

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ShootMurdererGui"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local clickSound = Instance.new("Sound")

button.Name = "Button"
button.Size = UDim2.new(0, 150, 0, 150)
button.Position = UDim2.new(0.85, -50, 0.15, -50)
button.Text = "Shoot"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

clickSound.SoundId = "rbxassetid://1673280232"
clickSound.Parent = button

local function createPredictionVisual()
    PredictionBox = Instance.new("Part")
    PredictionBox.Size = Vector3.new(0.4, 0.4, 0.4)
    PredictionBox.Shape = Enum.PartType.Ball
    PredictionBox.Anchored = true
    PredictionBox.CanCollide = false
    PredictionBox.Massless = true
    PredictionBox.Color = Color3.new(0, 0, 1)
    PredictionBox.Transparency = 1
    PredictionBox.Parent = workspace
end

local function getCharacterRootPart(character)
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
end

local function EquipGun()
    local gunInBackpack = LocalPlayer.Backpack:FindFirstChild("Gun")
    if gunInBackpack then
        gunInBackpack.Parent = LocalPlayer.Character
        return true
    end
    return false
end

local function calculatePrediction(target, distance)
    if not target then return nil end
    local rootPart = getCharacterRootPart(target)
    if not rootPart then return nil end

    local targetPosition = rootPart.Position
    local targetVelocity = rootPart.Velocity
    local shooterPosition = LocalPlayer.Character.HumanoidRootPart.Position

    local predictionTimeHorizontal = 0.231
    local predictionTimeVertical = 0.000000002

    if distance > 30 then
        predictionTimeVertical = 0.00000007
        predictionTimeHorizontal = 0.15
    else
        predictionTimeVertical = 0.000000002
        predictionTimeHorizontal = 0.231
    end

    local predictedX = targetPosition.X + (targetVelocity.X * predictionTimeHorizontal)
    local predictedY = targetPosition.Y + (targetVelocity.Y * predictionTimeVertical)
    local predictedZ = targetPosition.Z + (targetVelocity.Z * predictionTimeHorizontal)

    local predictedPosition = Vector3.new(predictedX, predictedY, predictedZ)

    return predictedPosition
end

local function hasKnife(player)
    if player.Character then
        for _, item in pairs(player.Character:GetChildren()) do
            if item:IsA("Tool") and item.Name == "Knife" then
                return true
            end
        end
    end

    local backpack = player:FindFirstChildOfClass("Backpack")
    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") and item.Name == "Knife" then
                return true
            end
        end
    end
    
    return false
end

local function updatePrediction()
    local closestPlayer
    local shortestDistance = math.huge

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            if hasKnife(player) then
                local rootPart = getCharacterRootPart(player.Character)
                if rootPart then
                    local distance = (LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end

    if closestPlayer and PredictionBox then
        local predictedPosition = calculatePrediction(closestPlayer.Character, shortestDistance)
        if predictedPosition then
            PredictionBox.Position = predictedPosition
        end
    end
end

local function shootAtClosestPlayer()
    local closestPlayer
    local shortestDistance = math.huge

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            if hasKnife(player) then -- Solo selecciona jugadores con Knife
                local rootPart = getCharacterRootPart(player.Character)
                if rootPart then
                    local distance = (LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
                    if distance < shortestDistance then
                        shortestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end

    if closestPlayer then
        local predictedPosition = calculatePrediction(closestPlayer.Character, shortestDistance)
        if predictedPosition then
            local args = {
                [1] = 1,
                [2] = predictedPosition,
                [3] = "AH2"
            }
            LocalPlayer.Character.Gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))
        end
    end
end

button.MouseButton1Click:Connect(function()
EquipGun()
    shootAtClosestPlayer()
    clickSound:Play()
end)

createPredictionVisual()
RunService.RenderStepped:Connect(updatePrediction)
end)

Library.addLabel(tab1, "For Murderer")

Library.addButton(tab1, "Kill All [murderer Only]", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/0DDgYP4Y"))()
end)

local Players = game:GetService("Players")
local RunService = game:GetService('RunService')

getgenv().knifeEq = false
getgenv().auraOn = false
getgenv().lastSlash = 0
getgenv().slashDelay = 0.5
getgenv().scriptActive = false
getgenv().detectionRadius = 9.4

local Plr
repeat
    Plr = Players.LocalPlayer
    task.wait()
until Plr

local auraConn
local rootPart

local function getRoot(c)
    if c then return c:WaitForChild("HumanoidRootPart", 2) end
end

Plr.CharacterAdded:Connect(function(c)
    rootPart = getRoot(c)
end)

if Plr.Character then
    rootPart = getRoot(Plr.Character)
end

local function equipKnife()
    local knife = Plr.Backpack:FindFirstChild("Knife")
    if not getgenv().knifeEq and knife then
        knife.Parent = Plr.Character
        getgenv().knifeEq = true
    end
end

local function unequipKnife()
    local knife = Plr.Character:FindFirstChild("Knife")
    if getgenv().knifeEq and knife then
        knife.Parent = Plr.Backpack
        getgenv().knifeEq = false
    end
end

local function findNearby()
    local nearPlr, nearDist = nil, 7.1
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= Plr and p.Character then
            local pRoot = p.Character:FindFirstChild("HumanoidRootPart")
            if pRoot then
                local dist = (rootPart.Position - pRoot.Position).Magnitude
                if dist <= nearDist then
                    nearPlr = p
                    break
                end
            end
        end
    end
    return nearPlr
end

local function aura()
    if not getgenv().auraOn or not rootPart then return end
    local target = findNearby()
    if target then
        equipKnife()
        if getgenv().knifeEq and tick() - getgenv().lastSlash >= getgenv().slashDelay then
            local args = { [1] = "Down" }
            game:GetService("Players").LocalPlayer.Character.Knife.Stab:FireServer(unpack(args))
            getgenv().lastSlash = tick()
        end
    else
        unequipKnife()
    end
end

local function startAura()
    if auraConn then auraConn:Disconnect() end
    getgenv().auraOn = true
    auraConn = RunService.Heartbeat:Connect(aura)
end

local function stopAura()
    getgenv().auraOn = false
    unequipKnife()
    if auraConn then
        auraConn:Disconnect()
        auraConn = nil
    end
end

Library.addToggle(tab1, "Knife Aura", false, function(state)
    if state then startAura() else stopAura() end
end)

RunService.Heartbeat:Connect(function()
    if getgenv().auraOn and not rootPart and Plr.Character then
        rootPart = getRoot(Plr.Character)
    end
end)

Library.addToggle(tab1, "Kill aura", false, function(state)
    getgenv().scriptActive = state
end)

Library.addTextbox(tab1, "Detection Radius Kill Aura", "Escribe el radio de detección para los enemigos", "9.4", function(value)
    getgenv().detectionRadius = tonumber(value) or 9.4
end)

local function hasKnife()
    local bp = Plr:FindFirstChild("Backpack")
    if bp and bp:FindFirstChild("Knife") then return true end
    local c = Plr.Character
    if c and c:FindFirstChild("Knife") then return true end
    return false
end

local function teleportEnemy(e)
    if rootPart and e then
        local eRoot = e:FindFirstChild("HumanoidRootPart")
        if eRoot then
            local dir = rootPart.CFrame.LookVector
            eRoot.CFrame = CFrame.new(rootPart.Position + dir * 2.8)
        end
    end
end

local function findClosest()
    local closest, dist = nil, getgenv().detectionRadius
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= Plr and p.Character then
            local pRoot = p.Character:FindFirstChild("HumanoidRootPart")
            if pRoot then
                local d = (pRoot.Position - rootPart.Position).Magnitude
                if d < dist then
                    closest, dist = p, d
                end
            end
        end
    end
    return closest
end

local function teleportClosest()
    if getgenv().scriptActive and rootPart and hasKnife() then
        local closest = findClosest()
        if closest and closest.Character then
            teleportEnemy(closest.Character)
        end
    end
end

Plr.CharacterAdded:Connect(function(c)
    rootPart = getRoot(c)
end)

rootPart = getRoot(Plr.Character)

RunService.Heartbeat:Connect(function()
    if getgenv().scriptActive and hasKnife() and rootPart then
        teleportClosest()
    end
end)
 
Library.addLabel(tab1, "Cam aimbot")
 
Library.addButton(tab1, "Cam Aimbot murderer", function()
local RS, Players, ReplicatedStorage = game:GetService("RunService"), game:GetService("Players"), game:GetService("ReplicatedStorage")
local LP, Camera = Players.LocalPlayer, workspace.CurrentCamera

local screenGui, button = Instance.new("ScreenGui"), Instance.new("TextButton")
screenGui.Name, screenGui.Parent = "aimbot", game:GetService("CoreGui")

button.Name, button.Size, button.Position = "Button", UDim2.new(0, 50, 0, 50), UDim2.new(0.5, -35, 0, 10)
button.Text, button.Font, button.TextSize = "Aimbot OFF", Enum.Font.Gotham, 10
button.TextColor3, button.BackgroundColor3, button.BackgroundTransparency = Color3.new(1, 1, 1), Color3.fromRGB(60, 60, 60), 0.6
button.Draggable, button.BorderSizePixel, button.Parent = true, 0, screenGui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius, UICorner.Parent = UDim.new(0, 15), button

local aimbotEnabled, targetPlayer = false, nil

button.MouseButton1Click:Connect(function()
    aimbotEnabled = not aimbotEnabled
    button.Text = aimbotEnabled and "Aimbot ON" or "Aimbot OFF"
end)

RS.RenderStepped:Connect(function()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    targetPlayer = nil

    for name, data in pairs(roles or {}) do
        if data.Role == "Murderer" and name ~= LP.Name then
            targetPlayer = Players:FindFirstChild(name)
            break
        end
    end

    if aimbotEnabled and targetPlayer and targetPlayer.Character then
        local char, torso = targetPlayer.Character, targetPlayer.Character:FindFirstChild("Torso") or targetPlayer.Character:FindFirstChild("UpperTorso")
        local humanoid = char:FindFirstChild("Humanoid")

        if torso and humanoid then
            local lookVector, directionToPlayer = torso.CFrame.LookVector, (LP.Character.HumanoidRootPart.Position - torso.Position).Unit
            local targetPos = (lookVector:Dot(directionToPlayer) < -0.7 or humanoid.MoveDirection.Magnitude == 0 or math.abs(lookVector.X) < 0.1) 
                and torso.Position or torso.Position + lookVector * 3
            
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPos)
        end
    end
end)
end)

Library.addButton(tab1, "TP Shoot", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("tps")
if existingGui then return end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "tps"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
button.Name = "Button"
button.Size = UDim2.new(0, 50, 0, 50)
button.Position = UDim2.new(1, -220, 0, 10)
button.Text = "TP SHOOT"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.Draggable = true
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
button.BackgroundTransparency = 0.6
button.BorderSizePixel = 0
button.Parent = screenGui

local function playerHasKnife(player)
    local backpack = player.Backpack
    if backpack:FindFirstChild("Knife") then
        return true
    end

    local character = player.Character
    if character and character:FindFirstChild("Knife") then
        return true
    end

    return false
end

local function equipGun()
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character
    if not character then return false end

    local gunInBackpack = player.Backpack:FindFirstChild("Gun")
    if gunInBackpack then
        gunInBackpack.Parent = character
        return true
    else
        return false
    end
end

local function teleportAndShoot(targetPlayer)
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")

    if not playerHasKnife(targetPlayer) then
        return
    end

    if not character or not character:FindFirstChild("Gun") then
        if not equipGun() then
            return
        end
    end

    local gun = character:FindFirstChild("Gun")
    if not gun then
        return
    end

    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local targetPart = targetPlayer.Character.HumanoidRootPart
        local originalPosition = rootPart.Position
        local runService = game:GetService("RunService")
        local renderConnection

        renderConnection = runService.RenderStepped:Connect(function()
            if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                renderConnection:Disconnect()
                return
            end

            local targetPosition = targetPart.Position
            local behindPosition = targetPosition - (targetPart.CFrame.LookVector * 5) - Vector3.new(0, -1, 0)
            rootPart.CFrame = CFrame.new(behindPosition)
            character:SetPrimaryPartCFrame(CFrame.new(rootPart.Position, targetPart.Position))
        end)

        wait(0.3)

        local targetPosition = targetPlayer.Character.HumanoidRootPart.Position
        local args = {
            [1] = 1,
            [2] = targetPosition,
            [3] = "AH2"
        }

        game:GetService("Players").LocalPlayer.Character.Gun.KnifeLocal.CreateBeam.RemoteFunction:InvokeServer(unpack(args))

        wait(0.01)
        renderConnection:Disconnect()
        rootPart.CFrame = CFrame.new(originalPosition)
    else
        return
    end
end

local function onButtonPress()
    button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)
    wait(0.2)
    button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)

    local player = game:GetService("Players").LocalPlayer
    local targetPlayer = game:GetService("Players"):GetPlayers()

    for _, otherPlayer in pairs(targetPlayer) do
        if playerHasKnife(otherPlayer) then
            teleportAndShoot(otherPlayer)
            return
        end
    end
end

button.MouseButton1Click:Connect(onButtonPress)
    end)
    
local settings = {
    HitboxSize = 10,
    HitboxTransparency = 0.7,
    HitboxMaterial = "Plastic",
    HitboxColor = Color3.fromRGB(169, 169, 169),
    Enabled = false,
    HitboxCollision = false
}

local runService = game:GetService("RunService")
local players = game:GetService("Players")

local originalSizes = {}
local heartbeatConnection

local function modifyRootPart()
    heartbeatConnection = runService.Heartbeat:Connect(function()
        for _, player in pairs(players:GetPlayers()) do
            if player ~= players.LocalPlayer then
                pcall(function()
                    local rootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                    if rootPart then
                        if settings.Enabled then
                            if not originalSizes[player] then
                                originalSizes[player] = {
                                    Size = rootPart.Size,
                                    Transparency = rootPart.Transparency,
                                    Color = rootPart.Color
                                }
                            end
                            rootPart.Size = Vector3.new(settings.HitboxSize, settings.HitboxSize, settings.HitboxSize)
                            rootPart.Transparency = settings.HitboxTransparency
                            rootPart.Color = settings.HitboxColor
                            rootPart.Material = Enum.Material[settings.HitboxMaterial]
                            rootPart.CanCollide = settings.HitboxCollision
                        else
                            if originalSizes[player] then
                                rootPart.Size = originalSizes[player].Size
                                rootPart.Transparency = originalSizes[player].Transparency
                                rootPart.Color = originalSizes[player].Color
                                originalSizes[player] = nil
                            end
                        end
                    end
                end)
            end
        end
    end)
end

-- Verificar que Library y tab2 no son nil
if Library and tab2 then
    Library.addToggle(tab2, "Hitbox Expander", settings.Enabled, function(state)
        settings.Enabled = state
        saveConfig(settings)
        if settings.Enabled then
            modifyRootPart()
        else
            if heartbeatConnection then
                heartbeatConnection:Disconnect()
            end
        end
    end)

    Library.addTextbox(tab2, "Hitbox Size", tostring(settings.HitboxSize), "10", function(value)
        settings.HitboxSize = tonumber(value) or settings.HitboxSize
        saveConfig(settings)
    end)

    Library.addTextbox(tab2, "Hitbox Transparency", tostring(settings.HitboxTransparency), "0.7", function(value)
        settings.HitboxTransparency = tonumber(value) or settings.HitboxTransparency
        saveConfig(settings)
    end)

    Library.addToggle(tab2, "Hitbox Collision", settings.HitboxCollision, function(state)
        settings.HitboxCollision = state
        saveConfig(settings)
    end)

    Library.addDropdown(tab2, "Select Hitbox Material", {
        "Plastic", "SmoothPlastic", "Glass", "Neon", "Wood", "CorrodedMetal",
        "ForceField", "Slate", "DiamondPlate", "Granite", "Marble", "Cobblestone", "WoodenPlanks"
    }, function(value)
        settings.HitboxMaterial = value
        saveConfig(settings)
    end)

    Library.AddColorPicker(tab2, "Selecciona un color", Color3.fromRGB(255, 0, 0), function(color)
        settings.HitboxColor = color
        saveConfig(settings)
    end)
else
    warn("Library or tab2 is nil!")
end

modifyRootPart()

Library.addButton(tab2, "Knife reach", function()
    local character = game.Players.LocalPlayer.Character
    if character then
        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA("Tool") and tool.Name == "Knife" then
                local handle = tool:FindFirstChild("Handle")
                if handle and handle:IsA("Part") then
                    handle.Size = Vector3.new(7, 7, 7)
                    handle.Massless = true
                    handle.Anchored = false
                    handle.CanCollide = false
                end
            end
        end

        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = 18
        end
    end
end)

getgenv().xray = false
getgenv().saved = {}

local function setTransparency(obj)
    for _, v in pairs(obj:GetChildren()) do
        if v:IsA("BasePart") then
            if getgenv().xray then
                getgenv().saved[v] = getgenv().saved[v] or v.Transparency
                v.Transparency = 0.5
            else
                if getgenv().saved[v] then
                    v.Transparency = getgenv().saved[v]
                    getgenv().saved[v] = nil
                end
            end
        end
        setTransparency(v)
    end
end

local function toggleXRay()
    setTransparency(workspace)
end

Library.addToggle(tab3, "XRay", false, function(state)
    getgenv().xray = state
    toggleXRay()
end)

getgenv().adornmentEnabled = false  

local adorns = {}

local function createAdorn(part)  
    if part:IsA("BasePart") and not adorns[part] then  
        local box = Instance.new("BoxHandleAdornment")  
        box.Size = part.Size  
        box.Color3 = Color3.fromRGB(100, 255, 100)  
        box.Transparency = 0.7  
        box.AlwaysOnTop = true  
        box.ZIndex = 1  
        box.Adornee = part  
        box.Parent = part  

        adorns[part] = box  
    end  
end  

local function scanAndAdd()  
    for _, container in pairs(game.Workspace:GetDescendants()) do  
        if container:IsA("Model") and container.Name == "CoinContainer" then  
            for _, part in pairs(container:GetDescendants()) do  
                createAdorn(part)  
            end  
        end  
    end  
end  

Library.addToggle(tab3, "See Coins", false, function(state)
    getgenv().adornmentEnabled = state

    if getgenv().adornmentEnabled then
        scanAndAdd()

        game.Workspace.DescendantAdded:Connect(function(descendant)
            if descendant:IsA("BasePart") and descendant.Parent and descendant.Parent.Name == "CoinContainer" then
                createAdorn(descendant)
            end
        end)
    else
        for _, box in pairs(adorns) do
            box:Destroy()
        end
        adorns = {}
    end
end)

getgenv().Nametag = false  
getgenv().Cheamesp = false  
getgenv().TracerEnabled = false  
getgenv().Highlight = false  

getgenv().ChamTransparency = 0.7  
getgenv().HighlightTransparency = 0.5  

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local Holder = Instance.new("Folder", game.CoreGui)  
Holder.Name = "ESP"  

local tracerContainer = {}  
local highlights = {}  
local rolesCache = {}  

local roleColors = {  
    Sheriff = Color3.fromRGB(0, 0, 200),  
    Murderer = Color3.fromRGB(255, 0, 0),  
    Hero = Color3.fromRGB(255, 255, 0),  
    None = Color3.fromRGB(0, 140, 0)  
}  

local outlineColors = {  
    Sheriff = Color3.fromRGB(0, 0, 255),  
    Murderer = Color3.fromRGB(139, 0, 0),  
    Hero = Color3.fromRGB(255, 255, 0),  
    None = Color3.fromRGB(0, 128, 0)  
}  

local function CreateNameTag()  
    local NameTag = Instance.new("BillboardGui")  
    NameTag.Name = "NameTag"  
    NameTag.Size = UDim2.new(0, 200, 0, 50)  
    NameTag.AlwaysOnTop = true  
    NameTag.StudsOffset = Vector3.new(0, 2.5, 0)  
    local Tag = Instance.new("TextLabel", NameTag)  
    Tag.Name = "Tag"  
    Tag.BackgroundTransparency = 1  
    Tag.Size = UDim2.new(0, 300, 0, 20)  
    Tag.TextSize = 14  
    Tag.Position = UDim2.new(0, -50, 0, 0)  
    Tag.TextStrokeTransparency = 0  
    Tag.Font = Enum.Font.SourceSansBold  
    return NameTag  
end  

local function LoadCharacter(player)  
    if not getgenv().Nametag or player == LocalPlayer then return end  
    local character = player.Character  
    if not character then return end  
    local head = character:FindFirstChild("Head")  
    if not head then return end  
    local vHolder = Holder:FindFirstChild(player.Name) or Instance.new("Folder", Holder)  
    vHolder.Name = player.Name  
    local nametag = vHolder:FindFirstChild("NameTag") or CreateNameTag()  
    nametag.Parent = vHolder  
    nametag.Adornee = head  
    nametag.Enabled = true  
    nametag.Tag.Text = player.Name  
    nametag.Tag.TextColor3 = roleColors.None  
end  

local function UnloadCharacter(player)  
    local vHolder = Holder:FindFirstChild(player.Name)  
    if vHolder then vHolder:Destroy() end  
end  

local function applyAdornmentsWithDelay(character)  
    if not character or not getgenv().Cheamesp then return end  
    for _, part in pairs(character:GetChildren()) do  
        if part:IsA("BasePart") then  
            task.delay(0.1, function()  
                local adornment = part:FindFirstChild("espAdornment")  
                if not adornment then  
                    adornment = Instance.new("BoxHandleAdornment")  
                    adornment.Name = "espAdornment"  
                    adornment.Size = part.Size  
                    adornment.Adornee = part  
                    adornment.AlwaysOnTop = true  
                    adornment.ZIndex = 5  
                    adornment.Transparency = getgenv().ChamTransparency  
                    adornment.Parent = part  
                end  
            end)  
        end  
    end  
end  

local function ManagePlayer(player)  
    if player == LocalPlayer then return end  
    player.CharacterAdded:Connect(function(character)  
        task.wait(0.5)  
        LoadCharacter(player)  
        applyAdornmentsWithDelay(character)  
        if getgenv().Highlight then  
            local highlight = Instance.new("Highlight")  
            highlight.Name = "ESP_Highlight"  
            highlight.FillTransparency = getgenv().HighlightTransparency  
            highlight.OutlineTransparency = 0  
            highlight.Parent = character  
            highlights[player] = highlight  
        end  
    end)  
    player.CharacterRemoving:Connect(function()  
        UnloadCharacter(player)  
        task.wait(0.3)
        if highlights[player] then  
            highlights[player]:Destroy()  
            highlights[player] = nil  
        end  
    end)  
    if player.Character then  
        LoadCharacter(player)  
        applyAdornmentsWithDelay(player.Character)  
    end  
end  

for _, player in pairs(Players:GetPlayers()) do  
    ManagePlayer(player)  
end  

Players.PlayerAdded:Connect(ManagePlayer)  
Players.PlayerRemoving:Connect(function(player)  
    UnloadCharacter(player)  
    if tracerContainer[player] then  
        tracerContainer[player]:Remove()  
        tracerContainer[player] = nil  
    end  
    if highlights[player] then  
        highlights[player]:Destroy()  
        highlights[player] = nil  
    end  
end)  

local function UpdateRoles()  
    local success, roles = pcall(function()  
        return ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()  
    end)  
    if not success or not roles then return {} end  
    rolesCache = {}  
    for playerName, data in pairs(roles) do  
        rolesCache[playerName] = data.Role  
    end  
    return rolesCache  
end  

local function UpdateLabels()  
    for _, player in pairs(Players:GetPlayers()) do  
        local vHolder = Holder:FindFirstChild(player.Name)
        local nametag = vHolder and vHolder:FindFirstChild("NameTag")
        if nametag then  
            local role = rolesCache[player.Name] or "None"  
            nametag.Tag.TextColor3 = roleColors[role] or roleColors.None  
        end  
    end  
end  

local function applyRoleColor(character, role)  
    if not character or not getgenv().Cheamesp then return end  
    local color = roleColors[role] or roleColors.None  
    for _, part in pairs(character:GetChildren()) do  
        if part:IsA("BasePart") then  
            local adornment = part:FindFirstChild("espAdornment")  
            if not adornment then  
                adornment = Instance.new("BoxHandleAdornment")  
                adornment.Name = "espAdornment"  
                adornment.Size = part.Size  
                adornment.Adornee = part  
                adornment.AlwaysOnTop = true  
                adornment.ZIndex = 5  
                adornment.Transparency = getgenv().ChamTransparency  
                adornment.Parent = part  
            else
                adornment.Transparency = getgenv().ChamTransparency  
            end
            adornment.Color3 = color  
        end  
    end  
end  

local function removeESP(character)  
    if not character then return end  
    for _, part in pairs(character:GetChildren()) do  
        if part:IsA("BasePart") then  
            local adornment = part:FindFirstChild("espAdornment")  
            if adornment then adornment:Destroy() end  
        end  
    end  
end  

local function drawTracerLines()  
    if not getgenv().TracerEnabled then
        for _, tracer in pairs(tracerContainer) do
            tracer:Remove()
        end
        tracerContainer = {}
        return
    end
    local camera = workspace.CurrentCamera  
    for _, player in pairs(Players:GetPlayers()) do  
        if player ~= LocalPlayer and player.Character then  
            local rootPart = player.Character:FindFirstChild("HumanoidRootPart")  
            local humanoid = player.Character:FindFirstChild("Humanoid")  
            if rootPart and humanoid and humanoid.Health > 0 then  
                local screenPos, onScreen = camera:WorldToViewportPoint(rootPart.Position)  
                if onScreen then  
                    local role = rolesCache[player.Name] or "None"  
                    local tracer = tracerContainer[player] or Drawing.new("Line")  
                    tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)  
                    tracer.To = Vector2.new(screenPos.X, screenPos.Y)  
                    tracer.Thickness = 3  
                    tracer.Color = roleColors[role] or roleColors.None  
                    tracer.Visible = true  
                    tracerContainer[player] = tracer  
                else  
                    if tracerContainer[player] then  
                        tracerContainer[player].Visible = false  
                    end  
                end  
            elseif tracerContainer[player] then  
                tracerContainer[player]:Remove()  
                tracerContainer[player] = nil  
            end  
        end  
    end  
end  

local lastRoleUpdate = 0  
local lastColorUpdate = 0  

task.spawn(function()
    while true do
        task.wait(0.03)
        if (getgenv().Nametag or getgenv().Cheamesp or getgenv().Highlight or getgenv().TracerEnabled) then
            local currentTime = os.clock()
            if currentTime - lastRoleUpdate >= 3 then
                UpdateRoles()
                lastRoleUpdate = currentTime
            end
            if currentTime - lastColorUpdate >= 1 then
                if getgenv().Nametag then
                    UpdateLabels()
                end
                if getgenv().Cheamesp then
                    for _, player in pairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer and player.Character then
                            local role = rolesCache[player.Name] or "None"
                            applyRoleColor(player.Character, role)
                        end
                    end
                end
                if getgenv().Highlight then
                    for player, highlight in pairs(highlights) do
                        if player.Character then
                            local role = rolesCache[player.Name] or "None"
                            highlight.FillColor = roleColors[role] or roleColors.None
                            highlight.OutlineColor = outlineColors[role] or outlineColors.None
                        end
                    end
                end
                lastColorUpdate = currentTime
            end
            drawTracerLines()
        end
    end
end)

Library.addLabel(tab3, "ESP Players")

Library.addToggle(tab3, "ESP Name", false, function(state)
    getgenv().Nametag = state
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            if state then 
                LoadCharacter(player) 
            else 
                UnloadCharacter(player) 
            end
        end
    end
end)

Library.addToggle(tab3, "ESP Cham", false, function(state)
    getgenv().Cheamesp = state
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            if state then
                local role = rolesCache[player.Name] or "None"
                applyRoleColor(player.Character, role)
            else
                removeESP(player.Character)
            end
        end
    end
end)

Library.addToggle(tab3, "ESP Tracer", false, function(state)
    getgenv().TracerEnabled = state
    if not state then
        for _, tracer in pairs(tracerContainer) do
            tracer:Remove()
        end
        tracerContainer = {}
    end
end)

Library.addToggle(tab3, "ESP Highlight", false, function(state)
    getgenv().Highlight = state
    if state then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local highlight = Instance.new("Highlight")
                highlight.Name = "ESP_Highlight"
                highlight.FillTransparency = getgenv().HighlightTransparency
                highlight.OutlineTransparency = 0
                highlight.Parent = player.Character
                highlights[player] = highlight
            end
        end
    else
        for player, highlight in pairs(highlights) do
            highlight:Destroy()
            highlights[player] = nil
        end
    end
end)

Library.addSlider(tab3, "Esp transparency", 0, 100, 50, 1, function(value)
    local highlightTransparency = value / 100
    local chamTransparency = math.min(value / 100, 0.9)
    getgenv().HighlightTransparency = highlightTransparency
    getgenv().ChamTransparency = chamTransparency

    for player, highlight in pairs(highlights) do
        if highlight then
            highlight.FillTransparency = highlightTransparency
        end
    end

    for _, player in pairs(Players:GetPlayers()) do
        if player.Character then
            for _, part in pairs(player.Character:GetChildren()) do
                if part:IsA("BasePart") then
                    local adornment = part:FindFirstChild("espAdornment")
                    if adornment then
                        adornment.Transparency = chamTransparency
                    end
                end
            end
        end
    end
end)

getgenv().ReplicatedStorage = game:GetService("ReplicatedStorage")
getgenv().StarterGui = game:GetService("StarterGui")
getgenv().Players = game:GetService("Players")

print("Script started")

getgenv().toggleNotifications = false  
getgenv().notificationsSent = { Murderer = false, Sheriff = false }
local localPlayer = Players.LocalPlayer

local function sendNotification(player, role)
    if not getgenv().toggleNotifications then return end
    local thumb = ""
    local playerObj = Players:FindFirstChild(player)
    
    if playerObj then
        thumb = Players:GetUserThumbnailAsync(playerObj.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size100x100)
    end

    StarterGui:SetCore("SendNotification", {
        Title = "Player Detected",
        Text = player .. " is " .. role,
        Icon = thumb,
        Duration = 5
    })
    
    getgenv().notificationsSent[role] = true
    print("Notification sent: " .. player .. " - " .. role)
end

local function getRoles()
    if not getgenv().toggleNotifications then return end

    print("Searching for players with roles...")

    local success, roles = pcall(function()
        return ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    end)

    if not success or not roles then return end

    local murderFound, sheriffFound = false, false

    for player, info in pairs(roles) do
        if info.Role == "Murderer" then
            murderFound = true
            if not getgenv().notificationsSent.Murderer then
                sendNotification(player, "Murderer")
            end
        elseif info.Role == "Sheriff" then
            sheriffFound = true
            if not getgenv().notificationsSent.Sheriff then
                sendNotification(player, "Sheriff")
            end
        end
    end

    if not murderFound then
        getgenv().notificationsSent.Murderer = false
    end

    if not sheriffFound then
        getgenv().notificationsSent.Sheriff = false
    end
end

local function startSearching()
    while true do
        if getgenv().toggleNotifications and localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
            getRoles()
        end
        wait(2)
    end
end

localPlayer.CharacterAdded:Connect(function()
    wait(1)
    getgenv().notificationsSent.Murderer = false
    getgenv().notificationsSent.Sheriff = false
end)

task.spawn(startSearching)

Library.addToggle(tab3, "Role Notification", false, function(state)
    getgenv().toggleNotifications = state
    if state then
        print("Role notifications enabled.")
    else
        print("Role notifications disabled.")
    end
end)

Library.addLabel(tab3, "Gun Stuff")

Library.addToggle(tab3, "ESP Gun", false, function(state)
    savedConfig.espgun12 = state
    saveConfig(savedConfig)
    getgenv().Gunesp = state
    
    local function createLabel(object)  
        local player = game:GetService("Players").LocalPlayer  
        local distance = (object.Position - player.Character.HumanoidRootPart.Position).Magnitude  
        if not object:FindFirstChild("GunLabel") then  
            local label = Instance.new("BillboardGui")  
            label.Name = "GunLabel"  
            label.Adornee = object  
            label.Size = UDim2.new(0, 200, 0, 50)  
            label.StudsOffset = Vector3.new(0, 3, 0)  
            label.AlwaysOnTop = true  
            label.Parent = object  
            local textLabel = Instance.new("TextLabel")  
            textLabel.Size = UDim2.new(1, 0, 1, 0)  
            textLabel.BackgroundTransparency = 1  
            textLabel.TextStrokeTransparency = 0.6  
            textLabel.TextSize = 10
            textLabel.ZIndex = 5  
            textLabel.Parent = label  
            textLabel.Text = string.format("Gun Here! [%d studs]", math.floor(distance))  
            textLabel.TextColor3 = Color3.fromRGB(255, 0, 255)  
        else  
            local textLabel = object.GunLabel:FindFirstChildOfClass("TextLabel")  
            if textLabel then  
                textLabel.Text = string.format("Gun Here! [%d studs]", math.floor(distance))  
            end  
        end  
    end  

    local function removeHighlightsAndLabels()  
        for _, v in pairs(workspace:GetChildren()) do  
            local gunDrop = v:FindFirstChild("GunDrop")  
            if gunDrop then  
                local highlight = gunDrop:FindFirstChild("Highlight")  
                if highlight then  
                    highlight:Destroy()  
                end  
                local label = gunDrop:FindFirstChild("GunLabel")  
                if label then  
                    label:Destroy()  
                end  
            end  
        end  
    end  

    local runConnection  
    if state then  
        runConnection = game:GetService("RunService").Heartbeat:Connect(function()  
            if getgenv().Gunesp then
                for _, v in pairs(workspace:GetChildren()) do  
                    local gunDrop = v:FindFirstChild("GunDrop")  
                    if gunDrop then  
                        if not gunDrop:FindFirstChild("Highlight") then  
                            local highlight = Instance.new("Highlight")  
                            highlight.Parent = gunDrop  
                            highlight.FillTransparency = 0.7  
                            highlight.FillColor = Color3.fromRGB(148, 0, 211)  
                            highlight.OutlineColor = Color3.fromRGB(255, 0, 255)  
                        end  
                        createLabel(gunDrop)  
                    end  
                end  
            end  
        end)  
    else  
        if runConnection then  
            runConnection:Disconnect()  
        end  
        removeHighlightsAndLabels()  
        return
    end  
end) 

local pl = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local gui = game:GetService("StarterGui")

getgenv().active = false

Library.addToggle(tab3, "GunDrop Notifier", false, function(state)
    getgenv().active = state
end)

local notif = {}

local function checkGuns()
    if not getgenv().active then return end
    local char = pl.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    for _, v in pairs(workspace:GetChildren()) do
        local gun = v:FindFirstChild("GunDrop")
        if gun and not notif[gun] then
            local d = (gun.Position - hrp.Position).Magnitude
            gui:SetCore("SendNotification", {
                Title = "Gun Drop Found!",
                Text = string.format("Gun found at %.2f studs", d),
                Duration = 5
            })
            notif[gun] = true
            for _, c in pairs(gun:GetChildren()) do
                if c:IsA("Mash") then
                    c.Size = Vector3.new(10, 10, 10)
                end
            end
        end
    end
end

rs.Heartbeat:Connect(function()
    checkGuns()
end)

Library.addLabel(tab3, "round time")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local state = false
local timerThread = nil

local function createGui()
    if CoreGui:FindFirstChild("TimerGui") then
        CoreGui.TimerGui:Destroy()
    end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "TimerGui"
    screenGui.Parent = CoreGui

    local timerText = Instance.new("TextLabel")
    timerText.Name = "TimerText"
    timerText.Parent = screenGui
    timerText.BackgroundTransparency = 1
    timerText.TextColor3 = Color3.new(1, 1, 1)
    timerText.TextStrokeColor3 = Color3.new(0, 0, 0)
    timerText.TextStrokeTransparency = 0.5
    timerText.TextScaled = true
    timerText.AnchorPoint = Vector2.new(0.5, 0.5)
    timerText.Position = UDim2.new(0.5, 0, 0.1, 0)
    timerText.Size = UDim2.new(0, 200, 0, 50)
    timerText.Font = Enum.Font.GothamBold
    timerText.Text = "0:00"

    return timerText
end

local function secondsToMinutes(seconds)
    return string.format("%d:%02d", math.floor(seconds / 60), seconds % 60)
end

local function updateTimer(timerText)
    while state do
        local success, timeLeft = pcall(function()
            return ReplicatedStorage.Remotes.Extras.GetTimer:InvokeServer()
        end)

        if not success then
            warn("Error al obtener el temporizador:", timeLeft)
            task.wait(1)
            continue
        end

        if timeLeft <= 0 then
            timerText.Text = "0:00"
            
            -- Parpadeo cuando llega a cero
            for _ = 1, 3 do
                if not state then break end
                timerText.TextColor3 = Color3.new(1, 0, 0)
                task.wait(0.5)
                if not state then break end
                timerText.TextColor3 = Color3.new(1, 1, 1)
                task.wait(0.5)
            end

            -- Esperar hasta que el tiempo se reinicie
            repeat
                task.wait(1)
                timeLeft = ReplicatedStorage.Remotes.Extras.GetTimer:InvokeServer()
            until timeLeft > 0 or not state
        else
            timerText.Text = secondsToMinutes(timeLeft)
            timerText.TextColor3 = timeLeft <= 10 and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
        end
        
        task.wait(1)
    end
end

Library.addToggle(tab3, "Show Timer Game", false, function(toggleState)
    state = toggleState
    
    if state then
        local timerText = createGui()
        timerThread = task.spawn(function() updateTimer(timerText) end)
    else
        if timerThread then
            task.cancel(timerThread)
            timerThread = nil
        end
        
        if CoreGui:FindFirstChild("TimerGui") then
            CoreGui.TimerGui:Destroy()
        end
    end
end)

Library.addLabel(tab3, "snitch role")

Library.addButton(tab3, "Inquire chat who is the sheriff or murderer", function()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TextChatService = game:GetService("TextChatService")

local function sendMessage(msg)
    if msg and msg ~= "" then
        pcall(function()
            TextChatService.TextChannels.RBXGeneral:SendAsync(msg)
        end)
    end
end

local function checkRoles()
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    if not roles then return end

    local Sheriff, Murderer
    for playerName, roleData in pairs(roles) do
        if roleData.Role == "Murderer" then
            Murderer = playerName
        elseif roleData.Role == "Sheriff" then
            Sheriff = playerName
        end
    end

    if Sheriff and Murderer then
        sendMessage(Sheriff .. " is the Sheriff and " .. Murderer .. " is the Murderer.")
    elseif Sheriff then
        sendMessage(Sheriff .. " is the Sheriff, but there is no Murderer.")
    elseif Murderer then
        sendMessage(Murderer .. " is the Murderer.")
    end
end

checkRoles()
end)

Library.addButton(tab3, "Fps Booster", function()
    loadstring(game:HttpGet(("https://raw.githubusercontent.com/Jorgelinea/Fps/refs/heads/main/Protected_3128182632327016.txt"),true))()
end)

Library.addButton(tab3, "fake death", function()
    local p = game.Players.LocalPlayer
    local c = p.Character or p.CharacterAdded:Wait()
    local h = c:WaitForChild("Humanoid")
    local cf = c.HumanoidRootPart.CFrame
    c:SetPrimaryPartCFrame(cf * CFrame.Angles(math.rad(-90), 0, 0))
    h.Sit = true
end)

local function GetPlayerByRole(role)
    local roles = ReplicatedStorage:FindFirstChild("GetPlayerData", true):InvokeServer()
    for i, v in pairs(roles) do
        if v.Role == role then
            return Players:FindFirstChild(i)
        end
    end
    return nil
end

local function TeleportToRole(role)
    local rolePlayer = GetPlayerByRole(role)
    if rolePlayer and rolePlayer.Character and rolePlayer.Character:FindFirstChild("HumanoidRootPart") then
        local Character = Players.LocalPlayer.Character
        if Character then
            Character:SetPrimaryPartCFrame(rolePlayer.Character.HumanoidRootPart.CFrame)
        end
    end
end

local function ViewRole(role)
    local rolePlayer = GetPlayerByRole(role)
    if rolePlayer and rolePlayer.Character and rolePlayer.Character:FindFirstChild("HumanoidRootPart") then
        Camera.CameraSubject = rolePlayer.Character.Humanoid
        Camera.CFrame = rolePlayer.Character.HumanoidRootPart.CFrame
    end
end

Library.addLabel(tab3, "View Roles")

Library.addButton(tab3, "View Murderer", function()
    ViewRole("Murderer")
end)

Library.addButton(tab3, "View Sheriff", function()
    ViewRole("Sheriff")
end)

Library.addButton(tab3, "View Hero", function()
    ViewRole("Hero")
end)

Library.addButton(tab3, "Return to my camera", function()
    local LP = Players.LocalPlayer
    if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") then
        Camera.CameraSubject = LP.Character.Humanoid
        Camera.CFrame = LP.Character.HumanoidRootPart.CFrame
    end
end)

Library.addButton(tab3, "Fe emote", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/eCpipCTH"))()
end)

Library.addButton(tab4, "FAKE SPEED GLICH", function()
if game:GetService("CoreGui"):FindFirstChild("fakespeed") then return end

local gui = Instance.new("ScreenGui")
gui.Name = "fakespeed"
gui.Parent = game:GetService("CoreGui")

local btn = Instance.new("TextButton")
btn.Size = UDim2.new(0, 50, 0, 50)
btn.Position = UDim2.new(0.5, -25, 0.5, -25)
btn.Text = "OFF"
btn.Font = Enum.Font.Gotham
btn.TextSize = 14
btn.TextColor3 = Color3.new(1, 1, 1)
btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
btn.BackgroundTransparency = 0.6
btn.Draggable = true
btn.Parent = gui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 15)
corner.Parent = btn

local active, conn = false
btn.MouseButton1Click:Connect(function()
    active = not active
    btn.Text, btn.BackgroundColor3 = active and "ON" or "OFF", active and Color3.fromRGB(173, 216, 230) or Color3.fromRGB(60, 60, 60)
end)

local plr, rs = game.Players.LocalPlayer, game:GetService("RunService")
local spd, maxSpd, acc, dec, landDec, landSpd, landDur = 3, 15, 0.2, 0.1, 0.05, 2, 0.3

local function setup(chr)
    local hum = chr:WaitForChild("Humanoid")
    local slide, time = false, 0

    if conn then conn:Disconnect() end
    conn = rs.Heartbeat:Connect(function(dt)
        local state, dir = hum:GetState(), hum.MoveDirection
        if state == Enum.HumanoidStateType.Freefall and active then
            spd = dir.Magnitude > 0 and math.min(spd + acc, maxSpd) or math.max(spd - dec, 0)
            chr:TranslateBy(dir * spd * dt)
        elseif state == Enum.HumanoidStateType.Landed then
            if not slide then spd, time, slide = landSpd, 0, true end
        elseif slide then
            if time < landDur then
                chr:TranslateBy(dir * spd * dt)
                spd, time = math.max(spd - landDec, 0), time + dt
            else slide = false end
        else spd = math.max(spd - dec, 0) end
    end)
end

plr.CharacterAdded:Connect(setup)
if plr.Character then setup(plr.Character) end
end)
Library.addButton(tab4, "FAKE Fake bomb trick", function()
local player = game:GetService("Players").LocalPlayer
local coreGui, replicatedStorage = game:GetService("CoreGui"), game:GetService("ReplicatedStorage")

local gui = coreGui:FindFirstChild("bomb")
if gui then gui:Destroy() end

gui = Instance.new("ScreenGui", coreGui)
gui.Name = "bomb"

local btn = Instance.new("TextButton", gui)
btn.Size, btn.Position = UDim2.new(0, 100, 0, 100), UDim2.new(1, -110, 0, 10)
btn.Text, btn.Font, btn.TextSize, btn.TextColor3 = "Fake bomb trick", Enum.Font.Gotham, 14, Color3.new(1, 1, 1)
btn.BackgroundColor3, btn.BackgroundTransparency, btn.Draggable = Color3.new(0, 1, 0), 0.6, true

Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 15)

local canUse, cooldown = true, 22

local function reset()
    canUse, btn.BackgroundColor3, btn.Text = true, Color3.new(0, 1, 0), "Fake bomb trick"
end

local function useBomb()
    if not canUse then return end
    canUse, btn.BackgroundColor3 = false, Color3.new(1, 0, 0)

    local backpack, char = player:FindFirstChild("Backpack"), player.Character or player.CharacterAdded:Wait()
    local bomb = backpack:FindFirstChild("FakeBomb") or char:FindFirstChild("FakeBomb")

    if not bomb then
        replicatedStorage.Remotes.Extras.ReplicateToy:InvokeServer("FakeBomb")
        bomb = backpack:WaitForChild("FakeBomb") or char:WaitForChild("FakeBomb")
    end

    bomb.Parent = char
    if bomb:IsDescendantOf(char) then
        char:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
        game.Players.LocalPlayer.Character.Humanoid.JumpPower = 53
        bomb.Remote:FireServer(char.HumanoidRootPart.CFrame * CFrame.new(0, -3, 0), 50)
        wait(0.3)
        bomb.Parent = backpack
        game.Players.LocalPlayer.Character.Humanoid.JumpPower = 51
    end

    local start, currentChar = time(), player.Character
    while time() - start < cooldown do
        if player.Character ~= currentChar then reset() return end
        btn.Text = string.format("Cooldown: %ds", cooldown - math.floor(time() - start))
        wait(0.1)
    end

    reset()
end

btn.MouseButton1Click:Connect(useBomb)
player.CharacterAdded:Connect(reset)
reset()
end)

Library.addButton(tab4, "Auto Wallhop", function()
    loadstring(game:HttpGet('https://pastebin.com/raw/vpRrW1KA'))()
end)

Library.addButton(tab4, "Fling murderer", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/YKTYp5Dn"))()
end)

Library.addButton(tab4, "Fling sheriff", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/Lx8UkvVv"))()
end)

Library.addLabel(tab4, "Gun stuff")
local player = game.Players.LocalPlayer
local coreGui = game:GetService("CoreGui")
local autoGrabThread
local auraThread
local viewThread

Library.addToggle(tab4, "Bring Gun", false, function(state)
    local existingGui = coreGui:FindFirstChild("TPGUN")
    if existingGui then existingGui:Destroy() end

    if state then
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "TPGUN"
        screenGui.Parent = coreGui

        local button = Instance.new("TextButton")
        button.Name = "TPGUNButton"
        button.Text = "Bring Gun"
        button.Size = UDim2.new(0, 60, 0, 50)
        button.Position = UDim2.new(1, -220, 0, 10)
        button.BackgroundTransparency = 0.5
        button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.Draggable = true
        Instance.new("UICorner", button).CornerRadius = UDim.new(0, 5)
        button.Parent = screenGui

        button.MouseButton1Click:Connect(function()
            local character = player.Character
            if not character then return end
            
            local gunDrop = workspace:FindFirstChild("GunDrop", true)
            local root = character:FindFirstChild("HumanoidRootPart")
            
            if gunDrop and root then
                firetouchinterest(root, gunDrop, 0)
                task.wait(0.001)
                firetouchinterest(root, gunDrop, 1)
            end
        end)
    end
end)

Library.addToggle(tab4, "Auto grab Gun", false, function(state)
    if autoGrabThread then
        task.cancel(autoGrabThread)
        autoGrabThread = nil
    end

    if state then
        autoGrabThread = task.spawn(function()
            local function hasKnife()
                local character = player.Character
                return character and (player.Backpack:FindFirstChild("Knife") or character:FindFirstChild("Knife"))
            end

            while state do
                if not hasKnife() then
                    local gunDrop = workspace:FindFirstChild("GunDrop", true)
                    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")

                    if gunDrop and root then
                        firetouchinterest(root, gunDrop, 0)
                        task.wait(0.001)
                        firetouchinterest(root, gunDrop, 1)
                    end
                end
                task.wait(0.3)
            end
        end)
    end
end)

Library.addToggle(tab4, "Gun Aura", false, function(state)
    if auraThread then
        task.cancel(auraThread)
        auraThread = nil
    end

    if state then
        auraThread = task.spawn(function()
            while state do
                local character = player.Character
                local root = character and character:FindFirstChild("HumanoidRootPart")
                local gunDrop = workspace:FindFirstChild("GunDrop", true)

                if root and gunDrop then
                    local distance = (root.Position - gunDrop.Position).Magnitude
                    if distance <= 7 then
                        firetouchinterest(root, gunDrop, 0)
                        task.wait(0.001)
                        firetouchinterest(root, gunDrop, 1)
                    end
                end
                task.wait(0.1)
            end
        end)
    end
end)

Library.addToggle(tab4, "View Drop Gun", false, function(state)
    if viewThread then
        task.cancel(viewThread)
        viewThread = nil
        workspace.CurrentCamera.CameraSubject = player.Character and player.Character:FindFirstChild("Humanoid") or player
    end

    if state then
        viewThread = task.spawn(function()
            while state do
                local gunDrop = workspace:FindFirstChild("GunDrop", true)
                if gunDrop then
                    workspace.CurrentCamera.CameraSubject = gunDrop
                end
                task.wait(0.1)
            end
        end)
    end
end)

Library.addButton(tab4, "be invisible", function()
    loadstring(game:HttpGet('https://pastebin.com/raw/GgYsFfDK'))()
end)

Library.addToggle(tab4, "tp at the Last Death Position", false, function(state)
    savedConfig.Death = state
    saveConfig(savedConfig)

    if state then
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name, screenGui.Parent = "TeleportGui", game:GetService("CoreGui")

        local teleportButton = Instance.new("TextButton")
        teleportButton.Name, teleportButton.Size, teleportButton.Position, teleportButton.Text, teleportButton.Font, teleportButton.TextSize, teleportButton.TextColor3, teleportButton.BackgroundColor3, teleportButton.BackgroundTransparency, teleportButton.Draggable, teleportButton.BorderSizePixel, teleportButton.Parent = 
            "TeleportButton", UDim2.new(0, 60, 0, 50), UDim2.new(0.5, -170, 0, 10), "Teleport", Enum.Font.Gotham, 10, Color3.fromRGB(255, 255, 255), Color3.fromRGB(60, 60, 60), 0.6, true, 5, screenGui

        local UICorner = Instance.new("UICorner")
        UICorner.CornerRadius, UICorner.Parent = UDim.new(0, 15), teleportButton

        local player = game.Players.LocalPlayer
        local lastDeathPosition

        local function recordDeathPosition()
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                lastDeathPosition = player.Character.HumanoidRootPart.Position
            end
        end

        local function onCharacterDied()
            recordDeathPosition()
        end

        local function onCharacterAdded(character)
            local humanoid = character:WaitForChild("Humanoid", 5)
            if humanoid then humanoid.Died:Connect(onCharacterDied) end
        end

        player.CharacterAdded:Connect(onCharacterAdded)
        if player.Character then onCharacterAdded(player.Character) end

        teleportButton.MouseButton1Click:Connect(function()
            if lastDeathPosition and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.CFrame = CFrame.new(lastDeathPosition)
            end
        end)
    else
        local existingGui = game:GetService("CoreGui"):FindFirstChild("TeleportGui")
        if existingGui then existingGui:Destroy() end
    end
end)

Library.addLabel(tab4, "Teleport To A Specific Location")

Library.addButton(tab4, "Go to the Lobby", function()
    local player = game.Players.LocalPlayer
    local spawns = workspace:WaitForChild("Lobby"):WaitForChild("Spawns"):GetChildren()

    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and #spawns > 0 then
        local randomSpawn = spawns[math.random(1, #spawns)]
        player.Character.HumanoidRootPart.CFrame = randomSpawn.CFrame + Vector3.new(0, 3, 0)
    end
end)

Library.addButton(tab4, "Vote Map", function()
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-109, 141, 88)
end)

Library.addButton(tab4, "Go to Map", function()
    for i,v in pairs(workspace:GetDescendants()) do
        if v.Name == "Spawn" then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(v.Position) * CFrame.new(0, 2.5, 0)
        elseif v.Name == "PlayerSpawn" then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(v.Position) * CFrame.new(0, 2.5, 0)
        end
    end
end)

Library.addButton(tab4, "void (Safe)", function()
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local hrp = character:WaitForChild("HumanoidRootPart")

    local teleportPosition = CFrame.new(-74, 6, 693)
    hrp.CFrame = teleportPosition * CFrame.new(0, 3, 0)
end)

Library.addLabel(tab4, "teleport a role player")

Library.addButton(tab4, "tp Sheriff", function()
    TeleportToRole("Sheriff")
end)

Library.addButton(tab4, "tp Murderer", function()
    TeleportToRole("Murderer")
end)

Library.addButton(tab4, "tp Hero", function()
    TeleportToRole("Hero")
end)

Library.addLabel(tab5, "Optimization for auto farm (also without auto farm)")

getgenv().antiLag = false
getgenv().removeRaggy = false
getgenv().targetModels = {"Raggy", "GlitchProof"}

local function destroyTargetModels(parent)
    for _, obj in ipairs(parent:GetDescendants()) do
        if obj:IsA("Model") and table.find(getgenv().targetModels, obj.Name) then
            obj:Destroy()
            print(obj.Name .. " ha sido destruido.")
        end
    end
end

local function getCoinContainer()
    return Workspace:FindFirstChild("CoinContainer", true)
end

local function handleCoinTouched(coin)
    local connection
    connection = coin.Touched:Connect(function(hit)
        local character = hit.Parent
        if character and Players:GetPlayerFromCharacter(character) then
            connection:Disconnect()
            task.wait(0.1)
            coin:Destroy()
        end
    end)
end

local function monitorCoins()
    while true do
        if getgenv().antiLag then
            local container = getCoinContainer()
            if container then
                for _, coin in ipairs(container:GetChildren()) do
                    if coin.Name == "Coin_Server" and coin:IsA("BasePart") then
                        handleCoinTouched(coin)
                    end
                end
            end
        end
        task.wait(0.8)
    end
end

task.spawn(monitorCoins)

local function clearLag()
    for _, folder in ipairs(Workspace:GetChildren()) do
        if folder:IsA("Folder") and table.find({"Footsteps", "WeaponDisplays"}, folder.Name) then
            folder:Destroy()
        end
    end

    for _, player in ipairs(Players:GetPlayers()) do  
        local character = player.Character  
        if character then  
            for _, item in ipairs({"KnifeDisplay", "GunDisplay", "Pet"}) do  
                local targetItem = character:FindFirstChild(item)  
                if targetItem then targetItem:Destroy() end  
            end  
            for _, tool in ipairs(character:GetChildren()) do  
                if tool:IsA("Tool") then  
                    local chroma = tool:FindFirstChild("Handle") and tool.Handle:FindFirstChild("Chroma")  
                    if chroma then chroma:Destroy() end  
                end  
            end  
        end  
    end  

    for _, child in ipairs(Workspace:GetChildren()) do  
        if child:IsA("Model") or child:IsA("Part") then  
            local chroma = child:FindFirstChild("Handle") and child.Handle:FindFirstChild("Chroma")  
            if chroma then chroma:Destroy() end  
        end  
    end
end

local function monitorAntiLag()
    while true do
        if getgenv().antiLag then
            clearLag()
        end
        task.wait(1)
    end
end

task.spawn(monitorAntiLag)

Workspace.ChildAdded:Connect(function(child)
    if not getgenv().antiLag then return end
    if child:IsA("Folder") and table.find({"Footsteps", "WeaponDisplays"}, child.Name) then
        child:Destroy()
    elseif child:IsA("Model") or child:IsA("Part") then
        local chroma = child:FindFirstChild("Handle") and child.Handle:FindFirstChild("Chroma")
        if chroma then chroma:Destroy() end
    end
end)

Players.PlayerAdded:Connect(function(newPlayer)
    newPlayer.CharacterAdded:Connect(function(character)
        if getgenv().antiLag then
            clearLag()
        end
    end)
end)

Library.addToggle(tab5, "optimization", false, function(state)
    getgenv().antiLag = state
end)

Library.addToggle(tab5, "Destroy dead body", false, function(state)
    getgenv().removeRaggy = state
    if getgenv().removeRaggy then
        destroyTargetModels(Workspace)
    end
end)

Library.addButton(tab5, "lower cpu load", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/KAzmS50Z"))()
end)

local D3RenderingDisabled = false

Library.addToggle(tab5, "Disable 3D rendering", false, function(state)
    savedConfig.renderizado = state
    saveConfig(savedConfig)

    if not D3RenderingDisabled and state then
        D3RenderingDisabled = true
        RunService:Set3dRenderingEnabled(false)
    elseif D3RenderingDisabled and not state then
        D3RenderingDisabled = false
        RunService:Set3dRenderingEnabled(true)
    end
end)

Library.addLabel(tab5, "teleport autofarm")

local autoCollectCoins = false 
local maxCoinDistance = 110
local moveSpeed = 27
local checkInterval = 0.5
local moveToSpeed = 35
local verticalOffset = 0.1
local teleportCooldown = 3

local tweenService = game:GetService("TweenService")
local runService = game:GetService("RunService")
local virtualUser = game:GetService("VirtualUser")
local workspace = game:GetService("Workspace")

local character, humanoid, humanoidRootPart
local activeTween
local currentCoinContainer = nil
local lastTeleportTime = 0
local lastCoinContainerAtDeath = nil

local Vector3_new = Vector3.new
local CFrame_new = CFrame.new
local tick = tick
local task_wait = task.wait
local ipairs = ipairs
local math_huge = math.huge
local math_sqrt = math.sqrt

local updateCharacter, getCoinContainer, handleCoinTouched

local function disconnectConnection(connection)
    if connection then
        connection:Disconnect()
    end
end

function updateCharacter()  
    character = player.Character or player.CharacterAdded:Wait()  
    humanoid = character:WaitForChild("Humanoid")  
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")  
    print("Character updated")
    humanoid.Died:Connect(function()
        lastCoinContainerAtDeath = currentCoinContainer
        print("Player died. Last coin container at death set.")
    end)
end

function getCoinContainer()
    return workspace:FindFirstChild("CoinContainer", true)
end

function handleCoinTouched(coin)
    local connection
    connection = coin.Touched:Connect(function(hit)
        if not autoCollectCoins then return end 
        if Players:GetPlayerFromCharacter(hit.Parent) then
            disconnectConnection(connection)
            task_wait(0.01)
            coin:Destroy()
        end
    end)
end

local function getClosestCoin(container)
    if not container or not humanoidRootPart then return end
    
    local rootPosition = humanoidRootPart.Position
    local closestCoin
    local shortestDistanceSq = math_huge
    
    for _, coin in ipairs(container:GetChildren()) do
        if coin.Name == "Coin_Server" and coin:IsA("BasePart") then
            local delta = rootPosition - coin.Position
            local distanceSq = delta:Dot(delta)
            if distanceSq < shortestDistanceSq then
                shortestDistanceSq = distanceSq
                closestCoin = coin
            end
        end
    end
    
    return closestCoin, math_sqrt(shortestDistanceSq)
end

local function tweenToPosition(targetPosition)
    if not humanoidRootPart then return end
    
    local targetPosAdjusted = targetPosition + Vector3_new(0, verticalOffset, 0)
    local tweenInfo = TweenInfo.new(
        (humanoidRootPart.Position - targetPosAdjusted).Magnitude / moveSpeed,
        Enum.EasingStyle.Linear
    )
    
    local tween = tweenService:Create(
        humanoidRootPart,
        tweenInfo,
        {CFrame = CFrame_new(targetPosAdjusted, targetPosAdjusted + humanoidRootPart.CFrame.LookVector)}
    )
    
    activeTween = tween
    local character = player.Character or player.CharacterAdded:Wait()
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
    humanoidRootPart.Anchored = false
    tween:Play()
    
    tween.Completed:Connect(function()
        humanoidRootPart.Anchored = false
    end)
    
    return tween
end

local function moveToCoin(coin)
    if not coin or not humanoidRootPart then return end
    
    if humanoid and humanoid.Health <= 0 then
         return
    end

    local container = currentCoinContainer
    if not container then
        humanoid.WalkSpeed = 17
        return
    end
    
    humanoid.WalkSpeed = moveToSpeed
    local character = player.Character or player.CharacterAdded:Wait()
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
    local targetPosition = coin.Position
    local distance = (humanoidRootPart.Position - targetPosition).Magnitude
    
    if distance > maxCoinDistance then
        if tick() - lastTeleportTime >= teleportCooldown then
            humanoidRootPart.CFrame = CFrame_new(targetPosition, targetPosition + humanoidRootPart.CFrame.LookVector)
            lastTeleportTime = tick()
        end
        return
    end
    
    humanoid:MoveTo(targetPosition)
    local startTime = tick()
    
    while (humanoidRootPart.Position - targetPosition).Magnitude > 0.7 and tick() - startTime <= 0.7 do
        if not autoCollectCoins then break end
        task_wait(0.02)
    end
    
    if tick() - startTime > 0.7 then
        local tween = tweenToPosition(targetPosition)
        tween.Completed:Wait()
    end
end

local function collectCoins()
    while autoCollectCoins do
        if not player.Character then
            player.CharacterAdded:Wait()
            updateCharacter()
        end
        
        if (humanoid and humanoid.Health <= 0) or (lastCoinContainerAtDeath and currentCoinContainer == lastCoinContainerAtDeath) then
            task_wait(checkInterval)
        else
            if lastCoinContainerAtDeath and currentCoinContainer ~= lastCoinContainerAtDeath then
                lastCoinContainerAtDeath = nil
            end
            local closestCoin = currentCoinContainer and getClosestCoin(currentCoinContainer)
        
            if closestCoin then
                moveToCoin(closestCoin)
                task_wait(checkInterval)
            else
                task_wait(checkInterval)
            end
        end
    end
    if player.Character then
        local h = player.Character:FindFirstChildOfClass("Humanoid")
        if h then
            h.WalkSpeed = 17
        end
    end
end

local function manageCoinContainer()
    local containerConnection
    while true do
        if not autoCollectCoins then
            if currentCoinContainer then
                currentCoinContainer = nil
                if activeTween then
                    activeTween:Cancel()
                    if humanoidRootPart then
                        humanoidRootPart.Anchored = false
                    end
                end
                disconnectConnection(containerConnection)
            end
            task_wait(checkInterval)
        else
            local container = getCoinContainer()
            
            if container ~= currentCoinContainer then
                currentCoinContainer = container
                
                if activeTween then
                    activeTween:Cancel()
                    if humanoidRootPart then
                        humanoidRootPart.Anchored = false
                    end
                end
                disconnectConnection(containerConnection)
                
                if container then
                    containerConnection = container.ChildAdded:Connect(function(child)
                        if child.Name == "Coin_Server" and child:IsA("BasePart") then
                            handleCoinTouched(child)
                        end
                    end)
                    
                    for _, coin in ipairs(container:GetChildren()) do
                        if coin.Name == "Coin_Server" and coin:IsA("BasePart") then
                            handleCoinTouched(coin)
                        end
                    end
                    
                    if autoCollectCoins then
                        task.spawn(collectCoins)
                    end
                end
            end
            
            task_wait(checkInterval)
        end
    end
end

player.CharacterAdded:Connect(function()
    updateCharacter()
    print("Character updated")
end)

player.Idled:Connect(function()
    virtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    task_wait(1)
    virtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
end)

updateCharacter()
task.spawn(manageCoinContainer)

Library.addToggle(tab5, "Autofarm", false, function(state)
    autoCollectCoins = state
    if state then
        task.spawn(collectCoins)
    else
        if player and player.Character then
            local h = player.Character:FindFirstChildOfClass("Humanoid")
            if h then
                h.WalkSpeed = 17
            end
            for _, part in pairs(player.Character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
end)

getgenv().magnetcoin = getgenv().magnetcoin or false
getgenv().scriptEnabled = false
getgenv().original = getgenv().original or {}
getgenv().conns = getgenv().conns or {}

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local rs = game:GetService("RunService")
local lp = Players.LocalPlayer
local targetPos = Vector3.new(-108, 138, 9)
local hasTeleported = false

local function modCoin(coin, enlarge)
    if coin and coin.Parent then
        if enlarge then
            if not getgenv().original[coin] then
                getgenv().original[coin] = coin.Size
                coin.Size = coin.Size * 4.5
            end
        elseif getgenv().original[coin] then
            coin.Size = getgenv().original[coin]
            getgenv().original[coin] = nil
        end
    end
end

local function checkContainer(model)
    if not Players:GetPlayerFromCharacter(model) then
        local container = model:FindFirstChild("CoinContainer")
        if container then
            for _, coin in ipairs(container:GetChildren()) do
                if coin:IsA("BasePart") and coin.Name == "Coin_Server" then
                    modCoin(coin, getgenv().magnetcoin)
                end
            end
            return true
        end
    end
    return false
end

local function setup()
    for _, c in ipairs(getgenv().conns) do c:Disconnect() end
    table.clear(getgenv().conns)

    for _, model in ipairs(Workspace:GetChildren()) do
        checkContainer(model)
    end

    getgenv().conns[1] = Workspace.ChildAdded:Connect(checkContainer)
end

local function toggle(state)
    getgenv().magnetcoin = state
    if state then
        setup()
        task.spawn(function()
            while getgenv().magnetcoin do
                for _, model in ipairs(Workspace:GetChildren()) do
                    checkContainer(model)
                end
                task.wait(3)
            end
        end)
    else
        for coin in pairs(getgenv().original) do
            modCoin(coin, false)
        end
        table.clear(getgenv().original)

        for _, con in ipairs(getgenv().conns) do con:Disconnect() end
        table.clear(getgenv().conns)
    end
end

Library.addToggle(tab5, "magnet coin", false, function(state)
    if Players.LocalPlayer then
        toggle(getgenv().magnetcoin)
        Players.LocalPlayer.CharacterAdded:Connect(function()
            if getgenv().magnetcoin then toggle(true) end
        end)
    end
end)

local function hasKnife(player)
    local c = player.Character
    local b = player:FindFirstChild("Backpack")

    if c then
        for _, t in ipairs(c:GetChildren()) do
            if t:IsA("Tool") and t.Name == "Knife" then
                return true
            end
        end
    end

    if b then
        for _, t in ipairs(b:GetChildren()) do
            if t:IsA("Tool") and t.Name == "Knife" then
                return true
            end
        end
    end

    return false
end

local function onCharacterAdded()
    hasTeleported = false
end

lp.CharacterAdded:Connect(onCharacterAdded)

local connection
connection = rs.Heartbeat:Connect(function()
    if not getgenv().scriptEnabled then
        return
    end

    local rootPart = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    
    if rootPart and not hasTeleported then
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= lp and hasKnife(player) then
                rootPart.CFrame = CFrame.new(targetPos)
                hasTeleported = true
                break
            end
        end
    end
end)

Library.addToggle(tab5, "Auto XP", false, function(state)
    getgenv().scriptEnabled = state
end)

Library.addButton(tab6, "Anchor character", function()
    local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    
    isAnchored = not isAnchored
    for _, part in ipairs(char:GetChildren()) do
        if part:IsA("BasePart") then
            part.Anchored = isAnchored
        end
    end
end)

local jugadorLocal = game.Players.LocalPlayer
local colisionesDeshabilitadas = false

local function actualizarColisiones(state)
    colisionesDeshabilitadas = state
    for _, jugador in pairs(game.Players:GetPlayers()) do
        if jugador ~= jugadorLocal then
            local personaje = jugador.Character
            if personaje then
                for _, parte in pairs(personaje:GetChildren()) do
                    if parte:IsA("BasePart") then
                        parte.CanCollide = not colisionesDeshabilitadas
                    end
                end
            end
        end
    end
end

Library.addLabel(tab6, "It also works as an anti-fling")

Library.addToggle(tab6, "Disable players collisions", false, function(state)
    actualizarColisiones(state)
end)

game:GetService("RunService").Stepped:Connect(function()
    if colisionesDeshabilitadas then
        for _, jugador in pairs(game.Players:GetPlayers()) do
            if jugador ~= jugadorLocal then
                local personaje = jugador.Character
                if personaje then
                    for _, parte in pairs(personaje:GetChildren()) do
                        if parte:IsA("BasePart") then
                            parte.CanCollide = false
                        end
                    end
                end
            end
        end
    else
        for _, jugador in pairs(game.Players:GetPlayers()) do
            if jugador ~= jugadorLocal then
                local personaje = jugador.Character
                if personaje then
                    for _, parte in pairs(personaje:GetChildren()) do
                        if parte:IsA("BasePart") then
                            parte.CanCollide = true
                        end
                    end
                end
            end
        end
    end
end)

Library.addButton(tab6, "second life", function()
local function GodMode()
    local p = game.Players.LocalPlayer
    local c = p.Character or p.CharacterAdded:Wait()

    if c and c:FindFirstChild("Humanoid") then
        local h = c.Humanoid
        local accs = {}

        for _, acc in pairs(c:GetChildren()) do
            if acc:IsA("Accessory") then
                table.insert(accs, acc:Clone())
                acc:Destroy()
            end
        end

        local nh = h:Clone()
        nh.Parent = c
        nh.Name = "Humanoid"
        nh.WalkSpeed = 18.3
        nh.JumpPower = 53
        nh.Health = math.huge
        nh.MaxHealth = math.huge

        workspace.CurrentCamera.CameraSubject = nh

        local anim = c:FindFirstChild("Animate")
        if anim then
            anim.Disabled = true
            wait(0.1)
            anim.Disabled = true
        end

        for _, acc in pairs(accs) do
            nh:AddAccessory(acc)
        end

        h:Destroy()

        nh.Died:Connect(function()
            wait(0.1)
            nh.Health = math.huge
        end)
    end
end

GodMode()
    end)
    
local originalStates = {}

Library.addToggle(tab6, "Noclip", false, function(state)
    getgenv().Noclip = state
    if not state then
        for part, canCollide in pairs(originalStates) do
            if part and part.Parent then
                part.CanCollide = canCollide
            end
        end
        originalStates = {}
    end
end)

RunService.Stepped:Connect(function()
    if getgenv().Noclip and player.Character then
        for _, part in pairs(player.Character:GetDescendants()) do
            if part:IsA("BasePart") and part.Parent == player.Character then
                if not originalStates[part] then
                    originalStates[part] = part.CanCollide
                end
                part.CanCollide = false
            end
        end
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local plr = Players.LocalPlayer

getgenv().settings = {
    speed = { value = 17, loop = false },
    jump = { power = 50, loop = false, infinite = false },
    connections = {}
}

local settings = getgenv().settings

local function updateHumanoid(property, value)
    local character = plr.Character or plr.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid[property] = value
    end
end

local function disconnectAllConnections()
    for key, connection in pairs(settings.connections) do
        if connection then
            connection:Disconnect()
            settings.connections[key] = nil
        end
    end
end

plr.CharacterAdded:Connect(function()
    disconnectAllConnections()
    task.wait(0.5)

    if settings.speed.loop then
        settings.connections.speed = RunService.Heartbeat:Connect(function()
            updateHumanoid("WalkSpeed", settings.speed.value)
        end)
    else
        updateHumanoid("WalkSpeed", settings.speed.value)
    end

    if settings.jump.loop then
        settings.connections.jump = RunService.Heartbeat:Connect(function()
            updateHumanoid("JumpPower", settings.jump.power)
        end)
    else
        updateHumanoid("JumpPower", settings.jump.power)
    end

    if settings.jump.infinite then
        settings.connections.infinite = UserInputService.JumpRequest:Connect(function()
            local character = plr.Character or plr.CharacterAdded:Wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then humanoid:ChangeState("Jumping") end
        end)
    end
end)

Library.addSlider(tab6, "Speed", 0, 100, settings.speed.value, 1, function(value)
    settings.speed.value = value
    if not settings.speed.loop then
        updateHumanoid("WalkSpeed", value)
    end
end)

Library.addToggle(tab6, "Loop speed", false, function(state)
    settings.speed.loop = state
    if state then
        if settings.connections.speed then settings.connections.speed:Disconnect() end
        settings.connections.speed = RunService.Heartbeat:Connect(function()
            updateHumanoid("WalkSpeed", settings.speed.value)
        end)
    else
        if settings.connections.speed then
            settings.connections.speed:Disconnect()
            settings.connections.speed = nil
        end
    end
end)

Library.addSlider(tab6, "Power Jump", 0, 100, settings.jump.power, 1, function(value)
    settings.jump.power = value
    if not settings.jump.loop then
        updateHumanoid("JumpPower", value)
    end
end)

Library.addToggle(tab6, "Power Jump/Loop", false, function(state)
    settings.jump.loop = state
    if state then
        if settings.connections.jump then settings.connections.jump:Disconnect() end
        settings.connections.jump = RunService.Heartbeat:Connect(function()
            updateHumanoid("JumpPower", settings.jump.power)
        end)
    else
        if settings.connections.jump then
            settings.connections.jump:Disconnect()
            settings.connections.jump = nil
        end
    end
end)

Library.addToggle(tab6, "Infinite Jump", false, function(state)
    settings.jump.infinite = state
    if state then
        if settings.connections.infinite then settings.connections.infinite:Disconnect() end
        settings.connections.infinite = UserInputService.JumpRequest:Connect(function()
            local character = plr.Character or plr.CharacterAdded:Wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then humanoid:ChangeState("Jumping") end
        end)
    else
        if settings.connections.infinite then
            settings.connections.infinite:Disconnect()
            settings.connections.infinite = nil
        end
    end
end)

Library.addButton(tab7, "Get all the emotes", function()
    local PlayerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    local Emotes = PlayerGui:WaitForChild("MainGUI"):WaitForChild("Game"):FindFirstChild("Emotes")

    if Emotes then
        local success = pcall(function()
            require(game:GetService("ReplicatedStorage").Modules.EmoteModule).GeneratePage(
                {"headless", "zombie", "zen", "ninja", "floss", "dab", "sit"},
                Emotes,
                "Free Emotes"
            )
        end)

        if success then
            game.StarterGui:SetCore("SendNotification", {
                Title = "Success",
                Text = "Emotes obtained",
                Duration = 3
            })
        end
    end
end)

Library.addButton(tab7, "Ninja", function()
    local anim = Instance.new('Animation')
    anim.AnimationId = "rbxassetid://2431864798"
    local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
    track:Play()
    game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
        track:Stop()
    end)
end)

Library.addButton(tab7, "Dab", function()
    local anim = Instance.new('Animation')
    anim.AnimationId = "rbxassetid://2445521505"
    local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
    track:Play()
    game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
        track:Stop()
    end)
end)

Library.addButton(tab7, "Floss", function()
    local anim = Instance.new('Animation')
    anim.AnimationId = "rbxassetid://2452938820"
    local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
    track:Play()
    game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
        track:Stop()
    end)
end)

Library.addButton(tab7, "Headless", function()
    local anim = Instance.new('Animation')
    anim.AnimationId = "rbxassetid://2513694073"
    local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
    track:Play()
    game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
        track:Stop()
    end)
end)

Library.addButton(tab7, "Zen", function()
    local anim = Instance.new('Animation')
    anim.AnimationId = "rbxassetid://2431812646"
    local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
    track:Play()
    game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
        track:Stop()
    end)
end)

Library.addButton(tab7, "Zombie", function()
    local anim = Instance.new('Animation')
    anim.AnimationId = "rbxassetid://2513692312"
    local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
    track:Play()
    game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
        track:Stop()
    end)
end)

Library.addButton(tab7, "Sit", function()
    local anim = Instance.new('Animation')
    anim.AnimationId = "rbxassetid://2431845940"
    local track = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
    track:Play()
    game.Players.LocalPlayer.Character.Humanoid.Changed:Once(function()
        track:Stop()
    end)
end)

Library.addButton(tab8, "Delete Settings", function()
    local configFileName = "mm2Config.txt"

    local function deleteConfigFile()
        if isfile(configFileName) then
            delfile(configFileName)
        end
    end

    deleteConfigFile()
end)

Library.addButton(tab8, "Anti afk", function()
    local C = game:GetService("VirtualUser")
    game:GetService("Players").LocalPlayer.Idled:connect(function()
       C:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
       wait(1)
       C:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    end)
end)

getgenv().player = game.Players.LocalPlayer
getgenv().guiName = "JumpGui"
getgenv().gui, getgenv().connections = nil, {}

getgenv().toggleJumpFeature = function(enable)
    if getgenv().gui then getgenv().gui:Destroy() end
    getgenv().gui = nil
    getgenv().connections = {}

    if enable then
        getgenv().gui = Instance.new("ScreenGui")
        getgenv().gui.Name = getgenv().guiName
        getgenv().gui.Parent = game:GetService("CoreGui")

        local jumpButton = Instance.new("TextButton")
        jumpButton.Size = UDim2.new(0, 100, 0, 90)
        jumpButton.Position = UDim2.new(1, -110, 1, -120)
        jumpButton.Text = "Jump"
        jumpButton.Font = Enum.Font.Gotham
        jumpButton.TextSize = 14
        jumpButton.TextColor3 = Color3.new(1, 1, 1)
        jumpButton.BackgroundColor3 = Color3.new(0.12, 0.12, 0.12)
        jumpButton.BackgroundTransparency = 0.6
        jumpButton.BorderSizePixel = 0
        jumpButton.Parent = getgenv().gui

        local isPressed = false

        getgenv().connections[1] = jumpButton.MouseButton1Down:Connect(function()
            isPressed = true
        end)

        getgenv().connections[2] = jumpButton.MouseButton1Up:Connect(function()
            isPressed = false
        end)

        getgenv().connections[3] = game:GetService("RunService").RenderStepped:Connect(function()
            if isPressed then
                local humanoid = getgenv().player.Character and getgenv().player.Character:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end
        end)
    end
end

Library.addToggle(tab8, "Jump into second life.", false, function(state)
    getgenv().toggleJumpFeature(state)
end)

Library.addButton(tab8, "fling all", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/HpNf0TYX"))()
end)

Library.addButton(tab8, "ReJoin", function()
    local ts = game:GetService("TeleportService")
    local p = game:GetService("Players").LocalPlayer
    ts:Teleport(game.PlaceId, p)
end)

Library.addButton(tab8, "Server hop", function() 
    local function serverHop()
        local teleportService = game:GetService("TeleportService")
        teleportService:Teleport(game.PlaceId)
    end

    serverHop()
end)

game.StarterGui:SetCore("SendNotification", {
    Icon = "rbxassetid://119807919776183";
    Title = "CapybaraScript", 
    Text = "Did you know that this script \n was made by 1 developer?"
})
